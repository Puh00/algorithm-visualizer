{"version":3,"sources":["components/common/Header.tsx","assets/github.png","utils/Sleep.ts","utils/Array.ts","utils/Path.ts","utils/Coordinates.ts","utils/Random.ts","utils/Maze.ts","core/maze/BinaryTree.ts","core/maze/Eller.ts","core/maze/Kruskal.ts","core/maze/Prim.ts","core/maze/RecursiveBacktracking.ts","core/maze/RecursiveDivision.ts","core/maze/MazeFactory.ts","core/pathfinding/Astar.ts","core/pathfinding/UCS.ts","core/pathfinding/PathfindingFactory.ts","components/common/AlgorithmButtonGroup.tsx","components/pathfinding/CellButton.tsx","components/pathfinding/Grid.tsx","components/pathfinding/Popover.tsx","components/pathfinding/Panel.tsx","components/pathfinding/PathfindingVisualizer.tsx","core/model/Color.ts","core/sorting/BubbleSort.ts","core/sorting/CocktailSort.ts","core/sorting/HeapSort.ts","core/sorting/InsertionSort.ts","core/sorting/MergeSort.ts","core/sorting/QuickSort.ts","core/sorting/SelectionSort.ts","core/sorting/SortingFactory.ts","components/sorting/Panel.tsx","components/sorting/SortingVisualizer.tsx","App.tsx","index.tsx"],"names":["Header","Navbar","expand","bg","variant","className","Container","Brand","href","OverlayTrigger","placement","overlay","Tooltip","id","src","alt","Toggle","aria-controls","Collapse","Nav","Link","as","to","sleep","delay","Promise","resolve","setTimeout","swap","arr","x","y","setState","extractPath","entry","path","pqe","unshift","coord","backPointer","console","log","length","yDir","xDir","adjacentCoords","c","n","m","offset","coords","i","row","col","push","isSameCoord","c1","c2","alignmentBetweenCoordinates","p","q","Math","max","min","Error","closestOddCoord","randomNumber","floor","random","randomOddCoordinates","popRandomElementFromSet","set","size","rs","Array","from","values","delete","markAllCellsAsWalls","grid","setGrid","isWall","carveHorizontaly","a","carveVertically","carvePassageBetweenAdjacentCoordinates","alignment","BinaryTree","dirs","dir","coinflip","populate","sets","Set","_mergeSets","set1","set2","merged","forEach","value","add","mergeSets","val","index","removeRandomElements","s","horizontalConnections","verticalConnections","unique","nextRow","fill","Eller","Tree","parent","this","root","tree","setOfPossibleEdges","edges","Kruskal","isConnected","connect","passages","filter","mark","frontier","walls","item","Prim","startCoord","neighbours","shuffle","array","temp","j","carvePassagesFrom","visited","RecursiveBacktracking","addHWall","minX","maxX","hole","isStart","isFinish","addVWall","minY","maxY","addOuterWalls","divideHorizontally","divide","divideVertically","RecursiveDivision","getMazeAlgorithm","algorithmType","manhattanDistance","abs","fudge","crossProduct","start","dx1","dy1","dx2","dy2","cross","guessCost","heuristic","astar","goal","pq","PriorityQueue","comparator","p1","p2","costToHere","queue","dequeue","success","isActive","costToNext","UCS","getPathfindingAlgorithm","algorithm","AlgorithmButtonGroup","defaultAlgorithm","algorithms","setAlgorithm","ButtonGroup","map","alg","ToggleButton","type","checked","onChange","e","currentTarget","name","cellColor","cell","isPath","cssAnimation","CellButton","mouseDown","onMouseDown","onMouseEnter","onMouseUp","Button","style","backgroundColor","Grid","mode","setMode","setStart","finish","setFinish","searching","React","useState","setMouseDown","toggleWall","handleMouseUp","handleMouseDown","handleMouseEnter","moveFinish","moveStart","background","border","outline","display","height","width","cursor","marginBottom","onClick","onMouseLeave","popover","Popover","Title","Content","Panel","heuristics","setHeuristic","resetGrid","removePath","search","mazes","generateMaze","justifyContent","alignItems","DropdownButton","title","menuAlign","Dropdown","Item","SplitButton","toggleLabel","alignRight","charAt","toUpperCase","slice","disabled","h","newGrid","noHorizontalCells","window","innerWidth","noVerticalCells","innerHeight","calculateCells","_","drawPath","res","PathfindingVisualizer","setSearching","searcher","then","relocateStartAndFinishToOddCoords","newStart","newFinish","mazeGenerator","fluid","padding","Row","Col","md","RED","BLUE","GREEN","animation","bars","color","bubbleSort","greatestElementIndex","num","cocktailSort","swapped","end","heapify","largest","right","left","heapSort","insertionSort","nextGap","gap","ceil","inPlaceMerge","_sort","mid","mergeSort","partitionIndex","getMedian","midpoint","partition","pivotIndex","pivot","quicksort","selectionSort","iMin","getSortingAlgorithm","handleNumberChange","sort","reset","setDelay","textAlign","parseInt","target","step","onKeyDown","preventDefault","SortingVisualizer","setBars","setNum","resetBars","useEffect","sorter","Number","bar","idx","App","exact","component","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.d9b3d8e9.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nimport {\r\n  Container,\r\n  Nav,\r\n  Navbar,\r\n  OverlayTrigger,\r\n  Tooltip,\r\n} from 'react-bootstrap';\r\nimport { Link } from 'react-router-dom';\r\n\r\nimport logo from '../../assets/github.png';\r\n\r\nexport const Header = (): JSX.Element => {\r\n  return (\r\n    <Navbar expand=\"md\" bg=\"dark\" variant=\"dark\" className=\"app-vanish\">\r\n      <Container>\r\n        <Navbar.Brand href=\"https://github.com/Puh00/algorithm-visualizer\">\r\n          <OverlayTrigger\r\n            placement=\"bottom\"\r\n            overlay={<Tooltip id=\"tip\">View Project</Tooltip>}\r\n          >\r\n            <img src={logo} alt=\"github logo\" />\r\n          </OverlayTrigger>\r\n        </Navbar.Brand>\r\n        <Navbar.Toggle aria-controls=\"basic-navbar-nav\" />\r\n        <Navbar.Collapse id=\"basic-navbar-nav\">\r\n          <Nav className=\"me-auto\">\r\n            <Nav.Link as={Link} to=\"/sorting\">\r\n              Sorting\r\n            </Nav.Link>\r\n            <Nav.Link as={Link} to=\"/pathfinding\">\r\n              Pathfinding\r\n            </Nav.Link>\r\n          </Nav>\r\n        </Navbar.Collapse>\r\n      </Container>\r\n    </Navbar>\r\n  );\r\n};\r\n","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RERCMUIwOUY4NkNFMTFFM0FBNTJFRTMzNTJEMUJDNDYiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RERCMUIwOUU4NkNFMTFFM0FBNTJFRTMzNTJEMUJDNDYiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU1MTc4QTJBOTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU1MTc4QTJCOTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+jUqS1wAAApVJREFUeNq0l89rE1EQx3e3gVJoSPzZeNEWPKgHoa0HBak0iHiy/4C3WvDmoZ56qJ7txVsPQu8qlqqHIhRKJZceesmhioQEfxTEtsoSpdJg1u/ABJ7Pmc1m8zLwgWTmzcw3L+/te+tHUeQltONgCkyCi2AEDHLsJ6iBMlgHL8FeoqokoA2j4CloRMmtwTmj7erHBXPgCWhG6a3JNXKdCiDl1cidVbXZkJoXQRi5t5BrxwoY71FzU8S4JuAIqFkJ2+BFSlEh525b/hr3+k/AklDkNsf6wTT4yv46KIMNpsy+iMdMc47HNWxbsgVcUn7FmLAzzoFAWDsBx+wVP6bUpp5ewI+DOeUx0Wd9D8F70BTGNjkWtqnhmT1JQAHcUgZd8Lo3rQb1LAT8eJVUfgGvHQigGp+V2Z0iAUUl8QH47kAA1XioxIo+bRN8OG8F/oBjwv+Z1nJgX5jpdzQDw0LCjsPmrcW7I/iHScCAEDj03FtD8A0EyuChHgg4KTlJQF3wZ7WELppnBX+dBFSVpJsOBWi1qiRgSwnOgoyD5hmuJdkWCVhTgnTvW3AgYIFrSbZGh0UW/Io5Vp+DQoK7o80pztWMemZbgxeNwCNwDbw1fIfgGZjhU6xPaJgBV8BdsMw5cbZoHsenwYFxkZzl83xTSKTiviCAfCsJLysH3POfC8m8NegyGAGfLP/VmGmfSChgXroR0RSWjEFv2J/nG84cuKFMf4sTCZqXuJd4KaXFVjEG3+tw4eXbNK/YC9oXXs3O8NY8y99L4BXY5cvLY/Bb2VZ58EOJVcB18DHJq9lRsKr8inyKGVjlmh29mtHs3AHfuhCwy1vXT/Nu2GKQt+UHsGdctyX6eQyNvc+5sfX9Dl7Pe2J/BRgAl2CpwmrsHR0AAAAASUVORK5CYII=\"","export const sleep = (delay: number): Promise<void> =>\r\n  new Promise((resolve) => setTimeout(resolve, delay));\r\n","export const swap = <T>(\r\n  arr: T[],\r\n  x: number,\r\n  y: number,\r\n  setState?: React.Dispatch<React.SetStateAction<T[]>>\r\n): void => {\r\n  [arr[y], arr[x]] = [arr[x], arr[y]];\r\n  if (setState) setState([...arr]);\r\n};\r\n","import { Coord } from '../core/model/Cell';\r\nimport { PQEntry } from '../core/model/PQEntry';\r\n\r\n/**\r\n * Extract the full path from start to goal\r\n * @param entry the final priority queue entry\r\n * @returns the path from start to goal as a list of cells\r\n */\r\nexport const extractPath = (entry: PQEntry): Coord[] => {\r\n  const path = [];\r\n  let pqe: PQEntry | null = entry;\r\n  while (pqe !== null) {\r\n    path.unshift(pqe.coord);\r\n    pqe = pqe.backPointer;\r\n  }\r\n  console.log(path.length);\r\n  return path;\r\n};\r\n","import { Coord } from '../core/model/Cell';\r\n\r\n// Direction vectors: [Up, Right, Down, Left]\r\nconst yDir = [-1, 0, 1, 0];\r\nconst xDir = [0, 1, 0, -1];\r\n\r\n/**\r\n * Retrieves adjacent coordinates that shares a border with the given coordinate.\r\n * @param c the coordinate to evaluate.\r\n * @param n the height of the grid.\r\n * @param m the width of the grid.\r\n * @param offset by default, the function will only give neighbours that are 1 unit away.\r\n * @returns adjacent coordinates that are within bounds.\r\n */\r\nexport const adjacentCoords = (\r\n  c: Coord,\r\n  n: number,\r\n  m: number,\r\n  offset = 1\r\n): Coord[] => {\r\n  const coords: Coord[] = [];\r\n  for (let i = 0; i < 4; i++) {\r\n    const row = c.y + yDir[i] * offset;\r\n    const col = c.x + xDir[i] * offset;\r\n    if (row >= 0 && col >= 0 && row < n && col < m) {\r\n      coords.push({ x: col, y: row });\r\n    }\r\n  }\r\n  return coords;\r\n};\r\n\r\n// Since Typescript compare by references...\r\nexport const isSameCoord = (c1: Coord, c2: Coord): boolean =>\r\n  c1.x === c2.x && c1.y === c2.y;\r\n\r\ntype dir = 'HORIZONTAL' | 'VERTICAL';\r\n\r\n/**\r\n * Calculates the alignement between two coordinates.\r\n * @param p the first coordinate.\r\n * @param q the second coordinate.\r\n * @throws will throw an error if the coordinates are neither vertically or\r\n * horizontally aligned\r\n * @returns the alignment between the coordinates.\r\n */\r\nexport const alignmentBetweenCoordinates = (p: Coord, q: Coord): dir => {\r\n  if (Math.max(p.y, q.y) - Math.min(p.y, q.y) === 0) return 'HORIZONTAL';\r\n  else if (Math.max(p.x, q.x) - Math.min(p.x, q.x) === 0) return 'VERTICAL';\r\n  else throw new Error('Neither horizontally or vertically aligned');\r\n};\r\n\r\n/**\r\n * If {p} is not located at odd coordinates, modify it so that the coordinates are odd.\r\n * @param p the coordinates.\r\n * @returns odd coordinates.\r\n */\r\nexport const closestOddCoord = (p: Coord): Coord => {\r\n  if (p.x < 0 || p.y < 0) throw new Error('Invalid negative coordinate');\r\n  const x = p.x % 2 !== 0 ? p.x : p.x - 1 < 1 ? p.x + 1 : p.x - 1;\r\n  const y = p.y % 2 !== 0 ? p.y : p.y - 1 < 1 ? p.y + 1 : p.y - 1;\r\n  return { x, y };\r\n};\r\n","import { Coord } from '../core/model/Cell';\r\n\r\n// inclusive: [min, max]\r\nexport const randomNumber = (min: number, max: number): number =>\r\n  Math.floor(Math.random() * (max - min + 1) + min);\r\n\r\n/**\r\n * Produces a random odd coordinate within the bounds of the given paramters\r\n * @param n Vertical size.\r\n * @param m Horizontal size.\r\n * @returns a random odd coordinate.\r\n */\r\nexport const randomOddCoordinates = (n: number, m: number): Coord => {\r\n  const x = randomNumber(2, m - 1);\r\n  const y = randomNumber(2, n - 1);\r\n  return { x: x % 2 === 0 ? x - 1 : x, y: y % 2 === 0 ? y - 1 : y };\r\n};\r\n\r\n/**\r\n * Removes a random element from the set and returns that object as the\r\n * value of this function\r\n * @param set the set to pick a random element from.\r\n * @throws will throw an error if the set is empty.\r\n * @returns the randomly picked element.\r\n */\r\nexport const popRandomElementFromSet = <T>(set: Set<T>): T => {\r\n  if (set.size === 0) throw new Error('Empty Set');\r\n  const rs = Array.from(set.values())[Math.floor(Math.random() * set.size)];\r\n  set.delete(rs);\r\n  return rs;\r\n};\r\n","import { alignmentBetweenCoordinates, sleep } from '.';\r\nimport { Cell, Coord } from '../core/model/Cell';\r\n\r\n/**\r\n * Convert each cell in the grid to a wall.\r\n * @param grid the grid that has the state of every cell.\r\n * @param setGrid react hook to update the state of the grid.\r\n */\r\nexport const markAllCellsAsWalls = (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): void => {\r\n  for (let row = 0; row < grid.length; row++) {\r\n    for (let col = 0; col < grid[0].length; col++) {\r\n      grid[row][col].isWall = true;\r\n    }\r\n  }\r\n  setGrid([...grid]);\r\n};\r\n\r\n/**\r\n * Carves to the right from the given coordinate.\r\n * @param grid the grid to carve upon.\r\n * @param x x coordinate.\r\n * @param y y coordinate.\r\n * @param setGrid react hook to update the state of the grid.\r\n */\r\nexport const carveHorizontaly = async (\r\n  grid: Cell[][],\r\n  x: number,\r\n  y: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  for (let i = 0; i < 3; i++) grid[y][x + i].isWall = false;\r\n  setGrid([...grid]);\r\n  await sleep(1);\r\n};\r\n\r\n/**\r\n * Carves downwards from the given coordinate.\r\n * @param grid the grid to carve upon.\r\n * @param x x coordinate.\r\n * @param y y coordinate.\r\n * @param setGrid react hook to update the state of the grid.\r\n */\r\nexport const carveVertically = async (\r\n  grid: Cell[][],\r\n  x: number,\r\n  y: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  for (let i = 0; i < 3; i++) grid[y + i][x].isWall = false;\r\n  setGrid([...grid]);\r\n  await sleep(1);\r\n};\r\n\r\n/**\r\n * Carve a passage between two coordinates if and only if they are adjacent\r\n * and vertically or horizontally aligned.\r\n * @param p starting coordinate.\r\n * @param q target coordinate.\r\n * @param grid the grid to carve upon.\r\n * @param setGrid react hook to update the state.\r\n */\r\nexport const carvePassageBetweenAdjacentCoordinates = async (\r\n  p: Coord,\r\n  q: Coord,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  const alignment = alignmentBetweenCoordinates(p, q);\r\n  if (alignment === 'HORIZONTAL')\r\n    // current cell and neighbour are horizontally aligned\r\n    await carveHorizontaly(grid, Math.min(p.x, q.x), p.y, setGrid);\r\n  else if (alignment === 'VERTICAL')\r\n    // ...vertically aligned\r\n    await carveVertically(grid, p.x, Math.min(p.y, q.y), setGrid);\r\n};\r\n","import {\r\n  carveHorizontaly,\r\n  carveVertically,\r\n  markAllCellsAsWalls,\r\n  randomNumber,\r\n} from '../../utils';\r\nimport { Cell } from '../model/Cell';\r\n\r\n// Binary Tree with Southeast bias\r\nexport const BinaryTree = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n\r\n  for (let row = 1; row < grid.length; row++) {\r\n    if (row % 2 === 0) continue;\r\n    for (let col = 1; col < grid[0].length; col++) {\r\n      if (col % 2 === 0) continue;\r\n      const dirs: string[] = [];\r\n      // if within bounds add the direction\r\n      if (col + 2 < grid[0].length - 1) dirs.push('EAST');\r\n      if (row + 2 < grid.length - 1) dirs.push('SOUTH');\r\n\r\n      const dir = dirs[randomNumber(0, dirs.length - 1)];\r\n      if (dir === 'EAST') await carveHorizontaly(grid, col, row, setGrid);\r\n      else if (dir === 'SOUTH') await carveVertically(grid, col, row, setGrid);\r\n    }\r\n  }\r\n};\r\n","import {\r\n  carveHorizontaly,\r\n  carveVertically,\r\n  markAllCellsAsWalls,\r\n  popRandomElementFromSet,\r\n} from '../../utils';\r\nimport { Cell } from '../model/Cell';\r\n\r\nconst coinflip = (): boolean => Math.random() > 0.5;\r\n\r\n/**\r\n * Replaces all of the null values in the current row with a new set\r\n * @param sets the array containing the sets of the current row.\r\n */\r\nconst populate = (sets: Array<Set<number> | null>): void => {\r\n  for (let i = 1; i < sets.length; i += 2) if (!sets[i]) sets[i] = new Set([i]);\r\n};\r\n\r\nconst _mergeSets = (\r\n  set1: Set<number> | null,\r\n  set2: Set<number> | null\r\n): Set<number> => {\r\n  if (!set1 || !set2) throw new Error(\"Can't merge undefined sets\");\r\n  const merged: Set<number> = new Set();\r\n  set1.forEach((value) => merged.add(value));\r\n  set2.forEach((value) => merged.add(value));\r\n  return merged;\r\n};\r\n\r\n/**\r\n * Merge two sets if and only if they are disjoint.\r\n *\r\n * Also updates previous sets to match with the newly merged set.\r\n *\r\n * @param sets the array containing the sets of the current row.\r\n * @param set1 the first coordinate's set.\r\n * @param set2 the second coordinate's set.\r\n * @param col x coordinate.\r\n * @param row y coordinate.\r\n * @param grid the grid to work with.\r\n * @param setGrid react hook to update the state of the grid.\r\n */\r\nconst mergeSets = async (\r\n  sets: Array<Set<number> | null>,\r\n  set1: Set<number> | null,\r\n  set2: Set<number> | null,\r\n  col: number,\r\n  row: number,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  if (set1 === set2) return;\r\n  const merged = _mergeSets(set1, set2);\r\n  [sets[col], sets[col + 2]] = [merged, merged];\r\n  // manually update earlier identical sets\r\n  sets.forEach((val, index) => {\r\n    if (val === set1 || val === set2) sets[index] = merged;\r\n  });\r\n  await carveHorizontaly(grid, col, row, setGrid);\r\n};\r\n\r\n/**\r\n * For each element in the set, randomly decide whether to remove it or not.\r\n * Ensures that there is at least one element left in the set.\r\n * @param s the set to manipulate.\r\n */\r\nconst removeRandomElements = (s: Set<number> | null): void => {\r\n  if (!s) throw new Error(\"Can't pop undefined set\");\r\n  for (let i = s.size; i > 1; i--) if (coinflip()) popRandomElementFromSet(s);\r\n};\r\n\r\nconst horizontalConnections = async (\r\n  sets: Array<Set<number> | null>,\r\n  row: number,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  for (let col = 1; col < grid[0].length; col += 2) {\r\n    // skip if out of bounds\r\n    if (!grid[row][col + 2]) continue;\r\n\r\n    const [set1, set2] = [sets[col], sets[col + 2]];\r\n\r\n    if (row !== grid.length - 2) {\r\n      if (coinflip())\r\n        // randomly join adjacent cells, given that they are disjoint\r\n        await mergeSets(sets, set1, set2, col, row, grid, setGrid);\r\n    }\r\n    // last row, connect all adjacent disjoint sets\r\n    else await mergeSets(sets, set1, set2, col, row, grid, setGrid);\r\n  }\r\n};\r\n\r\n/**\r\n * Randomly create vertical connections downward to the next row\r\n *\r\n * @param sets the array containing the state of the current row.\r\n * @param row y coordinate.\r\n * @param grid the grid to work with.\r\n * @param setGrid react hook to update the state of the grid.\r\n * @returns the sets in the next row.\r\n */\r\nconst verticalConnections = async (\r\n  sets: Array<Set<number> | null>,\r\n  row: number,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<Array<Set<number> | null>> => {\r\n  const unique = [...new Set(sets)];\r\n  for (let i = 1; i < unique.length; i++) removeRandomElements(unique[i]);\r\n\r\n  const nextRow: Array<Set<number> | null> = Array(grid[0].length).fill(null);\r\n\r\n  for (let i = 1; i < unique.length; i++) {\r\n    const set = unique[i];\r\n    if (!set) throw new Error('Undefined set');\r\n    for (const col of set) {\r\n      await carveVertically(grid, col, row, setGrid);\r\n      nextRow[col] = set;\r\n    }\r\n  }\r\n  return nextRow;\r\n};\r\n\r\nexport const Eller = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n  const [n, m] = [grid.length, grid[0].length];\r\n\r\n  // each cell in the row belongs to a set\r\n  // cells that share a set, also shares a path\r\n  let sets: Array<Set<number> | null> = Array(m).fill(null);\r\n\r\n  for (let row = 1; row < n; row += 2) {\r\n    // give undiscovered cells from previous iteration a set\r\n    populate(sets);\r\n\r\n    await horizontalConnections(sets, row, grid, setGrid);\r\n    // last row: skip creating vertical connections at the bottom of the grid\r\n    if (row === n - 2) return;\r\n    sets = await verticalConnections(sets, row, grid, setGrid);\r\n  }\r\n};\r\n","import {\r\n  carvePassageBetweenAdjacentCoordinates,\r\n  markAllCellsAsWalls,\r\n  popRandomElementFromSet,\r\n} from '../../utils';\r\nimport { Cell, Coord } from '../model/Cell';\r\n\r\ninterface Edge {\r\n  p: Coord;\r\n  q: Coord;\r\n}\r\n\r\n// Simple Tree data structure to see if two \"sets\" are disjoint\r\nclass Tree {\r\n  parent: Tree | undefined;\r\n\r\n  root(): Tree {\r\n    return this.parent ? this.parent.root() : this;\r\n  }\r\n\r\n  isConnected(tree: Tree): boolean {\r\n    return this.root() === tree.root();\r\n  }\r\n\r\n  connect(tree: Tree): void {\r\n    tree.root().parent = this;\r\n  }\r\n}\r\n\r\n// Returns a set of all possible edges in the given grid\r\nconst setOfPossibleEdges = (grid: Cell[][]): Set<Edge> => {\r\n  const edges = new Set<Edge>();\r\n  for (let row = 1; row < grid.length; row++) {\r\n    if (row % 2 === 0) continue;\r\n    for (let col = 1; col < grid[0].length; col++) {\r\n      if (col % 2 === 0) continue;\r\n      const x = col + 2;\r\n      const y = row + 2;\r\n      // East neighbour\r\n      if (x < grid[0].length - 1)\r\n        edges.add({ p: { x: col, y: row }, q: { x: x, y: row } });\r\n      // South neighbour\r\n      if (y < grid.length - 1)\r\n        edges.add({ p: { x: col, y: row }, q: { x: col, y } });\r\n    }\r\n  }\r\n  return edges;\r\n};\r\n\r\nexport const Kruskal = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n\r\n  // each cell is assigned a set to indicate who they belong to\r\n  const sets: Tree[][] = Array.from(Array(grid.length), () =>\r\n    Array.from(Array(grid[0].length), () => new Tree())\r\n  );\r\n\r\n  const edges = setOfPossibleEdges(grid);\r\n\r\n  while (edges.size !== 0) {\r\n    const { p, q } = popRandomElementFromSet(edges);\r\n    const [set1, set2] = [sets[p.y][p.x], sets[q.y][q.x]];\r\n    if (!set1.isConnected(set2)) {\r\n      set1.connect(set2);\r\n      await carvePassageBetweenAdjacentCoordinates(p, q, grid, setGrid);\r\n    }\r\n  }\r\n};\r\n","import {\r\n  adjacentCoords,\r\n  carvePassageBetweenAdjacentCoordinates,\r\n  markAllCellsAsWalls,\r\n  popRandomElementFromSet,\r\n  randomNumber,\r\n  randomOddCoordinates,\r\n} from '../../utils';\r\nimport { Cell, Coord } from '../model/Cell';\r\n\r\n// Retrieves adjacent coordinates that are passages\r\nconst passages = (grid: Cell[][], c: Coord): Coord[] => {\r\n  return adjacentCoords(c, grid.length, grid[0].length, 2).filter(\r\n    (coord) => !grid[coord.y][coord.x].isWall\r\n  );\r\n};\r\n\r\n// Retrieves adjacent coordinates that are walls\r\nconst walls = (grid: Cell[][], c: Coord): Coord[] => {\r\n  return adjacentCoords(c, grid.length, grid[0].length, 2).filter(\r\n    (coord) => grid[coord.y][coord.x].isWall\r\n  );\r\n};\r\n\r\n// Add walls adjacent to the given coordinate, whilst also removing it\r\nconst mark = (coord: Coord, grid: Cell[][], frontier: Set<Coord>): void => {\r\n  walls(grid, coord).forEach((item) => frontier.add(item));\r\n  frontier.delete(coord);\r\n};\r\n\r\nexport const Prim = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n\r\n  const startCoord = randomOddCoordinates(grid.length, grid[0].length);\r\n  const frontier = new Set<Coord>();\r\n\r\n  // need to mark the first cell as path manually otherwise it's gonna crash\r\n  grid[startCoord.y][startCoord.x].isWall = false;\r\n  mark(startCoord, grid, frontier);\r\n\r\n  while (frontier.size !== 0) {\r\n    const p = popRandomElementFromSet(frontier);\r\n\r\n    // Skip if it has already been converted to a path\r\n    if (!grid[p.y][p.x].isWall) continue;\r\n\r\n    const neighbours = passages(grid, p);\r\n    if (neighbours.length !== 0) {\r\n      const q = neighbours[randomNumber(0, neighbours.length - 1)];\r\n      await carvePassageBetweenAdjacentCoordinates(p, q, grid, setGrid);\r\n    }\r\n    mark(p, grid, frontier);\r\n  }\r\n};\r\n","import React from 'react';\r\n\r\nimport {\r\n  adjacentCoords,\r\n  carvePassageBetweenAdjacentCoordinates,\r\n  markAllCellsAsWalls,\r\n  randomOddCoordinates,\r\n} from '../../utils';\r\nimport { Cell } from '../model/Cell';\r\n\r\nexport const shuffle = <T>(array: T[]): T[] => {\r\n  const temp = [...array];\r\n  for (let i = temp.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [temp[i], temp[j]] = [temp[j], temp[i]]; // shorthand for swap\r\n  }\r\n  return temp;\r\n};\r\n\r\nconst carvePassagesFrom = async (\r\n  x: number,\r\n  y: number,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const neighbours = shuffle(\r\n    adjacentCoords({ x, y }, grid.length, grid[0].length, 2)\r\n  );\r\n  visited[y][x] = true;\r\n\r\n  for (const n of neighbours) {\r\n    if (!visited[n.y][n.x]) {\r\n      visited[n.y][n.x] = true;\r\n      await carvePassageBetweenAdjacentCoordinates({ x, y }, n, grid, setGrid);\r\n      await carvePassagesFrom(n.x, n.y, grid, setGrid, visited);\r\n    }\r\n  }\r\n};\r\n\r\nexport const RecursiveBacktracking = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n  const [n, m] = [grid.length, grid[0].length];\r\n  const visited: boolean[][] = Array.from(Array(n), () => Array(m).fill(false));\r\n  const { x, y } = randomOddCoordinates(n, m);\r\n  await carvePassagesFrom(x, y, grid, setGrid, visited);\r\n};\r\n","/* eslint-disable @typescript-eslint/no-use-before-define */\r\nimport React from 'react';\r\n\r\nimport { randomNumber, sleep } from '../../utils';\r\nimport { Cell } from '../model/Cell';\r\n\r\nconst addHWall = async (\r\n  grid: Cell[][],\r\n  minX: number,\r\n  maxX: number,\r\n  y: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const hole = Math.floor(randomNumber(minX, maxX) / 2) * 2 + 1;\r\n  for (let i = minX; i <= maxX; i++) {\r\n    if (i === hole) visited[y][i] = true;\r\n    else if (!visited[y][i] && !grid[y][i].isStart && !grid[y][i].isFinish)\r\n      grid[y][i].isWall = true;\r\n  }\r\n  setGrid([...grid]);\r\n  await sleep(1);\r\n};\r\n\r\nconst addVWall = async (\r\n  grid: Cell[][],\r\n  minY: number,\r\n  maxY: number,\r\n  x: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const hole = Math.floor(randomNumber(minY, maxY) / 2) * 2 + 1;\r\n  for (let i = minY; i <= maxY; i++) {\r\n    if (i === hole) visited[i][x] = true;\r\n    else if (!visited[i][x] && !grid[i][x].isStart && !grid[i][x].isFinish)\r\n      grid[i][x].isWall = true;\r\n  }\r\n  setGrid([...grid]);\r\n  await sleep(1);\r\n};\r\n\r\nconst addOuterWalls = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  // vertical walls\r\n  for (let i = 0; i < grid.length; i++) {\r\n    grid[i][0].isWall = true;\r\n    grid[i][grid[0].length - 1].isWall = true;\r\n  }\r\n  // horizontal walls\r\n  for (let i = 0; i < grid[0].length; i++) {\r\n    grid[0][i].isWall = true;\r\n    grid[grid.length - 1][i].isWall = true;\r\n  }\r\n  setGrid([...grid]);\r\n};\r\n\r\nconst divideHorizontally = async (\r\n  grid: Cell[][],\r\n  minX: number,\r\n  maxX: number,\r\n  minY: number,\r\n  maxY: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const y = Math.floor(randomNumber(minY, maxY) / 2) * 2;\r\n  await addHWall(grid, minX, maxX, y, setGrid, visited);\r\n  // upper chamber\r\n  await divide(grid, minX, maxX, minY, y - 1, setGrid, visited);\r\n  // lower chamber\r\n  await divide(grid, minX, maxX, y + 1, maxY, setGrid, visited);\r\n};\r\n\r\nconst divideVertically = async (\r\n  grid: Cell[][],\r\n  minX: number,\r\n  maxX: number,\r\n  minY: number,\r\n  maxY: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const x = Math.floor(randomNumber(minX, maxX) / 2) * 2;\r\n  await addVWall(grid, minY, maxY, x, setGrid, visited);\r\n  // left chamber\r\n  await divide(grid, minX, x - 1, minY, maxY, setGrid, visited);\r\n  // right chamber\r\n  await divide(grid, x + 1, maxX, minY, maxY, setGrid, visited);\r\n};\r\n\r\nconst divide = async (\r\n  grid: Cell[][],\r\n  minX: number,\r\n  maxX: number,\r\n  minY: number,\r\n  maxY: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  if (maxX - minX < 2 || maxY - minY < 2) return;\r\n  if (maxX - minX < maxY - minY) {\r\n    divideHorizontally(grid, minX, maxX, minY, maxY, setGrid, visited);\r\n  } else if (maxY - minY < maxX - minX) {\r\n    divideVertically(grid, minX, maxX, minY, maxY, setGrid, visited);\r\n  } else {\r\n    if (randomNumber(0, 1) === 0)\r\n      divideHorizontally(grid, minX, maxX, minY, maxY, setGrid, visited);\r\n    else divideVertically(grid, minX, maxX, minY, maxY, setGrid, visited);\r\n  }\r\n};\r\n\r\nexport const RecursiveDivision = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  const visited: boolean[][] = Array.from(Array(grid.length), () =>\r\n    Array(grid[0].length).fill(false)\r\n  );\r\n  await addOuterWalls(grid, setGrid);\r\n  await divide(\r\n    grid,\r\n    1,\r\n    grid[0].length - 2,\r\n    1,\r\n    grid.length - 2,\r\n    setGrid,\r\n    visited\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { Cell } from '../model/Cell';\r\nimport { BinaryTree } from './BinaryTree';\r\nimport { Eller } from './Eller';\r\nimport { Kruskal } from './Kruskal';\r\nimport { Prim } from './Prim';\r\nimport { RecursiveBacktracking } from './RecursiveBacktracking';\r\nimport { RecursiveDivision } from './RecursiveDivision';\r\n\r\ntype mazeFunc = (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n) => Promise<void>;\r\n\r\nexport const getMazeAlgorithm = (algorithmType: string): mazeFunc => {\r\n  if (algorithmType === 'division') return RecursiveDivision;\r\n  else if (algorithmType === 'backtracking') return RecursiveBacktracking;\r\n  else if (algorithmType === 'binary') return BinaryTree;\r\n  else if (algorithmType === 'prim') return Prim;\r\n  else if (algorithmType === 'kruskal') return Kruskal;\r\n  else if (algorithmType === 'eller') return Eller;\r\n  else throw new Error('Invalid argument for Maze Algorithm');\r\n};\r\n","import React from 'react';\r\n\r\nimport PriorityQueue from 'ts-priority-queue';\r\n\r\nimport { adjacentCoords, extractPath, isSameCoord, sleep } from '../../utils';\r\nimport { Cell, Coord } from '../model/Cell';\r\nimport { PQEntry, Result } from '../model/PQEntry';\r\n\r\n// _____Different tie breakers_____\r\n/**\r\n * Calulates the Manhattan distance between the given coordinates.\r\n * @param p the first coordinate.\r\n * @param q the second coordinate.\r\n * @returns the Manhattan distance between the two coordinates.\r\n */\r\nconst manhattanDistance = (p: Coord, q: Coord): number =>\r\n  Math.abs(p.x - q.x) + Math.abs(p.y - q.y);\r\n\r\n/**\r\n * Nudge the scale of [h] slightly so that the heuristic favours nodes closer to the goal.\r\n * - Inadmissible heuristic\r\n * From {@link https://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html}\r\n * @param p the current coordinate.\r\n * @param q the target coordinate.\r\n * @returns modified heuristic.\r\n */\r\nconst fudge = (p: Coord, q: Coord): number => {\r\n  const heuristic = manhattanDistance(p, q);\r\n  return heuristic * (1 + 1 / 1000);\r\n};\r\n\r\n/**\r\n * Heuristic that prefers a path that lies along the straight line from the start to the\r\n * goal\r\n * - Inadmissible heuristic\r\n * From {@link https://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html}\r\n * @param start starting coordinate.\r\n * @param p the current coordinate.\r\n * @param q the target coordinate.\r\n * @returns modified heuristic.\r\n */\r\nconst crossProduct = (start: Coord, p: Coord, q: Coord): number => {\r\n  const dx1 = p.x - q.x;\r\n  const dy1 = p.y - q.y;\r\n  const dx2 = start.x - q.x;\r\n  const dy2 = start.y - q.y;\r\n  const cross = Math.abs(dx1 * dy2 - dx2 * dy1);\r\n  const heuristic = manhattanDistance(p, q);\r\n  return heuristic + cross * 0.001;\r\n};\r\n\r\n// Delegate calculation of heuristic\r\nconst guessCost = (\r\n  start: Coord,\r\n  p: Coord,\r\n  q: Coord,\r\n  heuristic = 'manhattan'\r\n): number => {\r\n  if (heuristic === 'manhattan') return manhattanDistance(p, q);\r\n  else if (heuristic === 'fudge') return fudge(p, q);\r\n  else if (heuristic === 'cross') return crossProduct(start, p, q);\r\n  else throw new Error('Invalid heuristic type');\r\n};\r\n\r\n/**\r\n * A* search algorithm\r\n * @param start the starting coordinate.\r\n * @param goal the target coordinate.\r\n * @param grid the grid that has the state of every cell.\r\n * @param setGrid react hook to update the state of the grid.\r\n * @returns the path from start to goal if the algorithm successfully found the target.\r\n */\r\nexport const astar = async (\r\n  start: Coord,\r\n  goal: Coord,\r\n  grid: Cell[][],\r\n  setState: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  heuristic?: string\r\n): Promise<Result> => {\r\n  const [n, m] = [grid.length, grid[0].length];\r\n\r\n  // Auxiliary array keeping track of visited cells\r\n  const visited: boolean[][] = Array.from(Array(n), () => Array(m).fill(false));\r\n\r\n  const pq = new PriorityQueue<PQEntry>({\r\n    comparator: (p1, p2) => {\r\n      // bug: 'if (p1.guessCost)' will return false if p1.guessCost is 0\r\n      if (\r\n        typeof p1.guessCost !== 'undefined' &&\r\n        typeof p2.guessCost !== 'undefined'\r\n      )\r\n        return p1.costToHere + p1.guessCost - (p2.costToHere + p2.guessCost);\r\n      else throw new Error(\"Undefined field 'guessCost' in PQEntry\");\r\n    },\r\n  });\r\n\r\n  // Add starting cell to be searched\r\n  pq.queue({\r\n    coord: start,\r\n    costToHere: 0,\r\n    backPointer: null,\r\n    guessCost: guessCost(start, start, goal, heuristic),\r\n  });\r\n\r\n  while (pq.length !== 0) {\r\n    const entry = pq.dequeue();\r\n\r\n    if (isSameCoord(entry.coord, goal))\r\n      return { success: true, path: extractPath(entry) };\r\n\r\n    if (\r\n      !visited[entry.coord.y][entry.coord.x] &&\r\n      !grid[entry.coord.y][entry.coord.x].isWall\r\n    ) {\r\n      visited[entry.coord.y][entry.coord.x] = true;\r\n\r\n      // mark visited cells\r\n      grid[entry.coord.y][entry.coord.x].isActive = true;\r\n      setState([...grid]);\r\n      await sleep(1);\r\n\r\n      for (const c of adjacentCoords(entry.coord, n, m)) {\r\n        const costToNext = entry.costToHere + 1;\r\n        pq.queue({\r\n          coord: c,\r\n          costToHere: costToNext,\r\n          backPointer: entry,\r\n          guessCost: guessCost(start, c, goal, heuristic),\r\n        });\r\n      }\r\n    }\r\n  }\r\n  return { success: false, path: null };\r\n};\r\n","import React from 'react';\r\n\r\nimport PriorityQueue from 'ts-priority-queue';\r\n\r\nimport { adjacentCoords, extractPath, isSameCoord, sleep } from '../../utils';\r\nimport { Cell, Coord } from '../model/Cell';\r\nimport { PQEntry, Result } from '../model/PQEntry';\r\n\r\n/**\r\n * Uniform-Cost Search\r\n * @param start the starting coordinate.\r\n * @param goal the target coordinate.\r\n * @param grid the grid that has the state of every cell.\r\n * @param setGrid react hook to update the state of the grid.\r\n * @returns the path from start to goal if the algorithm successfully found the target.\r\n */\r\nexport const UCS = async (\r\n  start: Coord,\r\n  goal: Coord,\r\n  grid: Cell[][],\r\n  setState: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<Result> => {\r\n  const [n, m] = [grid.length, grid[0].length];\r\n\r\n  // Auxiliary array keeping track of visited cells\r\n  const visited: boolean[][] = Array.from(Array(n), () => Array(m).fill(false));\r\n\r\n  const pq = new PriorityQueue<PQEntry>({\r\n    comparator: (p1, p2) => p1.costToHere - p2.costToHere,\r\n  });\r\n\r\n  // Add starting cell to be searched\r\n  pq.queue({ coord: start, costToHere: 0, backPointer: null });\r\n\r\n  while (pq.length !== 0) {\r\n    const entry = pq.dequeue();\r\n\r\n    if (isSameCoord(entry.coord, goal))\r\n      return { success: true, path: extractPath(entry) };\r\n\r\n    if (\r\n      !visited[entry.coord.y][entry.coord.x] &&\r\n      !grid[entry.coord.y][entry.coord.x].isWall\r\n    ) {\r\n      visited[entry.coord.y][entry.coord.x] = true;\r\n\r\n      // mark visited cells\r\n      grid[entry.coord.y][entry.coord.x].isActive = true;\r\n      setState([...grid]);\r\n      await sleep(1);\r\n\r\n      for (const c of adjacentCoords(entry.coord, n, m)) {\r\n        const costToNext = entry.costToHere + 1;\r\n        pq.queue({ coord: c, costToHere: costToNext, backPointer: entry });\r\n      }\r\n    }\r\n  }\r\n  return { success: false, path: null };\r\n};\r\n","import { Cell, Coord } from '../model/Cell';\r\nimport { Result } from '../model/PQEntry';\r\nimport { astar } from './Astar';\r\nimport { UCS } from './UCS';\r\n\r\ntype pathfindingFunc = (\r\n  start: Coord,\r\n  finish: Coord,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  heuristic?: string\r\n) => Promise<Result>;\r\n\r\nexport const getPathfindingAlgorithm = (algorithm: string): pathfindingFunc => {\r\n  if (algorithm === 'ucs') return UCS;\r\n  else if (algorithm === 'astar') return astar;\r\n  else throw new Error('Incorrect type for pathfinding algorithm');\r\n};\r\n","import React from 'react';\r\n\r\nimport { ButtonGroup, ToggleButton } from 'react-bootstrap';\r\n\r\ninterface Algorithm {\r\n  name: string;\r\n  value: string;\r\n}\r\n\r\ninterface Props {\r\n  defaultAlgorithm: string;\r\n  algorithms: Algorithm[];\r\n  setAlgorithm: React.Dispatch<React.SetStateAction<string>>;\r\n}\r\n\r\nexport const AlgorithmButtonGroup: React.FC<Props> = ({\r\n  defaultAlgorithm,\r\n  algorithms,\r\n  setAlgorithm,\r\n}: Props) => {\r\n  return (\r\n    <ButtonGroup className=\"p-1\">\r\n      {algorithms.map((alg) => (\r\n        <ToggleButton\r\n          key={alg.value}\r\n          type=\"radio\"\r\n          variant=\"outline-warning\"\r\n          value={alg.value}\r\n          checked={defaultAlgorithm === alg.value}\r\n          onChange={(e) => setAlgorithm(e.currentTarget.value)}\r\n        >\r\n          {alg.name}\r\n        </ToggleButton>\r\n      ))}\r\n    </ButtonGroup>\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { Button } from 'react-bootstrap';\r\n\r\nimport { Cell } from '../../core/model/Cell';\r\nimport './CellButton.css';\r\n\r\ninterface Props {\r\n  cell: Cell;\r\n  mouseDown: boolean;\r\n  onMouseDown: (row: number, col: number) => void;\r\n  onMouseEnter: (row: number, col: number) => void;\r\n  onMouseUp: () => void;\r\n}\r\n\r\nconst cellColor = (cell: Cell): string => {\r\n  if (cell.isWall) return 'grey';\r\n  else if (cell.isStart) return 'yellow';\r\n  else if (cell.isFinish) return 'blue';\r\n  else if (cell.isPath) return 'Chartreuse';\r\n  // or tomato for brighter\r\n  else if (cell.isActive) return 'crimson';\r\n  else return 'azure';\r\n};\r\n\r\nconst cssAnimation = (cell: Cell): string => {\r\n  return cell.isPath ? 'finish' : cell.isActive ? 'visited' : '';\r\n};\r\n\r\nexport const CellButton: React.FC<Props> = ({\r\n  cell,\r\n  mouseDown,\r\n  onMouseDown,\r\n  onMouseEnter,\r\n  onMouseUp,\r\n}: Props) => {\r\n  return (\r\n    <Button\r\n      className={`cell ${cssAnimation(cell)}`}\r\n      style={{\r\n        backgroundColor: cellColor(cell),\r\n      }}\r\n      onMouseEnter={() => {\r\n        if (mouseDown) onMouseEnter(cell.coord.y, cell.coord.x);\r\n      }}\r\n      onMouseDown={() => onMouseDown(cell.coord.y, cell.coord.x)}\r\n      onMouseUp={onMouseUp}\r\n    />\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { Cell, Coord } from '../../core/model/Cell';\r\nimport { CellButton } from './CellButton';\r\n\r\ninterface Props {\r\n  grid: Cell[][];\r\n  mode: string;\r\n  setMode: React.Dispatch<React.SetStateAction<string>>;\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>;\r\n  start: Coord;\r\n  setStart: React.Dispatch<React.SetStateAction<Coord>>;\r\n  finish: Coord;\r\n  setFinish: React.Dispatch<React.SetStateAction<Coord>>;\r\n  searching: boolean;\r\n}\r\n\r\nexport const Grid: React.FC<Props> = ({\r\n  grid,\r\n  mode,\r\n  setMode,\r\n  setGrid,\r\n  start,\r\n  setStart,\r\n  finish,\r\n  setFinish,\r\n  searching,\r\n}: Props) => {\r\n  const [mouseDown, setMouseDown] = React.useState<boolean>(false);\r\n\r\n  const toggleWall = (row: number, col: number): void => {\r\n    const cell = grid[row][col];\r\n    if (!cell.isStart && !cell.isFinish) {\r\n      cell.isWall = !cell.isWall;\r\n      setGrid([...grid]);\r\n    }\r\n  };\r\n\r\n  const moveStart = (row: number, col: number): void => {\r\n    grid[start.y][start.x].isStart = false;\r\n    const cell: Cell = grid[row][col];\r\n    cell.isStart = true;\r\n    setStart(cell.coord);\r\n    setGrid([...grid]);\r\n  };\r\n\r\n  const moveFinish = (row: number, col: number): void => {\r\n    grid[finish.y][finish.x].isFinish = false;\r\n    const cell = grid[row][col];\r\n    cell.isFinish = true;\r\n    setFinish(cell.coord);\r\n    setGrid([...grid]);\r\n  };\r\n\r\n  const handleMouseUp = (): void => setMouseDown(false);\r\n\r\n  const handleMouseDown = (row: number, col: number): void => {\r\n    if (grid[row][col].isStart) setMode('start');\r\n    else if (grid[row][col].isFinish) setMode('finish');\r\n    else {\r\n      setMode('wall');\r\n      toggleWall(row, col);\r\n    }\r\n    setMouseDown(true);\r\n  };\r\n\r\n  const handleMouseEnter = (row: number, col: number): void => {\r\n    if (mouseDown) {\r\n      if (mode === 'wall') toggleWall(row, col);\r\n      else if (mode === 'start' && !searching) moveStart(row, col);\r\n      else if (mode === 'finish' && !searching) moveFinish(row, col);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      {/*   */}\r\n      <button\r\n        style={{\r\n          background: 'transparent',\r\n          border: 'none',\r\n          outline: 'none',\r\n          display: 'block',\r\n          height: '5px',\r\n          width: '5px',\r\n          cursor: 'pointer',\r\n          marginBottom: '5px',\r\n        }}\r\n        onClick={() => {\r\n          for (let i = 0; i < grid.length; i++) {\r\n            grid[i][0].isWall = true;\r\n            grid[i][grid[0].length - 1].isWall = true;\r\n          }\r\n          // horizontal walls\r\n          for (let i = 0; i < grid[0].length; i++) {\r\n            grid[0][i].isWall = true;\r\n            grid[grid.length - 1][i].isWall = true;\r\n          }\r\n          for (let i = 0; i < grid.length - 1; i++) {\r\n            for (let j = 0; j < grid[0].length - 1; j++) {\r\n              if (i % 2 === 0 && j % 2 === 0) grid[i][j].isWall = true;\r\n            }\r\n          }\r\n          setGrid([...grid]);\r\n        }}\r\n      />\r\n      <div\r\n        onMouseDown={() => {\r\n          setMouseDown(true);\r\n        }}\r\n        onMouseUp={() => {\r\n          setMouseDown(false);\r\n        }}\r\n        onMouseLeave={() => {\r\n          setMouseDown(false);\r\n        }}\r\n      >\r\n        {grid.map((row, i) => (\r\n          <div key={i}>\r\n            {row.map((c, j) => (\r\n              <CellButton\r\n                cell={c}\r\n                key={j}\r\n                mouseDown={mouseDown}\r\n                onMouseDown={handleMouseDown}\r\n                onMouseEnter={handleMouseEnter}\r\n                onMouseUp={handleMouseUp}\r\n              />\r\n            ))}\r\n          </div>\r\n        ))}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { Popover } from 'react-bootstrap';\r\n\r\n/**\r\n * Basic popover explaining the different ways to calculate heuristic for A*\r\n */\r\nexport const popover = (\r\n  <Popover id=\"popover-basic\">\r\n    <Popover.Title as=\"h3\">A* Heuristic</Popover.Title>\r\n    <Popover.Content>\r\n      Different methods of calculating the heuristic in A*\r\n      <ul>\r\n        <li>\r\n          <strong>Manhattan distance</strong>:\r\n          <ul>\r\n            <li>Guarantees shortest path.</li>\r\n            <li>Trading speed for accuracy.</li>\r\n          </ul>\r\n        </li>\r\n        <li>\r\n          <strong>Fudge</strong>:\r\n          <ul>\r\n            <li>\r\n              Similar to A* except that the heuristic favours nodes closer to\r\n              the target.\r\n            </li>\r\n            <li>Finds a more direct route.</li>\r\n            <li>Inadmissible heuristic.</li>\r\n          </ul>\r\n        </li>\r\n        <li>\r\n          <strong>Cross</strong>:\r\n          <ul>\r\n            <li>\r\n              Prefers path that are along the straight line from the starting\r\n              point to the target.\r\n            </li>\r\n            <li>Nicer diagonal paths.</li>\r\n            <li>Inadmissible heuristic.</li>\r\n          </ul>\r\n        </li>\r\n      </ul>\r\n    </Popover.Content>\r\n  </Popover>\r\n);\r\n","import React from 'react';\r\n\r\nimport {\r\n  Button,\r\n  Dropdown,\r\n  DropdownButton,\r\n  OverlayTrigger,\r\n  SplitButton,\r\n} from 'react-bootstrap';\r\n\r\nimport { popover } from './Popover';\r\n\r\ninterface NameValue {\r\n  name: string;\r\n  value: string;\r\n}\r\n\r\ninterface Props {\r\n  algorithm: string;\r\n  AlgorithmButtonGroup: React.ReactNode;\r\n  heuristic: string;\r\n  heuristics: NameValue[];\r\n  setHeuristic: React.Dispatch<React.SetStateAction<string>>;\r\n  resetGrid: () => void;\r\n  removePath: () => void;\r\n  search: () => Promise<void>;\r\n  mazes: NameValue[];\r\n  generateMaze: (algorithmType: string) => Promise<void>;\r\n}\r\n\r\nexport const Panel: React.FC<Props> = ({\r\n  algorithm,\r\n  AlgorithmButtonGroup,\r\n  heuristic,\r\n  heuristics,\r\n  setHeuristic,\r\n  resetGrid,\r\n  removePath,\r\n  search,\r\n  mazes,\r\n  generateMaze,\r\n}: Props) => {\r\n  return (\r\n    <div\r\n      style={{\r\n        display: 'flex',\r\n        justifyContent: 'center',\r\n        alignItems: 'center',\r\n      }}\r\n    >\r\n      <DropdownButton variant=\"success\" title=\"Mazes\" menuAlign=\"left\">\r\n        {mazes.map((m, i) => (\r\n          <Dropdown.Item\r\n            as=\"button\"\r\n            key={i}\r\n            onClick={() => generateMaze(m.value)}\r\n          >\r\n            {m.name}\r\n          </Dropdown.Item>\r\n        ))}\r\n      </DropdownButton>\r\n      <SplitButton\r\n        id=\"reset\"\r\n        className=\"m-2\"\r\n        variant=\"danger\"\r\n        title={'Reset'}\r\n        toggleLabel=\"\"\r\n        onClick={resetGrid}\r\n      >\r\n        <Dropdown.Item onClick={removePath}>Clear path</Dropdown.Item>\r\n      </SplitButton>\r\n      <Button onClick={search} variant=\"primary\" className=\"m-1\">\r\n        Search!\r\n      </Button>\r\n      {AlgorithmButtonGroup}\r\n      <OverlayTrigger placement=\"right\" overlay={popover}>\r\n        <DropdownButton\r\n          alignRight={true}\r\n          className=\"m-1\"\r\n          variant=\"secondary\"\r\n          title={heuristic.charAt(0).toUpperCase() + heuristic.slice(1)}\r\n          disabled={algorithm !== 'astar'}\r\n        >\r\n          {heuristics.map((h) => (\r\n            <Dropdown.Item\r\n              as=\"button\"\r\n              key={h.value}\r\n              onClick={() => setHeuristic(h.value)}\r\n            >\r\n              {h.name}\r\n            </Dropdown.Item>\r\n          ))}\r\n        </DropdownButton>\r\n      </OverlayTrigger>\r\n    </div>\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { Col, Container, Row } from 'react-bootstrap';\r\n\r\nimport { getMazeAlgorithm } from '../../core/maze/MazeFactory';\r\nimport { Cell, Coord } from '../../core/model/Cell';\r\nimport { Result } from '../../core/model/PQEntry';\r\nimport { getPathfindingAlgorithm } from '../../core/pathfinding/PathfindingFactory';\r\nimport { closestOddCoord, sleep } from '../../utils';\r\nimport { AlgorithmButtonGroup } from '../common/AlgorithmButtonGroup';\r\nimport { Grid } from './Grid';\r\nimport { Panel } from './Panel';\r\n\r\nconst algorithms = [\r\n  { name: 'UCS', value: 'ucs' },\r\n  { name: 'A*', value: 'astar' },\r\n];\r\nconst mazes = [\r\n  { name: 'Recursive Division', value: 'division' },\r\n  { name: 'Recursive Backtracking', value: 'backtracking' },\r\n  { name: 'Binary Tree (Southeast bias)', value: 'binary' },\r\n  { name: \"Prim's Algorithm\", value: 'prim' },\r\n  { name: \"Kruskal's Algorithm\", value: 'kruskal' },\r\n  { name: \"Eller's Algorithm\", value: 'eller' },\r\n];\r\nconst heuristics = [\r\n  { name: 'Manhattan distance', value: 'manhattan' },\r\n  { name: 'Fudge', value: 'fudge' },\r\n  { name: 'Cross', value: 'cross' },\r\n];\r\n\r\n// Calculate how many cells fit the screen horizontally and vertically\r\nconst calculateCells = (): [number, number] => {\r\n  const noHorizontalCells = Math.floor(window.innerWidth / 30);\r\n  const noVerticalCells = Math.floor((window.innerHeight - 160) / 30);\r\n  // maze algorithm requires maze to have odd size\r\n  return [\r\n    noHorizontalCells % 2 === 0 ? noHorizontalCells - 1 : noHorizontalCells,\r\n    noVerticalCells % 2 === 0 ? noVerticalCells - 1 : noVerticalCells,\r\n  ];\r\n};\r\n\r\nconst newGrid = (start: Coord, finish: Coord): Cell[][] => {\r\n  const [n, m] = calculateCells();\r\n  const grid: Cell[][] = [...Array(m)].map((_, i) => {\r\n    return [...Array(n)].map((_, j) => ({\r\n      coord: { x: j, y: i },\r\n      isActive: false,\r\n      isPath: false,\r\n      isStart: false,\r\n      isFinish: false,\r\n      isWall: false,\r\n    }));\r\n  });\r\n  grid[start.y][start.x].isStart = true;\r\n  grid[finish.y][finish.x].isFinish = true;\r\n  return grid;\r\n};\r\n\r\nconst removePath = (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): void => {\r\n  for (let row = 0; row < grid.length; row++)\r\n    for (let col = 0; col < grid[0].length; col++) {\r\n      const cell = grid[row][col];\r\n      if (cell.isPath) cell.isPath = false;\r\n      if (cell.isActive) cell.isActive = false;\r\n    }\r\n  setGrid([...grid]);\r\n};\r\n\r\n// Draw the path received from pathfinding algorithm\r\nconst drawPath = async (\r\n  res: Result,\r\n  grid: Cell[][],\r\n  setState: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  if (res.path) {\r\n    for (const c of res.path) {\r\n      grid[c.y][c.x].isPath = true;\r\n      setState([...grid]);\r\n      await sleep(1);\r\n    }\r\n  }\r\n};\r\n\r\nexport const PathfindingVisualizer: React.FC = () => {\r\n  const [algorithm, setAlgorithm] = React.useState<string>('astar');\r\n  // to disable moving starting and finish cells during search\r\n  const [searching, setSearching] = React.useState<boolean>(false);\r\n  const [start, setStart] = React.useState<Coord>({ x: 1, y: 3 });\r\n  const [finish, setFinish] = React.useState<Coord>({ x: 7, y: 3 });\r\n  const [grid, setGrid] = React.useState<Cell[][]>(newGrid(start, finish));\r\n  const [mode, setMode] = React.useState<string>('wall');\r\n  const [heuristic, setHeuristic] = React.useState<string>('manhattan');\r\n\r\n  const search = async (): Promise<void> => {\r\n    const searcher = getPathfindingAlgorithm(algorithm);\r\n    setSearching(true);\r\n    await searcher(start, finish, grid, setGrid, heuristic).then(\r\n      async (res) => {\r\n        if (res.success) await drawPath(res, grid, setGrid);\r\n      }\r\n    );\r\n    setSearching(false);\r\n  };\r\n\r\n  // Move start and finish to odd coordinates (if they aren't already on odd coordinates)\r\n  const relocateStartAndFinishToOddCoords = (): void => {\r\n    grid[start.y][start.x].isStart = false;\r\n    grid[finish.y][finish.x].isFinish = false;\r\n    const newStart = closestOddCoord(start);\r\n    const newFinish = closestOddCoord(finish);\r\n    grid[newStart.y][newStart.x].isStart = true;\r\n    grid[newFinish.y][newFinish.x].isFinish = true;\r\n    setGrid([...grid]);\r\n    setStart(newStart);\r\n    setFinish(newFinish);\r\n  };\r\n\r\n  const generateMaze = async (algorithmType: string): Promise<void> => {\r\n    relocateStartAndFinishToOddCoords();\r\n    const mazeGenerator = getMazeAlgorithm(algorithmType);\r\n    await mazeGenerator(grid, setGrid);\r\n  };\r\n\r\n  return (\r\n    <Container fluid={true} style={{ padding: '0' }}>\r\n      <Row>\r\n        <Col\r\n          style={{\r\n            display: 'flex',\r\n            justifyContent: 'center',\r\n            alignItems: 'center',\r\n          }}\r\n        >\r\n          <Panel\r\n            AlgorithmButtonGroup={\r\n              <AlgorithmButtonGroup\r\n                defaultAlgorithm={algorithm}\r\n                algorithms={algorithms}\r\n                setAlgorithm={setAlgorithm}\r\n              />\r\n            }\r\n            algorithm={algorithm}\r\n            heuristic={heuristic}\r\n            heuristics={heuristics}\r\n            setHeuristic={setHeuristic}\r\n            resetGrid={() => setGrid(newGrid(start, finish))}\r\n            removePath={() => removePath(grid, setGrid)}\r\n            search={search}\r\n            mazes={mazes}\r\n            generateMaze={generateMaze}\r\n          />\r\n        </Col>\r\n      </Row>\r\n      <Row className=\"justify-content-center\">\r\n        <Col md=\"auto\">\r\n          <Grid\r\n            grid={grid}\r\n            mode={mode}\r\n            setMode={setMode}\r\n            setGrid={setGrid}\r\n            start={start}\r\n            setStart={setStart}\r\n            finish={finish}\r\n            setFinish={setFinish}\r\n            searching={searching}\r\n          />\r\n        </Col>\r\n      </Row>\r\n    </Container>\r\n  );\r\n};\r\n","export type Color = '#FF0000' | '#0000FF' | '#7CFC00';\r\nexport const RED: Color = '#FF0000';\r\nexport const BLUE: Color = '#0000FF';\r\nexport const GREEN: Color = '#7CFC00';\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN, BLUE } from '../model/Color';\r\n\r\nconst animation = async (\r\n  bars: Bar[],\r\n  j: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  bars[j].color = RED;\r\n  bars[j + 1].color = GREEN;\r\n  setState([...bars]);\r\n  await sleep(delay);\r\n  bars[j].color = BLUE;\r\n  bars[j + 1].color = BLUE;\r\n};\r\n\r\nexport const bubbleSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  const n: number = bars.length;\r\n  let greatestElementIndex: number = bars.length;\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    for (let j = 0; j < n - 1; j++) {\r\n      if (bars[j].num > bars[j + 1].num) {\r\n        swap(bars, j, j + 1);\r\n        await animation(bars, j, setState, delay);\r\n      }\r\n\r\n      if (j === greatestElementIndex - 2) {\r\n        // make the iteration's greatest element green (sorted partition)\r\n        greatestElementIndex--;\r\n        bars[greatestElementIndex].color = RED;\r\n        setState([...bars]);\r\n      }\r\n    }\r\n  }\r\n};\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN, BLUE } from '../model/Color';\r\n\r\nexport const cocktailSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  let swapped = true;\r\n  let start = 0;\r\n  let end = bars.length;\r\n\r\n  while (swapped) {\r\n    swapped = false;\r\n\r\n    // bottom to top\r\n    for (let i = start; i < end - 1; i++) {\r\n      if (bars[i].num > bars[i + 1].num) {\r\n        swap(bars, i, i + 1);\r\n        swapped = true;\r\n      }\r\n      bars[i].color = BLUE;\r\n      bars[i + 1].color = GREEN;\r\n      setState([...bars]);\r\n      await sleep(delay);\r\n    }\r\n\r\n    // mark this iterations greatest element\r\n    bars[end - 1].color = RED;\r\n    setState([...bars]);\r\n\r\n    // exit if sorted\r\n    if (!swapped) break;\r\n\r\n    swapped = false;\r\n    end--;\r\n\r\n    // top to bottom\r\n    for (let i = end - 1; i >= start; i--) {\r\n      if (bars[i].num > bars[i + 1].num) {\r\n        swap(bars, i, i + 1);\r\n        swapped = true;\r\n      }\r\n      if (i !== end - 1) bars[i + 1].color = BLUE;\r\n      bars[i].color = GREEN;\r\n      setState([...bars]);\r\n      await sleep(delay);\r\n    }\r\n    // mark this iterations smallest element\r\n    bars[start].color = RED;\r\n    setState([...bars]);\r\n\r\n    start++;\r\n  }\r\n};\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, BLUE } from '../model/Color';\r\n\r\nconst animation = async (\r\n  bars: Bar[],\r\n  x: number,\r\n  y: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  bars[x].color = RED;\r\n  bars[y].color = RED;\r\n  setState([...bars]);\r\n  await sleep(delay);\r\n  bars[x].color = BLUE;\r\n  bars[y].color = BLUE;\r\n  setState([...bars]);\r\n};\r\n\r\nconst heapify = async (\r\n  bars: Bar[],\r\n  n: number,\r\n  i: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  let largest = i;\r\n  const left = 2 * i + 1;\r\n  const right = 2 * i + 2;\r\n\r\n  if (left < n && bars[left].num > bars[largest].num) largest = left;\r\n\r\n  if (right < n && bars[right].num > bars[largest].num) largest = right;\r\n\r\n  if (largest !== i) {\r\n    swap(bars, i, largest);\r\n    await animation(bars, i, largest, setState, delay);\r\n    // recursively heapify sub-tree\r\n    await heapify(bars, n, largest, setState, delay);\r\n  }\r\n};\r\n\r\nexport const heapSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  const n = bars.length;\r\n\r\n  // build max-heap\r\n  for (let i = Math.floor(n / 2 - 1); i >= 0; i--) {\r\n    await heapify(bars, n, i, setState, delay);\r\n  }\r\n\r\n  for (let i = n - 1; i > 0; i--) {\r\n    // Move root to the end\r\n    swap(bars, 0, i, setState);\r\n\r\n    // mark sorted partition\r\n    bars[i].color = RED;\r\n\r\n    // heapify reduced heap\r\n    await heapify(bars, i, 0, setState, delay);\r\n  }\r\n};\r\n","import React, { SetStateAction } from 'react';\r\n\r\nimport { sleep } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN } from '../model/Color';\r\n\r\nexport const insertionSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  const n: number = bars.length;\r\n\r\n  bars[0].color = RED;\r\n\r\n  for (let i = 1; i < n; i++) {\r\n    const value: Bar = bars[i];\r\n    let hole: number = i;\r\n\r\n    bars[hole].color = RED;\r\n\r\n    while (hole > 0 && bars[hole - 1].num > value.num) {\r\n      await sleep(delay);\r\n      bars[hole] = bars[hole - 1];\r\n\r\n      bars[hole].color = GREEN;\r\n      if (hole + 1 < bars.length) bars[hole + 1].color = RED;\r\n\r\n      setState([...bars]);\r\n      hole--;\r\n    }\r\n\r\n    bars[hole].color = RED;\r\n\r\n    bars[hole] = value;\r\n    setState([...bars]);\r\n  }\r\n};\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, BLUE } from '../model/Color';\r\n\r\nconst nextGap = (gap: number): number => (gap <= 1 ? 0 : Math.ceil(gap / 2.0));\r\n\r\nconst animation = async (\r\n  bars: Bar[],\r\n  x: number,\r\n  y: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  bars[x].color = RED;\r\n  bars[y].color = RED;\r\n\r\n  setState([...bars]);\r\n  await sleep(delay);\r\n\r\n  bars[x].color = BLUE;\r\n  bars[y].color = BLUE;\r\n};\r\n\r\n/**\r\n * In-place Merge Sort\r\n *\r\n * Approach 2 from {@link https://www.geeksforgeeks.org/in-place-merge-sort/}.\r\n *\r\n * @param bars The array to be sorted.\r\n * @param start The left index of the array.\r\n * @param end The right index of the array.\r\n * @param setState Hook for changing the state.\r\n * @param delay Time in between each animation.\r\n */\r\nconst inPlaceMerge = async (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  let gap: number = end - start + 1;\r\n\r\n  for (gap = nextGap(gap); gap > 0; gap = nextGap(gap)) {\r\n    for (let i = start; i + gap <= end; i++) {\r\n      const j = i + gap;\r\n      if (bars[i].num > bars[j].num) {\r\n        swap(bars, i, j);\r\n        await animation(bars, i, j, setState, delay);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nconst _sort = async (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  if (start === end) return;\r\n\r\n  const mid = Math.floor((start + end) / 2);\r\n  await _sort(bars, start, mid, setState, delay);\r\n  await _sort(bars, mid + 1, end, setState, delay);\r\n\r\n  await inPlaceMerge(bars, start, end, setState, delay);\r\n};\r\n\r\nexport const mergeSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  await _sort(bars, 0, bars.length - 1, setState, delay);\r\n};\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN, BLUE } from '../model/Color';\r\n\r\nconst animation = async (\r\n  bars: Bar[],\r\n  i: number,\r\n  partitionIndex: number,\r\n  start: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  bars[i].color = GREEN;\r\n  bars[partitionIndex].color = RED;\r\n  setState([...bars]);\r\n  await sleep(delay);\r\n  if (i !== start) {\r\n    // only reset indices after start\r\n    bars[i].color = BLUE;\r\n    bars[partitionIndex].color = BLUE;\r\n  }\r\n};\r\n\r\n/**\r\n * Median of three\r\n *\r\n * Puts the median at the last index of the array and returns the pivot value\r\n *\r\n * @param bars The array to be sorted.\r\n * @param start The left index of the array.\r\n * @param end The right index of the array.\r\n * @returns The pivot value.\r\n */\r\nconst getMedian = (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>\r\n): number => {\r\n  const midpoint: number = Math.floor((start + end) / 2);\r\n  if (bars[start].num > bars[midpoint].num) swap(bars, start, midpoint);\r\n  if (bars[start] > bars[end]) swap(bars, start, end);\r\n  if (bars[midpoint] > bars[end]) swap(bars, midpoint, end);\r\n\r\n  swap(bars, midpoint, end, setState);\r\n  return bars[end].num;\r\n};\r\n\r\nconst partition = async (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<number> => {\r\n  const pivotIndex: number = end;\r\n  const pivot = getMedian(bars, start, end, setState);\r\n  let partitionIndex = start;\r\n\r\n  // Mark pivot\r\n  bars[pivotIndex].color = RED;\r\n  setState([...bars]);\r\n\r\n  for (let i = start; i < end; i++) {\r\n    if (bars[i].num <= pivot) {\r\n      swap(bars, i, partitionIndex, setState);\r\n\r\n      await animation(bars, i, partitionIndex, start, setState, delay);\r\n\r\n      partitionIndex++;\r\n    }\r\n  }\r\n\r\n  // Unmark pivot and starting pointer\r\n  bars[start].color = BLUE;\r\n  bars[pivotIndex].color = BLUE;\r\n  setState([...bars]);\r\n\r\n  swap(bars, partitionIndex, pivotIndex, setState);\r\n  return partitionIndex;\r\n};\r\n\r\nconst _sort = async (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  if (start < end) {\r\n    const partitionIndex: number = await partition(\r\n      bars,\r\n      start,\r\n      end,\r\n      setState,\r\n      delay\r\n    );\r\n    await _sort(bars, start, partitionIndex - 1, setState, delay);\r\n    await _sort(bars, partitionIndex + 1, end, setState, delay);\r\n  }\r\n};\r\n\r\nexport const quicksort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  await _sort(bars, 0, bars.length - 1, setState, delay);\r\n};\r\n","import React, { SetStateAction } from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN, BLUE } from '../model/Color';\r\n\r\nexport const selectionSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  const n: number = bars.length;\r\n  for (let i = 0; i < n - 1; i++) {\r\n    let iMin: number = i;\r\n    for (let j: number = i + 1; j < n; j++) {\r\n      if (bars[j].num < bars[iMin].num) iMin = j;\r\n\r\n      if (j === n - 1) {\r\n        // Mark the smallest element in the unsorted array\r\n        bars[iMin].color = GREEN;\r\n        setState([...bars]);\r\n      }\r\n    }\r\n\r\n    swap(bars, i, iMin);\r\n\r\n    await sleep(delay);\r\n    bars[iMin].color = BLUE; // Unmark\r\n    bars[i].color = RED;\r\n    setState([...bars]);\r\n  }\r\n\r\n  // manually make last element red cause yeah\r\n  bars[bars.length - 1].color = RED;\r\n  setState([...bars]);\r\n};\r\n","import { Bar } from '../model/Bar';\r\nimport { bubbleSort } from './BubbleSort';\r\nimport { cocktailSort } from './CocktailSort';\r\nimport { heapSort } from './HeapSort';\r\nimport { insertionSort } from './InsertionSort';\r\nimport { mergeSort } from './MergeSort';\r\nimport { quicksort } from './QuickSort';\r\nimport { selectionSort } from './SelectionSort';\r\n\r\ntype sortingFunc = (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n) => Promise<void>;\r\n\r\nexport const getSortingAlgorithm = (algorithm: string): sortingFunc => {\r\n  if (algorithm === 'selection') return selectionSort;\r\n  else if (algorithm === 'insertion') return insertionSort;\r\n  else if (algorithm === 'bubble') return bubbleSort;\r\n  else if (algorithm === 'quick') return quicksort;\r\n  else if (algorithm === 'merge') return mergeSort;\r\n  else if (algorithm === 'cocktail') return cocktailSort;\r\n  else if (algorithm === 'heap') return heapSort;\r\n  else throw new Error('Incorrect type for sorting algorithm');\r\n};\r\n","import React, { SetStateAction } from 'react';\r\n\r\nimport { Button } from 'react-bootstrap';\r\n\r\nimport { Bar } from '../../core/model/Bar';\r\n\r\ninterface Props {\r\n  num: number;\r\n  handleNumberChange: (e: React.ChangeEvent<HTMLInputElement>) => void;\r\n  sort: () => Promise<void>;\r\n  reset: () => void;\r\n  setBars: React.Dispatch<SetStateAction<Bar[]>>;\r\n  delay: number;\r\n  setDelay: React.Dispatch<SetStateAction<number>>;\r\n}\r\n\r\nexport const Panel: React.FC<Props> = ({\r\n  num,\r\n  handleNumberChange,\r\n  sort,\r\n  reset,\r\n  delay,\r\n  setDelay,\r\n}: Props) => {\r\n  const renderRangeSlider = (): JSX.Element => (\r\n    <label className=\"mx-2\" style={{ width: '10%', textAlign: 'left' }}>\r\n      Delay\r\n      <input\r\n        name=\"foo\"\r\n        type=\"range\"\r\n        min=\"1\"\r\n        max=\"100\"\r\n        value={delay}\r\n        className=\"slider\"\r\n        onChange={(e) => setDelay(parseInt(e.target.value))}\r\n      />\r\n    </label>\r\n  );\r\n\r\n  return (\r\n    <span>\r\n      {renderRangeSlider()}\r\n      <input\r\n        className=\"input-number\"\r\n        name=\"no. bars\"\r\n        type=\"number\"\r\n        value={num}\r\n        step={5}\r\n        min=\"5\"\r\n        max=\"150\"\r\n        onChange={handleNumberChange}\r\n        onKeyDown={(e) => e.preventDefault()}\r\n      />\r\n      <Button onClick={reset} className=\"mx-2\" variant=\"danger\">\r\n        Reset\r\n      </Button>\r\n      <Button onClick={sort}>Sort</Button>\r\n    </span>\r\n  );\r\n};\r\n","import React, { useState, useEffect } from 'react';\r\n\r\nimport './SortingVisualizer.css';\r\nimport { Col, Container, Row } from 'react-bootstrap';\r\n\r\nimport { Bar } from '../../core/model/Bar';\r\nimport { BLUE, GREEN } from '../../core/model/Color';\r\nimport { getSortingAlgorithm } from '../../core/sorting/SortingFactory';\r\nimport { sleep } from '../../utils';\r\nimport { AlgorithmButtonGroup } from '../common/AlgorithmButtonGroup';\r\nimport { Panel } from './Panel';\r\n\r\nconst algorithms = [\r\n  { name: 'Insertion Sort', value: 'insertion' },\r\n  { name: 'Selection Sort', value: 'selection' },\r\n  { name: 'Bubble Sort', value: 'bubble' },\r\n  { name: 'Quicksort', value: 'quick' },\r\n  { name: 'Merge Sort', value: 'merge' },\r\n  { name: 'Cocktail Sort', value: 'cocktail' },\r\n  { name: 'Heap Sort', value: 'heap' },\r\n];\r\n\r\nexport const SortingVisualizer: React.FC = () => {\r\n  const [bars, setBars] = useState<Bar[]>([]);\r\n  const [num, setNum] = useState<number>(90);\r\n  const [algorithm, setAlgorithm] = useState<string>('insertion');\r\n  const [delay, setDelay] = useState<number>(1);\r\n\r\n  const resetBars = (): void =>\r\n    setBars(\r\n      [...Array(num)].map(() => ({\r\n        num: Math.floor(Math.random() * 80) + 1,\r\n        color: BLUE,\r\n      }))\r\n    );\r\n\r\n  useEffect((): void => {\r\n    resetBars();\r\n  }, [num]); // eslint-disable-line react-hooks/exhaustive-deps\r\n\r\n  // Green progressive animation\r\n  const finish = async (\r\n    bars: Bar[],\r\n    setState: React.Dispatch<React.SetStateAction<Bar[]>>\r\n  ): Promise<void> => {\r\n    for (let i = 0; i < bars.length; i++) {\r\n      bars[i].color = GREEN;\r\n      setState([...bars]);\r\n      await sleep(1);\r\n    }\r\n  };\r\n\r\n  const sort = async (): Promise<void> => {\r\n    const sorter = getSortingAlgorithm(algorithm);\r\n    await sorter(bars, setBars, delay);\r\n    await finish(bars, setBars);\r\n  };\r\n\r\n  const handleNumberChange = (e: React.ChangeEvent<HTMLInputElement>): void => {\r\n    const { value, min, max } = e.target;\r\n    setNum(Math.max(Number(min), Math.min(Number(max), Number(value))));\r\n  };\r\n\r\n  const renderBars = (): JSX.Element => (\r\n    <div className=\"sorting-container\">\r\n      {bars.map((bar: Bar, idx) => (\r\n        <div\r\n          key={`b-${idx}`}\r\n          className=\"bar\"\r\n          style={{\r\n            backgroundColor: `${bar.color}`,\r\n            width: '1vw',\r\n            height: `${bar.num}vmin`,\r\n          }}\r\n        />\r\n      ))}\r\n    </div>\r\n  );\r\n\r\n  return (\r\n    <Container fluid={true} style={{ padding: '0' }}>\r\n      <Row className=\"app-vanish text-center justify-content-center\">\r\n        <Col md=\"auto\">\r\n          <Panel\r\n            num={num}\r\n            handleNumberChange={handleNumberChange}\r\n            reset={resetBars}\r\n            setBars={setBars}\r\n            sort={sort}\r\n            delay={delay}\r\n            setDelay={setDelay}\r\n          />\r\n          <AlgorithmButtonGroup\r\n            defaultAlgorithm={algorithm}\r\n            algorithms={algorithms}\r\n            setAlgorithm={setAlgorithm}\r\n          />\r\n        </Col>\r\n      </Row>\r\n      <Row className=\"justify-content-center\">\r\n        <Col md=\"auto\">{renderBars()}</Col>\r\n      </Row>\r\n    </Container>\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport './App.css';\r\nimport { HashRouter as Router, Switch, Route } from 'react-router-dom';\r\n\r\nimport { Header } from './components/common/Header';\r\nimport { PathfindingVisualizer } from './components/pathfinding/PathfindingVisualizer';\r\nimport { SortingVisualizer } from './components/sorting/SortingVisualizer';\r\n\r\nconst App = (): JSX.Element => {\r\n  return (\r\n    <Router>\r\n      <Header />\r\n      <Switch>\r\n        <Route exact path={['/', '/sorting']} component={SortingVisualizer} />\r\n        <Route path=\"/pathfinding\" component={PathfindingVisualizer} />\r\n      </Switch>\r\n    </Router>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from 'react';\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}