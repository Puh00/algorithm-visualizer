{"version":3,"sources":["components/common/Header.tsx","assets/github.png","utils/Sleep.ts","utils/Array.ts","utils/Path.ts","utils/Coordinates.ts","core/pathfinding/Astar.ts","core/pathfinding/UCS.ts","core/model/Color.ts","core/sorting/BubbleSort.ts","core/sorting/CocktailSort.ts","core/sorting/HeapSort.ts","core/sorting/InsertionSort.ts","core/sorting/MergeSort.ts","core/sorting/QuickSort.ts","core/sorting/SelectionSort.ts","utils/AlgorithmFactory.ts","utils/Random.ts","utils/Maze.ts","core/maze/BinaryTree.ts","core/maze/Eller.ts","core/maze/Kruskal.ts","core/maze/Prim.ts","core/maze/RecursiveBacktracking.ts","core/maze/RecursiveDivision.ts","core/maze/MazeFactory.ts","components/common/AlgorithmButtonGroup.tsx","components/pathfinding/CellButton.tsx","components/pathfinding/Grid.tsx","components/pathfinding/Panel.tsx","components/pathfinding/PathfindingVisualizer.tsx","components/sorting/Panel.tsx","components/sorting/SortingVisualizer.tsx","App.tsx","index.tsx"],"names":["Header","Navbar","expand","bg","variant","className","Container","Brand","href","OverlayTrigger","placement","overlay","Tooltip","id","src","alt","Toggle","aria-controls","Collapse","Nav","Link","as","to","sleep","delay","Promise","resolve","setTimeout","swap","arr","x","y","setState","extractPath","entry","path","pqe","unshift","coord","backPointer","yDir","xDir","adjacentCoords","c","n","m","offset","coords","i","row","col","push","isSameCoord","c1","c2","alignmentBetweenCoordinates","p","q","Math","max","min","Error","manhattanDistance","abs","astar","start","goal","grid","a","length","visited","Array","from","fill","pq","PriorityQueue","comparator","p1","p2","guessCost","costToHere","queue","dequeue","success","isWall","isActive","costToNext","UCS","RED","BLUE","GREEN","animation","bars","j","color","bubbleSort","greatestElementIndex","num","cocktailSort","swapped","end","heapify","largest","right","left","heapSort","floor","insertionSort","value","hole","nextGap","gap","ceil","inPlaceMerge","_sort","mid","mergeSort","partitionIndex","getMedian","midpoint","partition","pivotIndex","pivot","quicksort","selectionSort","iMin","getSortingAlgorithm","algorithmType","getPathfindingAlgorithm","randomNumber","random","randomOddCoordinates","popRandomElementFromSet","set","size","rs","values","delete","markAllCellsAsWalls","setGrid","carveHorizontaly","carveVertically","carvePassageBetweenAdjacentCoordinates","alignment","BinaryTree","dirs","dir","coinflip","populate","sets","Set","_mergeSets","set1","set2","merged","forEach","add","mergeSets","val","index","removeRandomElements","s","horizontalConnections","verticalConnections","unique","nextRow","Eller","Tree","parent","this","root","tree","setOfPossibleEdges","edges","Kruskal","isConnected","connect","passages","filter","mark","frontier","walls","item","Prim","startCoord","neighbours","shuffle","array","temp","carvePassagesFrom","RecursiveBacktracking","addHWall","minX","maxX","isStart","isFinish","addVWall","minY","maxY","addOuterWalls","divideHorizontally","divide","divideVertically","RecursiveDivision","getMazeAlgorithm","AlgorithmButtonGroup","defaultAlgorithm","algorithms","setAlgorithm","ButtonGroup","map","alg","ToggleButton","type","checked","onChange","e","currentTarget","name","cellColor","cell","isPath","cssAnimation","CellButton","mouseDown","onMouseDown","onMouseEnter","onMouseUp","Button","style","backgroundColor","Grid","mode","setStart","finish","setFinish","searching","React","useState","setMouseDown","toggleWall","moveStart","moveFinish","handleMouseUp","handleMouseDown","handleMouseEnter","onClick","onMouseLeave","Panel","modes","setMode","resetGrid","search","mazes","generateMaze","display","justifyContent","alignItems","DropdownButton","title","menuAlign","Dropdown","Item","noHorizontalCells","window","innerWidth","noVerticalCells","innerHeight","calculateCells","_","drawPath","res","PathfindingVisualizer","algorithm","setSearching","searcher","then","mazeGenerator","fluid","padding","Row","Col","md","handleNumberChange","sort","reset","setDelay","width","textAlign","parseInt","target","step","onKeyDown","preventDefault","SortingVisualizer","setBars","setNum","resetBars","useEffect","sorter","Number","bar","idx","height","App","exact","component","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.446c8102.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nimport {\r\n  Container,\r\n  Nav,\r\n  Navbar,\r\n  OverlayTrigger,\r\n  Tooltip,\r\n} from 'react-bootstrap';\r\nimport { Link } from 'react-router-dom';\r\n\r\nimport logo from '../../assets/github.png';\r\n\r\nexport const Header = (): JSX.Element => {\r\n  return (\r\n    <Navbar expand=\"md\" bg=\"dark\" variant=\"dark\" className=\"app-vanish\">\r\n      <Container>\r\n        <Navbar.Brand href=\"https://github.com/Puh00/algorithm-visualizer\">\r\n          <OverlayTrigger\r\n            placement=\"bottom\"\r\n            overlay={<Tooltip id=\"tip\">View Project</Tooltip>}\r\n          >\r\n            <img src={logo} alt=\"github logo\" />\r\n          </OverlayTrigger>\r\n        </Navbar.Brand>\r\n        <Navbar.Toggle aria-controls=\"basic-navbar-nav\" />\r\n        <Navbar.Collapse id=\"basic-navbar-nav\">\r\n          <Nav className=\"me-auto\">\r\n            <Nav.Link as={Link} to=\"/sorting\">\r\n              Sorting\r\n            </Nav.Link>\r\n            <Nav.Link as={Link} to=\"/pathfinding\">\r\n              Pathfinding\r\n            </Nav.Link>\r\n          </Nav>\r\n        </Navbar.Collapse>\r\n      </Container>\r\n    </Navbar>\r\n  );\r\n};\r\n","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RERCMUIwOUY4NkNFMTFFM0FBNTJFRTMzNTJEMUJDNDYiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RERCMUIwOUU4NkNFMTFFM0FBNTJFRTMzNTJEMUJDNDYiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU1MTc4QTJBOTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU1MTc4QTJCOTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+jUqS1wAAApVJREFUeNq0l89rE1EQx3e3gVJoSPzZeNEWPKgHoa0HBak0iHiy/4C3WvDmoZ56qJ7txVsPQu8qlqqHIhRKJZceesmhioQEfxTEtsoSpdJg1u/ABJ7Pmc1m8zLwgWTmzcw3L+/te+tHUeQltONgCkyCi2AEDHLsJ6iBMlgHL8FeoqokoA2j4CloRMmtwTmj7erHBXPgCWhG6a3JNXKdCiDl1cidVbXZkJoXQRi5t5BrxwoY71FzU8S4JuAIqFkJ2+BFSlEh525b/hr3+k/AklDkNsf6wTT4yv46KIMNpsy+iMdMc47HNWxbsgVcUn7FmLAzzoFAWDsBx+wVP6bUpp5ewI+DOeUx0Wd9D8F70BTGNjkWtqnhmT1JQAHcUgZd8Lo3rQb1LAT8eJVUfgGvHQigGp+V2Z0iAUUl8QH47kAA1XioxIo+bRN8OG8F/oBjwv+Z1nJgX5jpdzQDw0LCjsPmrcW7I/iHScCAEDj03FtD8A0EyuChHgg4KTlJQF3wZ7WELppnBX+dBFSVpJsOBWi1qiRgSwnOgoyD5hmuJdkWCVhTgnTvW3AgYIFrSbZGh0UW/Io5Vp+DQoK7o80pztWMemZbgxeNwCNwDbw1fIfgGZjhU6xPaJgBV8BdsMw5cbZoHsenwYFxkZzl83xTSKTiviCAfCsJLysH3POfC8m8NegyGAGfLP/VmGmfSChgXroR0RSWjEFv2J/nG84cuKFMf4sTCZqXuJd4KaXFVjEG3+tw4eXbNK/YC9oXXs3O8NY8y99L4BXY5cvLY/Bb2VZ58EOJVcB18DHJq9lRsKr8inyKGVjlmh29mtHs3AHfuhCwy1vXT/Nu2GKQt+UHsGdctyX6eQyNvc+5sfX9Dl7Pe2J/BRgAl2CpwmrsHR0AAAAASUVORK5CYII=\"","export const sleep = (delay: number): Promise<void> =>\r\n  new Promise((resolve) => setTimeout(resolve, delay));\r\n","export const swap = <T>(\r\n  arr: T[],\r\n  x: number,\r\n  y: number,\r\n  setState?: React.Dispatch<React.SetStateAction<T[]>>\r\n): void => {\r\n  [arr[y], arr[x]] = [arr[x], arr[y]];\r\n  if (setState) setState([...arr]);\r\n};\r\n","import { Coord } from '../core/model/Cell';\r\nimport { PQEntry } from '../core/model/PQEntry';\r\n\r\n/**\r\n * Extract the full path from start to goal\r\n * @param entry the final priority queue entry\r\n * @returns the path from start to goal as a list of cells\r\n */\r\nexport const extractPath = (entry: PQEntry): Coord[] => {\r\n  const path = [];\r\n  let pqe: PQEntry | null = entry;\r\n  while (pqe !== null) {\r\n    path.unshift(pqe.coord);\r\n    pqe = pqe.backPointer;\r\n  }\r\n  return path;\r\n};\r\n","import { Coord } from '../core/model/Cell';\r\n\r\n// Direction vectors: [Up, Right, Down, Left]\r\nconst yDir = [-1, 0, 1, 0];\r\nconst xDir = [0, 1, 0, -1];\r\n\r\n// Returns adjacent coordinates that are within bounds\r\nexport const adjacentCoords = (\r\n  c: Coord,\r\n  n: number,\r\n  m: number,\r\n  offset = 1\r\n): Coord[] => {\r\n  const coords: Coord[] = [];\r\n  for (let i = 0; i < 4; i++) {\r\n    const row = c.y + yDir[i] * offset;\r\n    const col = c.x + xDir[i] * offset;\r\n    if (row >= 0 && col >= 0 && row < n && col < m) {\r\n      coords.push({ x: col, y: row });\r\n    }\r\n  }\r\n  return coords;\r\n};\r\n\r\n// Since Typescript compare by references...\r\nexport const isSameCoord = (c1: Coord, c2: Coord): boolean =>\r\n  c1.x === c2.x && c1.y === c2.y;\r\n\r\ntype dir = 'HORIZONTAL' | 'VERTICAL';\r\n\r\nexport const alignmentBetweenCoordinates = (p: Coord, q: Coord): dir => {\r\n  if (Math.max(p.y, q.y) - Math.min(p.y, q.y) === 0) return 'HORIZONTAL';\r\n  else if (Math.max(p.x, q.x) - Math.min(p.x, q.x) === 0) return 'VERTICAL';\r\n  else throw new Error('Neither horizontally or vertically aligned');\r\n};\r\n","import React from 'react';\r\n\r\nimport PriorityQueue from 'ts-priority-queue';\r\n\r\nimport { adjacentCoords, extractPath, isSameCoord, sleep } from '../../utils';\r\nimport { Cell, Coord } from '../model/Cell';\r\nimport { PQEntry, Result } from '../model/PQEntry';\r\n\r\n/* const euclidianDistance = (p: Coord, q: Coord): number => {\r\n  return Math.hypot(p.x - q.x, p.y - q.y);\r\n}; */\r\n\r\nconst manhattanDistance = (p: Coord, q: Coord): number => {\r\n  return Math.abs(p.x - q.x) + Math.abs(p.y - q.y);\r\n};\r\n\r\nexport const astar = async (\r\n  start: Coord,\r\n  goal: Coord,\r\n  grid: Cell[][],\r\n  setState: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<Result> => {\r\n  // n * m length of grid\r\n  const n = grid.length;\r\n  const m = grid[0].length;\r\n\r\n  // Auxiliary array keeping track of visited cells\r\n  const visited: boolean[][] = Array.from(Array(n), () => Array(m).fill(false));\r\n\r\n  const pq = new PriorityQueue<PQEntry>({\r\n    comparator: (p1, p2) => {\r\n      // bug: 'if (p1.guessCost)' will return false if p1.guessCost is 0\r\n      if (\r\n        typeof p1.guessCost !== 'undefined' &&\r\n        typeof p2.guessCost !== 'undefined'\r\n      )\r\n        return p1.costToHere + p1.guessCost - (p2.costToHere + p2.guessCost);\r\n      else throw new Error(\"Undefined field 'guessCost' in PQEntry\");\r\n    },\r\n  });\r\n\r\n  // Add starting cell to be searched\r\n  pq.queue({\r\n    coord: start,\r\n    costToHere: 0,\r\n    backPointer: null,\r\n    guessCost: manhattanDistance(start, goal),\r\n  });\r\n\r\n  while (pq.length !== 0) {\r\n    const entry = pq.dequeue();\r\n\r\n    if (isSameCoord(entry.coord, goal))\r\n      return { success: true, path: extractPath(entry) };\r\n\r\n    if (\r\n      !visited[entry.coord.y][entry.coord.x] &&\r\n      !grid[entry.coord.y][entry.coord.x].isWall\r\n    ) {\r\n      visited[entry.coord.y][entry.coord.x] = true;\r\n\r\n      // mark visited cells\r\n      grid[entry.coord.y][entry.coord.x].isActive = true;\r\n      setState([...grid]);\r\n      await sleep(1);\r\n\r\n      for (const c of adjacentCoords(entry.coord, n, m)) {\r\n        const costToNext = entry.costToHere + 1;\r\n        pq.queue({\r\n          coord: c,\r\n          costToHere: costToNext,\r\n          backPointer: entry,\r\n          guessCost: manhattanDistance(c, goal),\r\n        });\r\n      }\r\n    }\r\n  }\r\n  return { success: false, path: null };\r\n};\r\n","import React from 'react';\r\n\r\nimport PriorityQueue from 'ts-priority-queue';\r\n\r\nimport { adjacentCoords, extractPath, isSameCoord, sleep } from '../../utils';\r\nimport { Cell, Coord } from '../model/Cell';\r\nimport { PQEntry, Result } from '../model/PQEntry';\r\n\r\nexport const UCS = async (\r\n  start: Coord,\r\n  goal: Coord,\r\n  grid: Cell[][],\r\n  setState: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<Result> => {\r\n  // n * m length of grid\r\n  const n = grid.length;\r\n  const m = grid[0].length;\r\n\r\n  // Auxiliary array keeping track of visited cells\r\n  const visited: boolean[][] = Array.from(Array(n), () => Array(m).fill(false));\r\n\r\n  const pq = new PriorityQueue<PQEntry>({\r\n    comparator: (p1, p2) => p1.costToHere - p2.costToHere,\r\n  });\r\n\r\n  // Add starting cell to be searched\r\n  pq.queue({ coord: start, costToHere: 0, backPointer: null });\r\n\r\n  while (pq.length !== 0) {\r\n    const entry = pq.dequeue();\r\n\r\n    if (isSameCoord(entry.coord, goal))\r\n      return { success: true, path: extractPath(entry) };\r\n\r\n    if (\r\n      !visited[entry.coord.y][entry.coord.x] &&\r\n      !grid[entry.coord.y][entry.coord.x].isWall\r\n    ) {\r\n      visited[entry.coord.y][entry.coord.x] = true;\r\n\r\n      // mark visited cells\r\n      grid[entry.coord.y][entry.coord.x].isActive = true;\r\n      setState([...grid]);\r\n      await sleep(1);\r\n\r\n      for (const c of adjacentCoords(entry.coord, n, m)) {\r\n        const costToNext = entry.costToHere + 1;\r\n        pq.queue({ coord: c, costToHere: costToNext, backPointer: entry });\r\n      }\r\n    }\r\n  }\r\n  return { success: false, path: null };\r\n};\r\n","export type Color = '#FF0000' | '#0000FF' | '#7CFC00';\r\nexport const RED: Color = '#FF0000';\r\nexport const BLUE: Color = '#0000FF';\r\nexport const GREEN: Color = '#7CFC00';\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN, BLUE } from '../model/Color';\r\n\r\nconst animation = async (\r\n  bars: Bar[],\r\n  j: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  bars[j].color = RED;\r\n  bars[j + 1].color = GREEN;\r\n  setState([...bars]);\r\n  await sleep(delay);\r\n  bars[j].color = BLUE;\r\n  bars[j + 1].color = BLUE;\r\n};\r\n\r\nexport const bubbleSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  const n: number = bars.length;\r\n  let greatestElementIndex: number = bars.length;\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    for (let j = 0; j < n - 1; j++) {\r\n      if (bars[j].num > bars[j + 1].num) {\r\n        swap(bars, j, j + 1);\r\n        await animation(bars, j, setState, delay);\r\n      }\r\n\r\n      if (j === greatestElementIndex - 2) {\r\n        // make the iteration's greatest element green (sorted partition)\r\n        greatestElementIndex--;\r\n        bars[greatestElementIndex].color = RED;\r\n        setState([...bars]);\r\n      }\r\n    }\r\n  }\r\n};\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN, BLUE } from '../model/Color';\r\n\r\nexport const cocktailSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  let swapped = true;\r\n  let start = 0;\r\n  let end = bars.length;\r\n\r\n  while (swapped) {\r\n    swapped = false;\r\n\r\n    // bottom to top\r\n    for (let i = start; i < end - 1; i++) {\r\n      if (bars[i].num > bars[i + 1].num) {\r\n        swap(bars, i, i + 1);\r\n        swapped = true;\r\n      }\r\n      bars[i].color = BLUE;\r\n      bars[i + 1].color = GREEN;\r\n      setState([...bars]);\r\n      await sleep(delay);\r\n    }\r\n\r\n    // mark this iterations greatest element\r\n    bars[end - 1].color = RED;\r\n    setState([...bars]);\r\n\r\n    // exit if sorted\r\n    if (!swapped) break;\r\n\r\n    swapped = false;\r\n    end--;\r\n\r\n    // top to bottom\r\n    for (let i = end - 1; i >= start; i--) {\r\n      if (bars[i].num > bars[i + 1].num) {\r\n        swap(bars, i, i + 1);\r\n        swapped = true;\r\n      }\r\n      if (i !== end - 1) bars[i + 1].color = BLUE;\r\n      bars[i].color = GREEN;\r\n      setState([...bars]);\r\n      await sleep(delay);\r\n    }\r\n    // mark this iterations smallest element\r\n    bars[start].color = RED;\r\n    setState([...bars]);\r\n\r\n    start++;\r\n  }\r\n};\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, BLUE } from '../model/Color';\r\n\r\nconst animation = async (\r\n  bars: Bar[],\r\n  x: number,\r\n  y: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  bars[x].color = RED;\r\n  bars[y].color = RED;\r\n  setState([...bars]);\r\n  await sleep(delay);\r\n  bars[x].color = BLUE;\r\n  bars[y].color = BLUE;\r\n  setState([...bars]);\r\n};\r\n\r\nconst heapify = async (\r\n  bars: Bar[],\r\n  n: number,\r\n  i: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  let largest = i;\r\n  const left = 2 * i + 1;\r\n  const right = 2 * i + 2;\r\n\r\n  if (left < n && bars[left].num > bars[largest].num) largest = left;\r\n\r\n  if (right < n && bars[right].num > bars[largest].num) largest = right;\r\n\r\n  if (largest !== i) {\r\n    swap(bars, i, largest);\r\n    await animation(bars, i, largest, setState, delay);\r\n    // recursively heapify sub-tree\r\n    await heapify(bars, n, largest, setState, delay);\r\n  }\r\n};\r\n\r\nexport const heapSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  const n = bars.length;\r\n\r\n  // build max-heap\r\n  for (let i = Math.floor(n / 2 - 1); i >= 0; i--) {\r\n    await heapify(bars, n, i, setState, delay);\r\n  }\r\n\r\n  for (let i = n - 1; i > 0; i--) {\r\n    // Move root to the end\r\n    swap(bars, 0, i, setState);\r\n\r\n    // mark sorted partition\r\n    bars[i].color = RED;\r\n\r\n    // heapify reduced heap\r\n    await heapify(bars, i, 0, setState, delay);\r\n  }\r\n};\r\n","import React, { SetStateAction } from 'react';\r\n\r\nimport { sleep } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN } from '../model/Color';\r\n\r\nexport const insertionSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  const n: number = bars.length;\r\n\r\n  bars[0].color = RED;\r\n\r\n  for (let i = 1; i < n; i++) {\r\n    const value: Bar = bars[i];\r\n    let hole: number = i;\r\n\r\n    bars[hole].color = RED;\r\n\r\n    while (hole > 0 && bars[hole - 1].num > value.num) {\r\n      await sleep(delay);\r\n      bars[hole] = bars[hole - 1];\r\n\r\n      bars[hole].color = GREEN;\r\n      if (hole + 1 < bars.length) bars[hole + 1].color = RED;\r\n\r\n      setState([...bars]);\r\n      hole--;\r\n    }\r\n\r\n    bars[hole].color = RED;\r\n\r\n    bars[hole] = value;\r\n    setState([...bars]);\r\n  }\r\n};\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, BLUE } from '../model/Color';\r\n\r\nconst nextGap = (gap: number): number => (gap <= 1 ? 0 : Math.ceil(gap / 2.0));\r\n\r\nconst animation = async (\r\n  bars: Bar[],\r\n  x: number,\r\n  y: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  bars[x].color = RED;\r\n  bars[y].color = RED;\r\n\r\n  setState([...bars]);\r\n  await sleep(delay);\r\n\r\n  bars[x].color = BLUE;\r\n  bars[y].color = BLUE;\r\n};\r\n\r\n/**\r\n * In-place Merge Sort\r\n *\r\n * Approach 2 from {@link https://www.geeksforgeeks.org/in-place-merge-sort/}.\r\n *\r\n * @param bars The array to be sorted.\r\n * @param start The left index of the array.\r\n * @param end The right index of the array.\r\n * @param setState Hook for changing the state.\r\n * @param delay Time in between each animation.\r\n */\r\nconst inPlaceMerge = async (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  let gap: number = end - start + 1;\r\n\r\n  for (gap = nextGap(gap); gap > 0; gap = nextGap(gap)) {\r\n    for (let i = start; i + gap <= end; i++) {\r\n      const j = i + gap;\r\n      if (bars[i].num > bars[j].num) {\r\n        swap(bars, i, j);\r\n        await animation(bars, i, j, setState, delay);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nconst _sort = async (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  if (start === end) return;\r\n\r\n  const mid = Math.floor((start + end) / 2);\r\n  await _sort(bars, start, mid, setState, delay);\r\n  await _sort(bars, mid + 1, end, setState, delay);\r\n\r\n  await inPlaceMerge(bars, start, end, setState, delay);\r\n};\r\n\r\nexport const mergeSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  await _sort(bars, 0, bars.length - 1, setState, delay);\r\n};\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN, BLUE } from '../model/Color';\r\n\r\nconst animation = async (\r\n  bars: Bar[],\r\n  i: number,\r\n  partitionIndex: number,\r\n  start: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  bars[i].color = GREEN;\r\n  bars[partitionIndex].color = RED;\r\n  setState([...bars]);\r\n  await sleep(delay);\r\n  if (i !== start) {\r\n    // only reset indices after start\r\n    bars[i].color = BLUE;\r\n    bars[partitionIndex].color = BLUE;\r\n  }\r\n};\r\n\r\n/**\r\n * Median of three\r\n *\r\n * Puts the median at the last index of the array and returns the pivot value\r\n *\r\n * @param bars The array to be sorted.\r\n * @param start The left index of the array.\r\n * @param end The right index of the array.\r\n * @returns The pivot value.\r\n */\r\nconst getMedian = (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>\r\n): number => {\r\n  const midpoint: number = Math.floor((start + end) / 2);\r\n  if (bars[start].num > bars[midpoint].num) swap(bars, start, midpoint);\r\n  if (bars[start] > bars[end]) swap(bars, start, end);\r\n  if (bars[midpoint] > bars[end]) swap(bars, midpoint, end);\r\n\r\n  swap(bars, midpoint, end, setState);\r\n  return bars[end].num;\r\n};\r\n\r\nconst partition = async (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<number> => {\r\n  const pivotIndex: number = end;\r\n  const pivot = getMedian(bars, start, end, setState);\r\n  let partitionIndex = start;\r\n\r\n  // Mark pivot\r\n  bars[pivotIndex].color = RED;\r\n  setState([...bars]);\r\n\r\n  for (let i = start; i < end; i++) {\r\n    if (bars[i].num <= pivot) {\r\n      swap(bars, i, partitionIndex, setState);\r\n\r\n      await animation(bars, i, partitionIndex, start, setState, delay);\r\n\r\n      partitionIndex++;\r\n    }\r\n  }\r\n\r\n  // Unmark pivot and starting pointer\r\n  bars[start].color = BLUE;\r\n  bars[pivotIndex].color = BLUE;\r\n  setState([...bars]);\r\n\r\n  swap(bars, partitionIndex, pivotIndex, setState);\r\n  return partitionIndex;\r\n};\r\n\r\nconst _sort = async (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  if (start < end) {\r\n    const partitionIndex: number = await partition(\r\n      bars,\r\n      start,\r\n      end,\r\n      setState,\r\n      delay\r\n    );\r\n    await _sort(bars, start, partitionIndex - 1, setState, delay);\r\n    await _sort(bars, partitionIndex + 1, end, setState, delay);\r\n  }\r\n};\r\n\r\nexport const quicksort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  await _sort(bars, 0, bars.length - 1, setState, delay);\r\n};\r\n","import React, { SetStateAction } from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN, BLUE } from '../model/Color';\r\n\r\nexport const selectionSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  const n: number = bars.length;\r\n  for (let i = 0; i < n - 1; i++) {\r\n    let iMin: number = i;\r\n    for (let j: number = i + 1; j < n; j++) {\r\n      if (bars[j].num < bars[iMin].num) iMin = j;\r\n\r\n      if (j === n - 1) {\r\n        // Mark the smallest element in the unsorted array\r\n        bars[iMin].color = GREEN;\r\n        setState([...bars]);\r\n      }\r\n    }\r\n\r\n    swap(bars, i, iMin);\r\n\r\n    await sleep(delay);\r\n    bars[iMin].color = BLUE; // Unmark\r\n    bars[i].color = RED;\r\n    setState([...bars]);\r\n  }\r\n\r\n  // manually make last element red cause yeah\r\n  bars[bars.length - 1].color = RED;\r\n  setState([...bars]);\r\n};\r\n","import React, { SetStateAction } from 'react';\r\n\r\nimport { Bar } from '../core/model/Bar';\r\nimport { Cell, Coord } from '../core/model/Cell';\r\nimport { Result } from '../core/model/PQEntry';\r\nimport { astar } from '../core/pathfinding/Astar';\r\nimport { UCS } from '../core/pathfinding/UCS';\r\nimport { bubbleSort } from '../core/sorting/BubbleSort';\r\nimport { cocktailSort } from '../core/sorting/CocktailSort';\r\nimport { heapSort } from '../core/sorting/HeapSort';\r\nimport { insertionSort } from '../core/sorting/InsertionSort';\r\nimport { mergeSort } from '../core/sorting/MergeSort';\r\nimport { quicksort } from '../core/sorting/QuickSort';\r\nimport { selectionSort } from '../core/sorting/SelectionSort';\r\n\r\ntype sortingFunc = (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<SetStateAction<Bar[]>>,\r\n  delay: number\r\n) => Promise<void>;\r\n\r\ntype pathfindingFunc = (\r\n  start: Coord,\r\n  finish: Coord,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<SetStateAction<Cell[][]>>\r\n) => Promise<Result>;\r\n\r\nexport const getSortingAlgorithm = (algorithmType: string): sortingFunc => {\r\n  if (algorithmType === 'selection') return selectionSort;\r\n  else if (algorithmType === 'insertion') return insertionSort;\r\n  else if (algorithmType === 'bubble') return bubbleSort;\r\n  else if (algorithmType === 'quick') return quicksort;\r\n  else if (algorithmType === 'merge') return mergeSort;\r\n  else if (algorithmType === 'cocktail') return cocktailSort;\r\n  else if (algorithmType === 'heap') return heapSort;\r\n  else throw new Error('Incorrect type for sorting algorithm');\r\n};\r\n\r\nexport const getPathfindingAlgorithm = (\r\n  algorithmType: string\r\n): pathfindingFunc => {\r\n  if (algorithmType === 'ucs') return UCS;\r\n  else if (algorithmType === 'astar') return astar;\r\n  else throw new Error('Incorrect type for pathfinding algorithm');\r\n};\r\n","import { Coord } from '../core/model/Cell';\r\n\r\n// inclusive: [min, max]\r\nexport const randomNumber = (min: number, max: number): number =>\r\n  Math.floor(Math.random() * (max - min + 1) + min);\r\n\r\n/**\r\n * Produces a random odd coordinate within the bounds of the given paramters\r\n * @param n Vertical size.\r\n * @param m Horizontal size.\r\n * @returns a random odd coordinate.\r\n */\r\nexport const randomOddCoordinates = (n: number, m: number): Coord => {\r\n  const x = randomNumber(2, m - 1);\r\n  const y = randomNumber(2, n - 1);\r\n  return { x: x % 2 === 0 ? x - 1 : x, y: y % 2 === 0 ? y - 1 : y };\r\n};\r\n\r\n/**\r\n * Removes a random element from the set and returns that object as the\r\n * value of this function\r\n * @param set the set to pick a random element from.\r\n * @throws will throw an error if the set is empty.\r\n * @returns the randomly picked element.\r\n */\r\nexport const popRandomElementFromSet = <T>(set: Set<T>): T => {\r\n  if (set.size === 0) throw new Error('Empty Set');\r\n  const rs = Array.from(set.values())[Math.floor(Math.random() * set.size)];\r\n  set.delete(rs);\r\n  return rs;\r\n};\r\n","import { alignmentBetweenCoordinates, sleep } from '.';\r\nimport { Cell, Coord } from '../core/model/Cell';\r\n\r\nexport const markAllCellsAsWalls = (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): void => {\r\n  for (let row = 0; row < grid.length; row++) {\r\n    for (let col = 0; col < grid[0].length; col++) {\r\n      grid[row][col].isWall = true;\r\n    }\r\n  }\r\n  setGrid([...grid]);\r\n};\r\n\r\nexport const carveHorizontaly = async (\r\n  grid: Cell[][],\r\n  x: number,\r\n  y: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  for (let i = 0; i < 3; i++) {\r\n    grid[y][x + i].isWall = false;\r\n  }\r\n  setGrid([...grid]);\r\n  await sleep(1);\r\n};\r\n\r\nexport const carveVertically = async (\r\n  grid: Cell[][],\r\n  x: number,\r\n  y: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  for (let i = 0; i < 3; i++) {\r\n    grid[y + i][x].isWall = false;\r\n  }\r\n  setGrid([...grid]);\r\n  await sleep(1);\r\n};\r\n\r\n/**\r\n * Carve a passage between two coordinates if and only if they are adjacent\r\n * and vertically or horizontally aligned.\r\n *\r\n * @param p starting coordinate.\r\n * @param q target coordinate.\r\n * @param grid the grid to carve upon.\r\n * @param setGrid react hook to update the state.\r\n */\r\nexport const carvePassageBetweenAdjacentCoordinates = async (\r\n  p: Coord,\r\n  q: Coord,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  const alignment = alignmentBetweenCoordinates(p, q);\r\n  if (alignment === 'HORIZONTAL') {\r\n    // current cell and neighbour are horizontally aligned\r\n    await carveHorizontaly(grid, Math.min(p.x, q.x), p.y, setGrid);\r\n  } else if (alignment === 'VERTICAL') {\r\n    // ...vertically aligned\r\n    await carveVertically(grid, p.x, Math.min(p.y, q.y), setGrid);\r\n  }\r\n};\r\n","import {\r\n  carveHorizontaly,\r\n  carveVertically,\r\n  markAllCellsAsWalls,\r\n  randomNumber,\r\n} from '../../utils';\r\nimport { Cell } from '../model/Cell';\r\n\r\n// Binary Tree with Southeast bias\r\nexport const BinaryTree = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n\r\n  for (let row = 1; row < grid.length; row++) {\r\n    if (row % 2 === 0) continue;\r\n    for (let col = 1; col < grid[0].length; col++) {\r\n      if (col % 2 === 0) continue;\r\n      const dirs: string[] = [];\r\n      // if within bounds add the direction\r\n      if (col + 2 < grid[0].length - 1) dirs.push('EAST');\r\n      if (row + 2 < grid.length - 1) dirs.push('SOUTH');\r\n\r\n      const dir = dirs[randomNumber(0, dirs.length - 1)];\r\n      if (dir === 'EAST') await carveHorizontaly(grid, col, row, setGrid);\r\n      else if (dir === 'SOUTH') await carveVertically(grid, col, row, setGrid);\r\n    }\r\n  }\r\n};\r\n","import {\r\n  carveHorizontaly,\r\n  carveVertically,\r\n  markAllCellsAsWalls,\r\n  popRandomElementFromSet,\r\n} from '../../utils';\r\nimport { Cell } from '../model/Cell';\r\n\r\nconst coinflip = (): boolean => Math.random() > 0.5;\r\n\r\n/**\r\n * Replaces all of the null values in the current row with a new set\r\n * @param sets the array containing the sets of the current row.\r\n */\r\nconst populate = (sets: Array<Set<number> | null>): void => {\r\n  for (let i = 1; i < sets.length; i += 2) if (!sets[i]) sets[i] = new Set([i]);\r\n};\r\n\r\nconst _mergeSets = (\r\n  set1: Set<number> | null,\r\n  set2: Set<number> | null\r\n): Set<number> => {\r\n  if (!set1 || !set2) throw new Error(\"Can't merge undefined sets\");\r\n  const merged: Set<number> = new Set();\r\n  set1.forEach((value) => merged.add(value));\r\n  set2.forEach((value) => merged.add(value));\r\n  return merged;\r\n};\r\n\r\n/**\r\n * Merge two sets if and only if they are disjoint.\r\n *\r\n * Also updates previous sets to match with the newly merged set.\r\n *\r\n * @param sets the array containing the sets of the current row.\r\n * @param set1 the first coordinate's set.\r\n * @param set2 the second coordinate's set.\r\n * @param col x coordinate.\r\n * @param row y coordinate.\r\n * @param grid the grid to work with.\r\n * @param setGrid react hook to update the state of the grid.\r\n */\r\nconst mergeSets = async (\r\n  sets: Array<Set<number> | null>,\r\n  set1: Set<number> | null,\r\n  set2: Set<number> | null,\r\n  col: number,\r\n  row: number,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  if (set1 === set2) return;\r\n  const merged = _mergeSets(set1, set2);\r\n  [sets[col], sets[col + 2]] = [merged, merged];\r\n  // manually update earlier identical sets\r\n  sets.forEach((val, index) => {\r\n    if (val === set1 || val === set2) sets[index] = merged;\r\n  });\r\n  await carveHorizontaly(grid, col, row, setGrid);\r\n};\r\n\r\n/**\r\n * For each element in the set, randomly decide whether to remove it or not.\r\n * Ensures that there is at least one element left in the set.\r\n * @param s the set to manipulate.\r\n */\r\nconst removeRandomElements = (s: Set<number> | null): void => {\r\n  if (!s) throw new Error(\"Can't pop undefined set\");\r\n  for (let i = s.size; i > 1; i--) if (coinflip()) popRandomElementFromSet(s);\r\n};\r\n\r\nconst horizontalConnections = async (\r\n  sets: Array<Set<number> | null>,\r\n  row: number,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  for (let col = 1; col < grid[0].length; col += 2) {\r\n    // skip if out of bounds\r\n    if (!grid[row][col + 2]) continue;\r\n\r\n    const [set1, set2] = [sets[col], sets[col + 2]];\r\n\r\n    if (row !== grid.length - 2) {\r\n      if (coinflip())\r\n        // randomly join adjacent cells, given that they are disjoint\r\n        await mergeSets(sets, set1, set2, col, row, grid, setGrid);\r\n    }\r\n    // last row, connect all adjacent disjoint sets\r\n    else await mergeSets(sets, set1, set2, col, row, grid, setGrid);\r\n  }\r\n};\r\n\r\n/**\r\n * Randomly create vertical connections downward to the next row\r\n *\r\n * @param sets the array containing the state of the current row.\r\n * @param row y coordinate.\r\n * @param grid the grid to work with.\r\n * @param setGrid react hook to update the state of the grid.\r\n * @returns the sets in the next row.\r\n */\r\nconst verticalConnections = async (\r\n  sets: Array<Set<number> | null>,\r\n  row: number,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<Array<Set<number> | null>> => {\r\n  const unique = [...new Set(sets)];\r\n  for (let i = 1; i < unique.length; i++) removeRandomElements(unique[i]);\r\n\r\n  const nextRow: Array<Set<number> | null> = Array(grid[0].length).fill(null);\r\n\r\n  for (let i = 1; i < unique.length; i++) {\r\n    const set = unique[i];\r\n    if (!set) throw new Error('Undefined set');\r\n    for (const col of set) {\r\n      await carveVertically(grid, col, row, setGrid);\r\n      nextRow[col] = set;\r\n    }\r\n  }\r\n  return nextRow;\r\n};\r\n\r\nexport const Eller = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n  const [n, m] = [grid.length, grid[0].length];\r\n\r\n  // each cell in the row belongs to a set\r\n  // cells that share a set, also shares a path\r\n  let sets: Array<Set<number> | null> = Array(m).fill(null);\r\n\r\n  for (let row = 1; row < n; row += 2) {\r\n    // give undiscovered cells from previous iteration a set\r\n    populate(sets);\r\n\r\n    await horizontalConnections(sets, row, grid, setGrid);\r\n    // last row: skip creating vertical connections at the bottom of the grid\r\n    if (row === n - 2) return;\r\n    sets = await verticalConnections(sets, row, grid, setGrid);\r\n  }\r\n};\r\n","import {\r\n  carvePassageBetweenAdjacentCoordinates,\r\n  markAllCellsAsWalls,\r\n  popRandomElementFromSet,\r\n} from '../../utils';\r\nimport { Cell, Coord } from '../model/Cell';\r\n\r\ninterface Edge {\r\n  p: Coord;\r\n  q: Coord;\r\n}\r\n\r\n// Simple Tree data structure to see if two \"sets\" are disjoint\r\nclass Tree {\r\n  parent: Tree | undefined;\r\n\r\n  root(): Tree {\r\n    return this.parent ? this.parent.root() : this;\r\n  }\r\n\r\n  isConnected(tree: Tree): boolean {\r\n    return this.root() === tree.root();\r\n  }\r\n\r\n  connect(tree: Tree): void {\r\n    tree.root().parent = this;\r\n  }\r\n}\r\n\r\n// Returns a set of all possible edges in the given grid\r\nconst setOfPossibleEdges = (grid: Cell[][]): Set<Edge> => {\r\n  const edges = new Set<Edge>();\r\n  for (let row = 1; row < grid.length; row++) {\r\n    if (row % 2 === 0) continue;\r\n    for (let col = 1; col < grid[0].length; col++) {\r\n      if (col % 2 === 0) continue;\r\n      const x = col + 2;\r\n      const y = row + 2;\r\n      // East neighbour\r\n      if (x < grid[0].length - 1)\r\n        edges.add({ p: { x: col, y: row }, q: { x: x, y: row } });\r\n      // South neighbour\r\n      if (y < grid.length - 1)\r\n        edges.add({ p: { x: col, y: row }, q: { x: col, y } });\r\n    }\r\n  }\r\n  return edges;\r\n};\r\n\r\nexport const Kruskal = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n\r\n  // each cell is assigned a set to indicate who they belong to\r\n  const sets: Tree[][] = Array.from(Array(grid.length), () =>\r\n    Array.from(Array(grid[0].length), () => new Tree())\r\n  );\r\n\r\n  const edges = setOfPossibleEdges(grid);\r\n\r\n  while (edges.size !== 0) {\r\n    const { p, q } = popRandomElementFromSet(edges);\r\n    const [set1, set2] = [sets[p.y][p.x], sets[q.y][q.x]];\r\n    if (!set1.isConnected(set2)) {\r\n      set1.connect(set2);\r\n      await carvePassageBetweenAdjacentCoordinates(p, q, grid, setGrid);\r\n    }\r\n  }\r\n};\r\n","import {\r\n  adjacentCoords,\r\n  carvePassageBetweenAdjacentCoordinates,\r\n  markAllCellsAsWalls,\r\n  popRandomElementFromSet,\r\n  randomNumber,\r\n  randomOddCoordinates,\r\n} from '../../utils';\r\nimport { Cell, Coord } from '../model/Cell';\r\n\r\n// Retrieves adjacent coordinates that are passages\r\nconst passages = (grid: Cell[][], c: Coord): Coord[] => {\r\n  return adjacentCoords(c, grid.length, grid[0].length, 2).filter(\r\n    (coord) => !grid[coord.y][coord.x].isWall\r\n  );\r\n};\r\n\r\n// Retrieves adjacent coordinates that are walls\r\nconst walls = (grid: Cell[][], c: Coord): Coord[] => {\r\n  return adjacentCoords(c, grid.length, grid[0].length, 2).filter(\r\n    (coord) => grid[coord.y][coord.x].isWall\r\n  );\r\n};\r\n\r\n// Add walls adjacent to the given coordinate, whilst also removing it\r\nconst mark = (coord: Coord, grid: Cell[][], frontier: Set<Coord>): void => {\r\n  walls(grid, coord).forEach((item) => frontier.add(item));\r\n  frontier.delete(coord);\r\n};\r\n\r\nexport const Prim = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n\r\n  const startCoord = randomOddCoordinates(grid.length, grid[0].length);\r\n  const frontier = new Set<Coord>();\r\n\r\n  // need to mark the first cell as path manually otherwise it's gonna crash\r\n  grid[startCoord.y][startCoord.x].isWall = false;\r\n  mark(startCoord, grid, frontier);\r\n\r\n  while (frontier.size !== 0) {\r\n    const p = popRandomElementFromSet(frontier);\r\n\r\n    // Skip if it has already been converted to a path\r\n    if (!grid[p.y][p.x].isWall) continue;\r\n\r\n    const neighbours = passages(grid, p);\r\n    if (neighbours.length !== 0) {\r\n      const q = neighbours[randomNumber(0, neighbours.length - 1)];\r\n      await carvePassageBetweenAdjacentCoordinates(p, q, grid, setGrid);\r\n    }\r\n    mark(p, grid, frontier);\r\n  }\r\n};\r\n","import React from 'react';\r\n\r\nimport {\r\n  adjacentCoords,\r\n  carvePassageBetweenAdjacentCoordinates,\r\n  markAllCellsAsWalls,\r\n  randomOddCoordinates,\r\n} from '../../utils';\r\nimport { Cell } from '../model/Cell';\r\n\r\nexport const shuffle = <T>(array: T[]): T[] => {\r\n  const temp = [...array];\r\n  for (let i = temp.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [temp[i], temp[j]] = [temp[j], temp[i]]; // shorthand for swap\r\n  }\r\n  return temp;\r\n};\r\n\r\nconst carvePassagesFrom = async (\r\n  x: number,\r\n  y: number,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const neighbours = shuffle(\r\n    adjacentCoords({ x, y }, grid.length, grid[0].length, 2)\r\n  );\r\n  visited[y][x] = true;\r\n\r\n  for (const n of neighbours) {\r\n    if (!visited[n.y][n.x]) {\r\n      visited[n.y][n.x] = true;\r\n      await carvePassageBetweenAdjacentCoordinates({ x, y }, n, grid, setGrid);\r\n      await carvePassagesFrom(n.x, n.y, grid, setGrid, visited);\r\n    }\r\n  }\r\n};\r\n\r\nexport const RecursiveBacktracking = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n  const [n, m] = [grid.length, grid[0].length];\r\n  const visited: boolean[][] = Array.from(Array(n), () => Array(m).fill(false));\r\n  const { x, y } = randomOddCoordinates(n, m);\r\n  await carvePassagesFrom(x, y, grid, setGrid, visited);\r\n};\r\n","/* eslint-disable @typescript-eslint/no-use-before-define */\r\nimport React from 'react';\r\n\r\nimport { randomNumber, sleep } from '../../utils';\r\nimport { Cell } from '../model/Cell';\r\n\r\nconst addHWall = async (\r\n  grid: Cell[][],\r\n  minX: number,\r\n  maxX: number,\r\n  y: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const hole = Math.floor(randomNumber(minX, maxX) / 2) * 2 + 1;\r\n  for (let i = minX; i <= maxX; i++) {\r\n    if (i === hole) visited[y][i] = true;\r\n    else if (!visited[y][i] && !grid[y][i].isStart && !grid[y][i].isFinish)\r\n      grid[y][i].isWall = true;\r\n  }\r\n  setGrid([...grid]);\r\n  await sleep(1);\r\n};\r\n\r\nconst addVWall = async (\r\n  grid: Cell[][],\r\n  minY: number,\r\n  maxY: number,\r\n  x: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const hole = Math.floor(randomNumber(minY, maxY) / 2) * 2 + 1;\r\n  for (let i = minY; i <= maxY; i++) {\r\n    if (i === hole) visited[i][x] = true;\r\n    else if (!visited[i][x] && !grid[i][x].isStart && !grid[i][x].isFinish)\r\n      grid[i][x].isWall = true;\r\n  }\r\n  setGrid([...grid]);\r\n  await sleep(1);\r\n};\r\n\r\nconst addOuterWalls = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  // vertical walls\r\n  for (let i = 0; i < grid.length; i++) {\r\n    grid[i][0].isWall = true;\r\n    grid[i][grid[0].length - 1].isWall = true;\r\n  }\r\n  // horizontal walls\r\n  for (let i = 0; i < grid[0].length; i++) {\r\n    grid[0][i].isWall = true;\r\n    grid[grid.length - 1][i].isWall = true;\r\n  }\r\n  setGrid([...grid]);\r\n};\r\n\r\nconst divideHorizontally = async (\r\n  grid: Cell[][],\r\n  minX: number,\r\n  maxX: number,\r\n  minY: number,\r\n  maxY: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const y = Math.floor(randomNumber(minY, maxY) / 2) * 2;\r\n  await addHWall(grid, minX, maxX, y, setGrid, visited);\r\n  // upper chamber\r\n  await divide(grid, minX, maxX, minY, y - 1, setGrid, visited);\r\n  // lower chamber\r\n  await divide(grid, minX, maxX, y + 1, maxY, setGrid, visited);\r\n};\r\n\r\nconst divideVertically = async (\r\n  grid: Cell[][],\r\n  minX: number,\r\n  maxX: number,\r\n  minY: number,\r\n  maxY: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const x = Math.floor(randomNumber(minX, maxX) / 2) * 2;\r\n  await addVWall(grid, minY, maxY, x, setGrid, visited);\r\n  // left chamber\r\n  await divide(grid, minX, x - 1, minY, maxY, setGrid, visited);\r\n  // right chamber\r\n  await divide(grid, x + 1, maxX, minY, maxY, setGrid, visited);\r\n};\r\n\r\nconst divide = async (\r\n  grid: Cell[][],\r\n  minX: number,\r\n  maxX: number,\r\n  minY: number,\r\n  maxY: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  if (maxX - minX < 2 || maxY - minY < 2) return;\r\n  if (maxX - minX < maxY - minY) {\r\n    divideHorizontally(grid, minX, maxX, minY, maxY, setGrid, visited);\r\n  } else if (maxY - minY < maxX - minX) {\r\n    divideVertically(grid, minX, maxX, minY, maxY, setGrid, visited);\r\n  } else {\r\n    if (randomNumber(0, 1) === 0)\r\n      divideHorizontally(grid, minX, maxX, minY, maxY, setGrid, visited);\r\n    else divideVertically(grid, minX, maxX, minY, maxY, setGrid, visited);\r\n  }\r\n};\r\n\r\nexport const RecursiveDivision = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  const visited: boolean[][] = Array.from(Array(grid.length), () =>\r\n    Array(grid[0].length).fill(false)\r\n  );\r\n  await addOuterWalls(grid, setGrid);\r\n  await divide(\r\n    grid,\r\n    1,\r\n    grid[0].length - 2,\r\n    1,\r\n    grid.length - 2,\r\n    setGrid,\r\n    visited\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { Cell } from '../model/Cell';\r\nimport { BinaryTree } from './BinaryTree';\r\nimport { Eller } from './Eller';\r\nimport { Kruskal } from './Kruskal';\r\nimport { Prim } from './Prim';\r\nimport { RecursiveBacktracking } from './RecursiveBacktracking';\r\nimport { RecursiveDivision } from './RecursiveDivision';\r\n\r\ntype mazeFunc = (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n) => Promise<void>;\r\n\r\nexport const getMazeAlgorithm = (algorithmType: string): mazeFunc => {\r\n  if (algorithmType === 'division') return RecursiveDivision;\r\n  else if (algorithmType === 'backtracking') return RecursiveBacktracking;\r\n  else if (algorithmType === 'binary') return BinaryTree;\r\n  else if (algorithmType === 'prim') return Prim;\r\n  else if (algorithmType === 'kruskal') return Kruskal;\r\n  else if (algorithmType === 'eller') return Eller;\r\n  else throw new Error('Invalid argument for Maze Algorithm');\r\n};\r\n","import React from 'react';\r\n\r\nimport { ButtonGroup, ToggleButton } from 'react-bootstrap';\r\n\r\ninterface Algorithm {\r\n  name: string;\r\n  value: string;\r\n}\r\n\r\ninterface Props {\r\n  defaultAlgorithm: string;\r\n  algorithms: Algorithm[];\r\n  setAlgorithm: React.Dispatch<React.SetStateAction<string>>;\r\n}\r\n\r\nexport const AlgorithmButtonGroup: React.FC<Props> = ({\r\n  defaultAlgorithm,\r\n  algorithms,\r\n  setAlgorithm,\r\n}: Props) => {\r\n  return (\r\n    <ButtonGroup className=\"p-1\">\r\n      {algorithms.map((alg) => (\r\n        <ToggleButton\r\n          key={alg.value}\r\n          type=\"radio\"\r\n          variant=\"outline-warning\"\r\n          value={alg.value}\r\n          checked={defaultAlgorithm === alg.value}\r\n          onChange={(e) => setAlgorithm(e.currentTarget.value)}\r\n        >\r\n          {alg.name}\r\n        </ToggleButton>\r\n      ))}\r\n    </ButtonGroup>\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { Button } from 'react-bootstrap';\r\n\r\nimport { Cell } from '../../core/model/Cell';\r\nimport './CellButton.css';\r\n\r\ninterface Props {\r\n  cell: Cell;\r\n  mouseDown: boolean;\r\n  onMouseDown: (row: number, col: number) => void;\r\n  onMouseEnter: (row: number, col: number) => void;\r\n  onMouseUp: () => void;\r\n}\r\n\r\nconst cellColor = (cell: Cell): string => {\r\n  if (cell.isWall) return 'grey';\r\n  else if (cell.isStart) return 'yellow';\r\n  else if (cell.isFinish) return 'blue';\r\n  else if (cell.isPath) return 'Chartreuse';\r\n  // or tomato for brighter\r\n  else if (cell.isActive) return 'crimson';\r\n  else return 'azure';\r\n};\r\n\r\nconst cssAnimation = (cell: Cell): string => {\r\n  return cell.isPath ? 'finish' : cell.isActive ? 'visited' : '';\r\n};\r\n\r\nexport const CellButton: React.FC<Props> = ({\r\n  cell,\r\n  mouseDown,\r\n  onMouseDown,\r\n  onMouseEnter,\r\n  onMouseUp,\r\n}: Props) => {\r\n  return (\r\n    <Button\r\n      className={`cell ${cssAnimation(cell)}`}\r\n      style={{\r\n        backgroundColor: cellColor(cell),\r\n      }}\r\n      onMouseEnter={() => {\r\n        if (mouseDown) onMouseEnter(cell.coord.y, cell.coord.x);\r\n      }}\r\n      onMouseDown={() => onMouseDown(cell.coord.y, cell.coord.x)}\r\n      onMouseUp={onMouseUp}\r\n    />\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { Cell, Coord } from '../../core/model/Cell';\r\nimport { CellButton } from './CellButton';\r\n\r\ninterface Props {\r\n  grid: Cell[][];\r\n  mode: string;\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>;\r\n  start: Coord;\r\n  setStart: React.Dispatch<React.SetStateAction<Coord>>;\r\n  finish: Coord;\r\n  setFinish: React.Dispatch<React.SetStateAction<Coord>>;\r\n  searching: boolean;\r\n}\r\n\r\nexport const Grid: React.FC<Props> = ({\r\n  grid,\r\n  mode,\r\n  setGrid,\r\n  start,\r\n  setStart,\r\n  finish,\r\n  setFinish,\r\n  searching,\r\n}: Props) => {\r\n  const [mouseDown, setMouseDown] = React.useState<boolean>(false);\r\n\r\n  const toggleWall = (row: number, col: number): void => {\r\n    const cell = grid[row][col];\r\n    if (!cell.isStart && !cell.isFinish) {\r\n      cell.isWall = !cell.isWall;\r\n      setGrid([...grid]);\r\n    }\r\n  };\r\n\r\n  const moveStart = (row: number, col: number): void => {\r\n    grid[start.y][start.x].isStart = false;\r\n    const cell: Cell = grid[row][col];\r\n    cell.isStart = true;\r\n    setStart(cell.coord);\r\n    setGrid([...grid]);\r\n  };\r\n\r\n  const moveFinish = (row: number, col: number): void => {\r\n    grid[finish.y][finish.x].isFinish = false;\r\n    const cell = grid[row][col];\r\n    cell.isFinish = true;\r\n    setFinish(cell.coord);\r\n    setGrid([...grid]);\r\n  };\r\n\r\n  const handleMouseUp = (): void => setMouseDown(false);\r\n\r\n  const handleMouseDown = (row: number, col: number): void => {\r\n    if (mode === 'wall') toggleWall(row, col);\r\n    else if (mode === 'start' && !searching) moveStart(row, col);\r\n    else if (mode === 'finish' && !searching) moveFinish(row, col);\r\n    setMouseDown(true);\r\n  };\r\n\r\n  const handleMouseEnter = (row: number, col: number): void => {\r\n    if (mouseDown) {\r\n      if (mode === 'wall') toggleWall(row, col);\r\n      else if (mode === 'start' && !searching) moveStart(row, col);\r\n      else if (mode === 'finish' && !searching) moveFinish(row, col);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <button\r\n        onClick={() => {\r\n          for (let i = 0; i < grid.length; i++) {\r\n            grid[i][0].isWall = true;\r\n            grid[i][grid[0].length - 1].isWall = true;\r\n          }\r\n          // horizontal walls\r\n          for (let i = 0; i < grid[0].length; i++) {\r\n            grid[0][i].isWall = true;\r\n            grid[grid.length - 1][i].isWall = true;\r\n          }\r\n          for (let i = 0; i < grid.length - 1; i++) {\r\n            for (let j = 0; j < grid[0].length - 1; j++) {\r\n              if (i % 2 === 0 && j % 2 === 0) grid[i][j].isWall = true;\r\n            }\r\n          }\r\n          setGrid([...grid]);\r\n        }}\r\n      >\r\n        test me\r\n      </button>\r\n      <div\r\n        onMouseDown={() => {\r\n          setMouseDown(true);\r\n        }}\r\n        onMouseUp={() => {\r\n          setMouseDown(false);\r\n        }}\r\n        onMouseLeave={() => {\r\n          setMouseDown(false);\r\n        }}\r\n      >\r\n        {grid.map((row, i) => (\r\n          <div key={i}>\r\n            {row.map((c, j) => (\r\n              <CellButton\r\n                cell={c}\r\n                key={j}\r\n                mouseDown={mouseDown}\r\n                onMouseDown={handleMouseDown}\r\n                onMouseEnter={handleMouseEnter}\r\n                onMouseUp={handleMouseUp}\r\n              />\r\n            ))}\r\n          </div>\r\n        ))}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n","import React, { SetStateAction } from 'react';\r\n\r\nimport {\r\n  Button,\r\n  ButtonGroup,\r\n  Dropdown,\r\n  DropdownButton,\r\n  ToggleButton,\r\n} from 'react-bootstrap';\r\n\r\ninterface NameValue {\r\n  name: string;\r\n  value: string;\r\n}\r\n\r\ninterface Props {\r\n  mode: string;\r\n  setMode: React.Dispatch<SetStateAction<string>>;\r\n  modes: NameValue[];\r\n  resetGrid: () => void;\r\n  search: () => Promise<void>;\r\n  mazes: NameValue[];\r\n  generateMaze: (algorithmType: string) => Promise<void>;\r\n}\r\n\r\nexport const Panel: React.FC<Props> = ({\r\n  mode,\r\n  modes,\r\n  setMode,\r\n  resetGrid,\r\n  search,\r\n  mazes,\r\n  generateMaze,\r\n}: Props) => {\r\n  return (\r\n    <div\r\n      style={{\r\n        display: 'flex',\r\n        justifyContent: 'center',\r\n        alignItems: 'center',\r\n      }}\r\n    >\r\n      <DropdownButton variant=\"success\" title=\"Mazes\" menuAlign=\"left\">\r\n        {mazes.map((m, i) => (\r\n          <Dropdown.Item\r\n            as=\"button\"\r\n            key={i}\r\n            onClick={() => generateMaze(m.value)}\r\n          >\r\n            {m.name}\r\n          </Dropdown.Item>\r\n        ))}\r\n      </DropdownButton>\r\n      <Button className=\"m-2\" variant=\"danger\" onClick={() => resetGrid()}>\r\n        Reset\r\n      </Button>\r\n      <Button onClick={search} variant=\"primary\">\r\n        Search!\r\n      </Button>\r\n      <ButtonGroup className=\"p-3\">\r\n        {modes.map((m) => (\r\n          <ToggleButton\r\n            key={m.value}\r\n            type=\"radio\"\r\n            variant=\"outline-warning\"\r\n            value={m.value}\r\n            checked={mode === m.value}\r\n            onChange={(e) => setMode(e.currentTarget.value)}\r\n          >\r\n            {m.name}\r\n          </ToggleButton>\r\n        ))}\r\n      </ButtonGroup>\r\n    </div>\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { Col, Container, Row } from 'react-bootstrap';\r\n\r\nimport { getMazeAlgorithm } from '../../core/maze/MazeFactory';\r\nimport { Cell, Coord } from '../../core/model/Cell';\r\nimport { Result } from '../../core/model/PQEntry';\r\nimport { sleep, getPathfindingAlgorithm } from '../../utils';\r\nimport { AlgorithmButtonGroup } from '../common/AlgorithmButtonGroup';\r\nimport { Grid } from './Grid';\r\nimport { Panel } from './Panel';\r\n\r\nconst algorithms = [\r\n  { name: 'UCS', value: 'ucs' },\r\n  { name: 'A*', value: 'astar' },\r\n];\r\nconst mazes = [\r\n  { name: 'Recursive Division', value: 'division' },\r\n  { name: 'Recursive Backtracking', value: 'backtracking' },\r\n  { name: 'Binary Tree (Southeast bias)', value: 'binary' },\r\n  { name: \"Prim's Algorithm\", value: 'prim' },\r\n  { name: \"Kruskal's Algorithm\", value: 'kruskal' },\r\n  { name: \"Eller's Algorithm\", value: 'eller' },\r\n];\r\nconst modes = [\r\n  { name: 'Wall', value: 'wall' },\r\n  { name: 'Start', value: 'start' },\r\n  { name: 'Finish', value: 'finish' },\r\n];\r\n\r\n// Calculate how many cells fit the screen horizontally and vertically\r\nconst calculateCells = (): [number, number] => {\r\n  const noHorizontalCells = Math.floor(window.innerWidth / 30);\r\n  const noVerticalCells = Math.floor((window.innerHeight - 160) / 30);\r\n  // maze algorithm requires maze to have odd size\r\n  return [\r\n    noHorizontalCells % 2 === 0 ? noHorizontalCells - 1 : noHorizontalCells,\r\n    noVerticalCells % 2 === 0 ? noVerticalCells - 1 : noVerticalCells,\r\n  ];\r\n};\r\n\r\nconst resetGrid = (start: Coord, finish: Coord): Cell[][] => {\r\n  // n * m size of the grid\r\n  const [n, m] = calculateCells();\r\n  const grid: Cell[][] = [...Array(m)].map((_, i) => {\r\n    return [...Array(n)].map((_, j) => ({\r\n      coord: { x: j, y: i },\r\n      isActive: false,\r\n      isPath: false,\r\n      isStart: false,\r\n      isFinish: false,\r\n      isWall: false,\r\n    }));\r\n  });\r\n  grid[start.y][start.x].isStart = true;\r\n  grid[finish.y][finish.x].isFinish = true;\r\n  return grid;\r\n};\r\n\r\n// Mark the path received from pathfinding algorithm\r\nconst drawPath = async (\r\n  res: Result,\r\n  grid: Cell[][],\r\n  setState: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  if (res.path) {\r\n    for (const c of res.path) {\r\n      grid[c.y][c.x].isPath = true;\r\n      setState([...grid]);\r\n      await sleep(1);\r\n    }\r\n  }\r\n};\r\n\r\nexport const PathfindingVisualizer: React.FC = () => {\r\n  const [algorithm, setAlgorithm] = React.useState<string>('ucs');\r\n  // to disable moving starting and finish cells during search\r\n  const [searching, setSearching] = React.useState<boolean>(false);\r\n  const [start, setStart] = React.useState<Coord>({ x: 1, y: 3 });\r\n  const [finish, setFinish] = React.useState<Coord>({ x: 7, y: 3 });\r\n  const [grid, setGrid] = React.useState<Cell[][]>(resetGrid(start, finish));\r\n  const [mode, setMode] = React.useState<string>('wall');\r\n\r\n  const reset = (): void => setGrid(resetGrid(start, finish));\r\n\r\n  const search = async (): Promise<void> => {\r\n    const searcher = getPathfindingAlgorithm(algorithm);\r\n    setSearching(true);\r\n    await searcher(start, finish, grid, setGrid).then(async (res) => {\r\n      if (res.success) await drawPath(res, grid, setGrid);\r\n    });\r\n    setSearching(false);\r\n  };\r\n\r\n  const generateMaze = async (algorithmType: string): Promise<void> => {\r\n    const mazeGenerator = getMazeAlgorithm(algorithmType);\r\n    await mazeGenerator(grid, setGrid);\r\n  };\r\n\r\n  return (\r\n    <Container fluid={true} style={{ padding: '0' }}>\r\n      <Row>\r\n        <Col\r\n          style={{\r\n            display: 'flex',\r\n            justifyContent: 'center',\r\n            alignItems: 'center',\r\n          }}\r\n        >\r\n          <Panel\r\n            resetGrid={reset}\r\n            search={search}\r\n            mode={mode}\r\n            setMode={setMode}\r\n            modes={modes}\r\n            mazes={mazes}\r\n            generateMaze={generateMaze}\r\n          />\r\n          <AlgorithmButtonGroup\r\n            defaultAlgorithm={algorithm}\r\n            algorithms={algorithms}\r\n            setAlgorithm={setAlgorithm}\r\n          />\r\n        </Col>\r\n      </Row>\r\n      <Row className=\"justify-content-center\">\r\n        <Col md=\"auto\">\r\n          <Grid\r\n            grid={grid}\r\n            mode={mode}\r\n            setGrid={setGrid}\r\n            start={start}\r\n            setStart={setStart}\r\n            finish={finish}\r\n            setFinish={setFinish}\r\n            searching={searching}\r\n          />\r\n        </Col>\r\n      </Row>\r\n    </Container>\r\n  );\r\n};\r\n","import React, { SetStateAction } from 'react';\r\n\r\nimport { Button } from 'react-bootstrap';\r\n\r\nimport { Bar } from '../../core/model/Bar';\r\n\r\ninterface Props {\r\n  num: number;\r\n  handleNumberChange: (e: React.ChangeEvent<HTMLInputElement>) => void;\r\n  sort: () => Promise<void>;\r\n  reset: () => void;\r\n  setBars: React.Dispatch<SetStateAction<Bar[]>>;\r\n  delay: number;\r\n  setDelay: React.Dispatch<SetStateAction<number>>;\r\n}\r\n\r\nexport const Panel: React.FC<Props> = ({\r\n  num,\r\n  handleNumberChange,\r\n  sort,\r\n  reset,\r\n  delay,\r\n  setDelay,\r\n}: Props) => {\r\n  const renderRangeSlider = (): JSX.Element => (\r\n    <label className=\"mx-2\" style={{ width: '10%', textAlign: 'left' }}>\r\n      Delay\r\n      <input\r\n        name=\"foo\"\r\n        type=\"range\"\r\n        min=\"1\"\r\n        max=\"100\"\r\n        value={delay}\r\n        className=\"slider\"\r\n        onChange={(e) => setDelay(parseInt(e.target.value))}\r\n      />\r\n    </label>\r\n  );\r\n\r\n  return (\r\n    <span>\r\n      {renderRangeSlider()}\r\n      <input\r\n        className=\"input-number\"\r\n        name=\"no. bars\"\r\n        type=\"number\"\r\n        value={num}\r\n        step={5}\r\n        min=\"5\"\r\n        max=\"150\"\r\n        onChange={handleNumberChange}\r\n        onKeyDown={(e) => e.preventDefault()}\r\n      />\r\n      <Button onClick={reset} className=\"mx-2\" variant=\"danger\">\r\n        Reset\r\n      </Button>\r\n      <Button onClick={sort}>Sort</Button>\r\n    </span>\r\n  );\r\n};\r\n","import React, { useState, useEffect } from 'react';\r\n\r\nimport '../../App.css';\r\nimport { Col, Container, Row } from 'react-bootstrap';\r\n\r\nimport { Bar } from '../../core/model/Bar';\r\nimport { BLUE, GREEN } from '../../core/model/Color';\r\nimport { sleep, getSortingAlgorithm } from '../../utils';\r\nimport { AlgorithmButtonGroup } from '../common/AlgorithmButtonGroup';\r\nimport { Panel } from './Panel';\r\n\r\nconst algorithms = [\r\n  { name: 'Insertion Sort', value: 'insertion' },\r\n  { name: 'Selection Sort', value: 'selection' },\r\n  { name: 'Bubble Sort', value: 'bubble' },\r\n  { name: 'Quicksort', value: 'quick' },\r\n  { name: 'Merge Sort', value: 'merge' },\r\n  { name: 'Cocktail Sort', value: 'cocktail' },\r\n  { name: 'Heap Sort', value: 'heap' },\r\n];\r\n\r\nexport const SortingVisualizer: React.FC = () => {\r\n  const [bars, setBars] = useState<Bar[]>([]);\r\n  const [num, setNum] = useState<number>(90);\r\n  const [algorithm, setAlgorithm] = useState<string>('insertion');\r\n  const [delay, setDelay] = useState<number>(20);\r\n\r\n  const resetBars = (): void =>\r\n    setBars(\r\n      [...Array(num)].map(() => ({\r\n        num: Math.floor(Math.random() * 80) + 1,\r\n        color: BLUE,\r\n      }))\r\n    );\r\n\r\n  useEffect((): void => {\r\n    resetBars();\r\n  }, [num]); // eslint-disable-line react-hooks/exhaustive-deps\r\n\r\n  // Green progressive animation\r\n  const finish = async (\r\n    bars: Bar[],\r\n    setState: React.Dispatch<React.SetStateAction<Bar[]>>\r\n  ): Promise<void> => {\r\n    for (let i = 0; i < bars.length; i++) {\r\n      bars[i].color = GREEN;\r\n      setState([...bars]);\r\n      await sleep(1);\r\n    }\r\n  };\r\n\r\n  const sort = async (): Promise<void> => {\r\n    const sorter = getSortingAlgorithm(algorithm);\r\n    await sorter(bars, setBars, delay);\r\n    await finish(bars, setBars);\r\n  };\r\n\r\n  const handleNumberChange = (e: React.ChangeEvent<HTMLInputElement>): void => {\r\n    const { value, min, max } = e.target;\r\n    setNum(Math.max(Number(min), Math.min(Number(max), Number(value))));\r\n  };\r\n\r\n  const renderBars = (): JSX.Element => (\r\n    <div className=\"sorting-container\">\r\n      {bars.map((bar: Bar, idx) => (\r\n        <div\r\n          key={`b-${idx}`}\r\n          className=\"bar\"\r\n          style={{\r\n            backgroundColor: `${bar.color}`,\r\n            width: '1vw',\r\n            height: `${bar.num}vmin`,\r\n          }}\r\n        />\r\n      ))}\r\n    </div>\r\n  );\r\n\r\n  return (\r\n    <Container fluid={true} style={{ padding: '0' }}>\r\n      <Row className=\"app-vanish text-center justify-content-center\">\r\n        <Col md=\"auto\">\r\n          <Panel\r\n            num={num}\r\n            handleNumberChange={handleNumberChange}\r\n            reset={resetBars}\r\n            setBars={setBars}\r\n            sort={sort}\r\n            delay={delay}\r\n            setDelay={setDelay}\r\n          />\r\n          <AlgorithmButtonGroup\r\n            defaultAlgorithm={algorithm}\r\n            algorithms={algorithms}\r\n            setAlgorithm={setAlgorithm}\r\n          />\r\n        </Col>\r\n      </Row>\r\n      <Row className=\"justify-content-center\">\r\n        <Col md=\"auto\">{renderBars()}</Col>\r\n      </Row>\r\n    </Container>\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { HashRouter as Router, Switch, Route } from 'react-router-dom';\r\n\r\nimport { Header } from './components/common/Header';\r\nimport { PathfindingVisualizer } from './components/pathfinding/PathfindingVisualizer';\r\nimport { SortingVisualizer } from './components/sorting/SortingVisualizer';\r\n\r\nconst App = (): JSX.Element => {\r\n  return (\r\n    <Router>\r\n      <Header />\r\n      <Switch>\r\n        <Route exact path={['/', '/sorting']} component={SortingVisualizer} />\r\n        <Route path=\"/pathfinding\" component={PathfindingVisualizer} />\r\n      </Switch>\r\n    </Router>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from 'react';\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}