{"version":3,"sources":["components/common/Header.tsx","assets/github.png","utils/Sleep.ts","utils/Array.ts","utils/Path.ts","utils/Coordinates.ts","utils/Random.ts","utils/Maze.ts","core/maze/BinaryTree.ts","core/maze/Eller.ts","core/maze/Kruskal.ts","core/maze/Prim.ts","core/maze/RecursiveBacktracking.ts","core/maze/RecursiveDivision.ts","core/maze/MazeFactory.ts","core/pathfinding/Astar.ts","core/pathfinding/UCS.ts","core/pathfinding/PathfindingFactory.ts","components/common/AlgorithmButtonGroup.tsx","components/pathfinding/CellButton.tsx","components/pathfinding/Grid.tsx","components/pathfinding/Popover.tsx","components/pathfinding/Panel.tsx","components/pathfinding/PathfindingVisualizer.tsx","core/model/Color.ts","core/sorting/BubbleSort.ts","core/sorting/CocktailSort.ts","core/sorting/HeapSort.ts","core/sorting/InsertionSort.ts","core/sorting/MergeSort.ts","core/sorting/QuickSort.ts","core/sorting/SelectionSort.ts","core/sorting/SortingFactory.ts","components/sorting/Panel.tsx","components/sorting/SortingVisualizer.tsx","App.tsx","index.tsx"],"names":["Header","Navbar","expand","bg","variant","className","Container","Brand","href","OverlayTrigger","placement","overlay","Tooltip","id","src","alt","Toggle","aria-controls","Collapse","Nav","Link","as","to","sleep","delay","Promise","resolve","setTimeout","swap","arr","x","y","setState","extractPath","entry","path","pqe","unshift","coord","backPointer","yDir","xDir","adjacentCoords","c","n","m","offset","coords","i","row","col","push","isSameCoord","c1","c2","alignmentBetweenCoordinates","p","q","Math","max","min","Error","closestOddCoord","randomNumber","floor","random","randomOddCoordinates","popRandomElementFromSet","set","size","rs","Array","from","values","delete","markAllCellsAsWalls","grid","setGrid","length","isWall","carveHorizontaly","a","carveVertically","carvePassageBetweenAdjacentCoordinates","alignment","BinaryTree","dirs","dir","coinflip","populate","sets","Set","_mergeSets","set1","set2","merged","forEach","value","add","mergeSets","val","index","removeRandomElements","s","horizontalConnections","verticalConnections","unique","nextRow","fill","Eller","Tree","parent","this","root","tree","setOfPossibleEdges","edges","Kruskal","isConnected","connect","passages","filter","mark","frontier","walls","item","Prim","startCoord","neighbours","shuffle","array","temp","j","carvePassagesFrom","visited","RecursiveBacktracking","addHWall","minX","maxX","hole","isStart","isFinish","addVWall","minY","maxY","addOuterWalls","divideHorizontally","divide","divideVertically","RecursiveDivision","getMazeAlgorithm","algorithmType","manhattanDistance","abs","fudge","crossProduct","start","dx1","dy1","dx2","dy2","cross","guessCost","heuristic","astar","goal","pq","PriorityQueue","comparator","p1","p2","costToHere","queue","dequeue","success","isActive","costToNext","UCS","getPathfindingAlgorithm","algorithm","AlgorithmButtonGroup","defaultAlgorithm","algorithms","setAlgorithm","ButtonGroup","map","alg","ToggleButton","type","checked","onChange","e","currentTarget","name","cellColor","cell","isPath","cssAnimation","CellButton","mouseDown","onMouseDown","onMouseEnter","onMouseUp","Button","style","backgroundColor","Grid","mode","setMode","setStart","finish","setFinish","searching","React","useState","setMouseDown","toggleWall","handleMouseUp","handleMouseDown","handleMouseEnter","moveFinish","moveStart","background","border","outline","display","height","width","cursor","marginBottom","onClick","onMouseLeave","popover","Popover","Title","Content","Panel","heuristics","setHeuristic","resetGrid","removePath","search","mazes","generateMaze","justifyContent","alignItems","DropdownButton","title","menuAlign","Dropdown","Item","SplitButton","toggleLabel","alignRight","charAt","toUpperCase","slice","disabled","h","newGrid","noHorizontalCells","window","innerWidth","noVerticalCells","innerHeight","calculateCells","_","drawPath","res","PathfindingVisualizer","setSearching","searcher","then","relocateStartAndFinishToOddCoords","newStart","newFinish","mazeGenerator","fluid","padding","Row","Col","md","RED","BLUE","GREEN","animation","bars","color","bubbleSort","greatestElementIndex","num","cocktailSort","swapped","end","heapify","largest","right","left","heapSort","insertionSort","nextGap","gap","ceil","inPlaceMerge","_sort","mid","mergeSort","partitionIndex","getMedian","midpoint","partition","pivotIndex","pivot","quicksort","selectionSort","iMin","getSortingAlgorithm","handleNumberChange","sort","reset","setDelay","textAlign","parseInt","target","step","onKeyDown","preventDefault","SortingVisualizer","setBars","setNum","resetBars","useEffect","sorter","Number","bar","idx","App","exact","component","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.e8c464ac.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nimport {\r\n  Container,\r\n  Nav,\r\n  Navbar,\r\n  OverlayTrigger,\r\n  Tooltip,\r\n} from 'react-bootstrap';\r\nimport { Link } from 'react-router-dom';\r\n\r\nimport logo from '../../assets/github.png';\r\n\r\nexport const Header = (): JSX.Element => {\r\n  return (\r\n    <Navbar expand=\"md\" bg=\"dark\" variant=\"dark\" className=\"app-vanish\">\r\n      <Container>\r\n        <Navbar.Brand href=\"https://github.com/Puh00/algorithm-visualizer\">\r\n          <OverlayTrigger\r\n            placement=\"bottom\"\r\n            overlay={<Tooltip id=\"tip\">View Project</Tooltip>}\r\n          >\r\n            <img src={logo} alt=\"github logo\" />\r\n          </OverlayTrigger>\r\n        </Navbar.Brand>\r\n        <Navbar.Toggle aria-controls=\"basic-navbar-nav\" />\r\n        <Navbar.Collapse id=\"basic-navbar-nav\">\r\n          <Nav className=\"me-auto\">\r\n            <Nav.Link as={Link} to=\"/sorting\">\r\n              Sorting\r\n            </Nav.Link>\r\n            <Nav.Link as={Link} to=\"/pathfinding\">\r\n              Pathfinding\r\n            </Nav.Link>\r\n          </Nav>\r\n        </Navbar.Collapse>\r\n      </Container>\r\n    </Navbar>\r\n  );\r\n};\r\n","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RERCMUIwOUY4NkNFMTFFM0FBNTJFRTMzNTJEMUJDNDYiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RERCMUIwOUU4NkNFMTFFM0FBNTJFRTMzNTJEMUJDNDYiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU1MTc4QTJBOTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU1MTc4QTJCOTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+jUqS1wAAApVJREFUeNq0l89rE1EQx3e3gVJoSPzZeNEWPKgHoa0HBak0iHiy/4C3WvDmoZ56qJ7txVsPQu8qlqqHIhRKJZceesmhioQEfxTEtsoSpdJg1u/ABJ7Pmc1m8zLwgWTmzcw3L+/te+tHUeQltONgCkyCi2AEDHLsJ6iBMlgHL8FeoqokoA2j4CloRMmtwTmj7erHBXPgCWhG6a3JNXKdCiDl1cidVbXZkJoXQRi5t5BrxwoY71FzU8S4JuAIqFkJ2+BFSlEh525b/hr3+k/AklDkNsf6wTT4yv46KIMNpsy+iMdMc47HNWxbsgVcUn7FmLAzzoFAWDsBx+wVP6bUpp5ewI+DOeUx0Wd9D8F70BTGNjkWtqnhmT1JQAHcUgZd8Lo3rQb1LAT8eJVUfgGvHQigGp+V2Z0iAUUl8QH47kAA1XioxIo+bRN8OG8F/oBjwv+Z1nJgX5jpdzQDw0LCjsPmrcW7I/iHScCAEDj03FtD8A0EyuChHgg4KTlJQF3wZ7WELppnBX+dBFSVpJsOBWi1qiRgSwnOgoyD5hmuJdkWCVhTgnTvW3AgYIFrSbZGh0UW/Io5Vp+DQoK7o80pztWMemZbgxeNwCNwDbw1fIfgGZjhU6xPaJgBV8BdsMw5cbZoHsenwYFxkZzl83xTSKTiviCAfCsJLysH3POfC8m8NegyGAGfLP/VmGmfSChgXroR0RSWjEFv2J/nG84cuKFMf4sTCZqXuJd4KaXFVjEG3+tw4eXbNK/YC9oXXs3O8NY8y99L4BXY5cvLY/Bb2VZ58EOJVcB18DHJq9lRsKr8inyKGVjlmh29mtHs3AHfuhCwy1vXT/Nu2GKQt+UHsGdctyX6eQyNvc+5sfX9Dl7Pe2J/BRgAl2CpwmrsHR0AAAAASUVORK5CYII=\"","export const sleep = (delay: number): Promise<void> =>\r\n  new Promise((resolve) => setTimeout(resolve, delay));\r\n","export const swap = <T>(\r\n  arr: T[],\r\n  x: number,\r\n  y: number,\r\n  setState?: React.Dispatch<React.SetStateAction<T[]>>\r\n): void => {\r\n  [arr[y], arr[x]] = [arr[x], arr[y]];\r\n  if (setState) setState([...arr]);\r\n};\r\n","import { Coord } from '../core/model/Cell';\r\nimport { PQEntry } from '../core/model/PQEntry';\r\n\r\n/**\r\n * Extract the full path from start to goal\r\n * @param entry the final priority queue entry\r\n * @returns the path from start to goal as a list of cells\r\n */\r\nexport const extractPath = (entry: PQEntry): Coord[] => {\r\n  const path = [];\r\n  let pqe: PQEntry | null = entry;\r\n  while (pqe !== null) {\r\n    path.unshift(pqe.coord);\r\n    pqe = pqe.backPointer;\r\n  }\r\n  return path;\r\n};\r\n","import { Coord } from '../core/model/Cell';\r\n\r\n// Direction vectors: [Up, Right, Down, Left]\r\nconst yDir = [-1, 0, 1, 0];\r\nconst xDir = [0, 1, 0, -1];\r\n\r\n/**\r\n * Retrieves adjacent coordinates that shares a border with the given coordinate.\r\n * @param c the coordinate to evaluate.\r\n * @param n the height of the grid.\r\n * @param m the width of the grid.\r\n * @param offset by default, the function will only give neighbours that are 1 unit away.\r\n * @returns adjacent coordinates that are within bounds.\r\n */\r\nexport const adjacentCoords = (\r\n  c: Coord,\r\n  n: number,\r\n  m: number,\r\n  offset = 1\r\n): Coord[] => {\r\n  const coords: Coord[] = [];\r\n  for (let i = 0; i < 4; i++) {\r\n    const row = c.y + yDir[i] * offset;\r\n    const col = c.x + xDir[i] * offset;\r\n    if (row >= 0 && col >= 0 && row < n && col < m) {\r\n      coords.push({ x: col, y: row });\r\n    }\r\n  }\r\n  return coords;\r\n};\r\n\r\n// Since Typescript compare by references...\r\nexport const isSameCoord = (c1: Coord, c2: Coord): boolean =>\r\n  c1.x === c2.x && c1.y === c2.y;\r\n\r\ntype dir = 'HORIZONTAL' | 'VERTICAL';\r\n\r\n/**\r\n * Calculates the alignement between two coordinates.\r\n * @param p the first coordinate.\r\n * @param q the second coordinate.\r\n * @throws will throw an error if the coordinates are neither vertically or\r\n * horizontally aligned\r\n * @returns the alignment between the coordinates.\r\n */\r\nexport const alignmentBetweenCoordinates = (p: Coord, q: Coord): dir => {\r\n  if (Math.max(p.y, q.y) - Math.min(p.y, q.y) === 0) return 'HORIZONTAL';\r\n  else if (Math.max(p.x, q.x) - Math.min(p.x, q.x) === 0) return 'VERTICAL';\r\n  else throw new Error('Neither horizontally or vertically aligned');\r\n};\r\n\r\n/**\r\n * If {p} is not located at odd coordinates, modify it so that the coordinates are odd.\r\n * @param p the coordinates.\r\n * @returns odd coordinates.\r\n */\r\nexport const closestOddCoord = (p: Coord): Coord => {\r\n  if (p.x < 0 || p.y < 0) throw new Error('Invalid negative coordinate');\r\n  const x = p.x % 2 !== 0 ? p.x : p.x - 1 < 1 ? p.x + 1 : p.x - 1;\r\n  const y = p.y % 2 !== 0 ? p.y : p.y - 1 < 1 ? p.y + 1 : p.y - 1;\r\n  return { x, y };\r\n};\r\n","import { Coord } from '../core/model/Cell';\r\n\r\n// inclusive: [min, max]\r\nexport const randomNumber = (min: number, max: number): number =>\r\n  Math.floor(Math.random() * (max - min + 1) + min);\r\n\r\n/**\r\n * Produces a random odd coordinate within the bounds of the given paramters\r\n * @param n Vertical size.\r\n * @param m Horizontal size.\r\n * @returns a random odd coordinate.\r\n */\r\nexport const randomOddCoordinates = (n: number, m: number): Coord => {\r\n  const x = randomNumber(2, m - 1);\r\n  const y = randomNumber(2, n - 1);\r\n  return { x: x % 2 === 0 ? x - 1 : x, y: y % 2 === 0 ? y - 1 : y };\r\n};\r\n\r\n/**\r\n * Removes a random element from the set and returns that object as the\r\n * value of this function\r\n * @param set the set to pick a random element from.\r\n * @throws will throw an error if the set is empty.\r\n * @returns the randomly picked element.\r\n */\r\nexport const popRandomElementFromSet = <T>(set: Set<T>): T => {\r\n  if (set.size === 0) throw new Error('Empty Set');\r\n  const rs = Array.from(set.values())[Math.floor(Math.random() * set.size)];\r\n  set.delete(rs);\r\n  return rs;\r\n};\r\n","import { alignmentBetweenCoordinates, sleep } from '.';\r\nimport { Cell, Coord } from '../core/model/Cell';\r\n\r\n/**\r\n * Convert each cell in the grid to a wall.\r\n * @param grid the grid that has the state of every cell.\r\n * @param setGrid react hook to update the state of the grid.\r\n */\r\nexport const markAllCellsAsWalls = (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): void => {\r\n  for (let row = 0; row < grid.length; row++) {\r\n    for (let col = 0; col < grid[0].length; col++) {\r\n      grid[row][col].isWall = true;\r\n    }\r\n  }\r\n  setGrid([...grid]);\r\n};\r\n\r\n/**\r\n * Carves to the right from the given coordinate.\r\n * @param grid the grid to carve upon.\r\n * @param x x coordinate.\r\n * @param y y coordinate.\r\n * @param setGrid react hook to update the state of the grid.\r\n */\r\nexport const carveHorizontaly = async (\r\n  grid: Cell[][],\r\n  x: number,\r\n  y: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  for (let i = 0; i < 3; i++) grid[y][x + i].isWall = false;\r\n  setGrid([...grid]);\r\n  await sleep(1);\r\n};\r\n\r\n/**\r\n * Carves downwards from the given coordinate.\r\n * @param grid the grid to carve upon.\r\n * @param x x coordinate.\r\n * @param y y coordinate.\r\n * @param setGrid react hook to update the state of the grid.\r\n */\r\nexport const carveVertically = async (\r\n  grid: Cell[][],\r\n  x: number,\r\n  y: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  for (let i = 0; i < 3; i++) grid[y + i][x].isWall = false;\r\n  setGrid([...grid]);\r\n  await sleep(1);\r\n};\r\n\r\n/**\r\n * Carve a passage between two coordinates if and only if they are adjacent\r\n * and vertically or horizontally aligned.\r\n * @param p starting coordinate.\r\n * @param q target coordinate.\r\n * @param grid the grid to carve upon.\r\n * @param setGrid react hook to update the state.\r\n */\r\nexport const carvePassageBetweenAdjacentCoordinates = async (\r\n  p: Coord,\r\n  q: Coord,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  const alignment = alignmentBetweenCoordinates(p, q);\r\n  if (alignment === 'HORIZONTAL')\r\n    // current cell and neighbour are horizontally aligned\r\n    await carveHorizontaly(grid, Math.min(p.x, q.x), p.y, setGrid);\r\n  else if (alignment === 'VERTICAL')\r\n    // ...vertically aligned\r\n    await carveVertically(grid, p.x, Math.min(p.y, q.y), setGrid);\r\n};\r\n","import {\r\n  carveHorizontaly,\r\n  carveVertically,\r\n  markAllCellsAsWalls,\r\n  randomNumber,\r\n} from '../../utils';\r\nimport { Cell } from '../model/Cell';\r\n\r\n// Binary Tree with Southeast bias\r\nexport const BinaryTree = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n\r\n  for (let row = 1; row < grid.length; row++) {\r\n    if (row % 2 === 0) continue;\r\n    for (let col = 1; col < grid[0].length; col++) {\r\n      if (col % 2 === 0) continue;\r\n      const dirs: string[] = [];\r\n      // if within bounds add the direction\r\n      if (col + 2 < grid[0].length - 1) dirs.push('EAST');\r\n      if (row + 2 < grid.length - 1) dirs.push('SOUTH');\r\n\r\n      const dir = dirs[randomNumber(0, dirs.length - 1)];\r\n      if (dir === 'EAST') await carveHorizontaly(grid, col, row, setGrid);\r\n      else if (dir === 'SOUTH') await carveVertically(grid, col, row, setGrid);\r\n    }\r\n  }\r\n};\r\n","import {\r\n  carveHorizontaly,\r\n  carveVertically,\r\n  markAllCellsAsWalls,\r\n  popRandomElementFromSet,\r\n} from '../../utils';\r\nimport { Cell } from '../model/Cell';\r\n\r\nconst coinflip = (): boolean => Math.random() > 0.5;\r\n\r\n/**\r\n * Replaces all of the null values in the current row with a new set\r\n * @param sets the array containing the sets of the current row.\r\n */\r\nconst populate = (sets: Array<Set<number> | null>): void => {\r\n  for (let i = 1; i < sets.length; i += 2) if (!sets[i]) sets[i] = new Set([i]);\r\n};\r\n\r\nconst _mergeSets = (\r\n  set1: Set<number> | null,\r\n  set2: Set<number> | null\r\n): Set<number> => {\r\n  if (!set1 || !set2) throw new Error(\"Can't merge undefined sets\");\r\n  const merged: Set<number> = new Set();\r\n  set1.forEach((value) => merged.add(value));\r\n  set2.forEach((value) => merged.add(value));\r\n  return merged;\r\n};\r\n\r\n/**\r\n * Merge two sets if and only if they are disjoint.\r\n *\r\n * Also updates previous sets to match with the newly merged set.\r\n *\r\n * @param sets the array containing the sets of the current row.\r\n * @param set1 the first coordinate's set.\r\n * @param set2 the second coordinate's set.\r\n * @param col x coordinate.\r\n * @param row y coordinate.\r\n * @param grid the grid to work with.\r\n * @param setGrid react hook to update the state of the grid.\r\n */\r\nconst mergeSets = async (\r\n  sets: Array<Set<number> | null>,\r\n  set1: Set<number> | null,\r\n  set2: Set<number> | null,\r\n  col: number,\r\n  row: number,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  if (set1 === set2) return;\r\n  const merged = _mergeSets(set1, set2);\r\n  [sets[col], sets[col + 2]] = [merged, merged];\r\n  // manually update earlier identical sets\r\n  sets.forEach((val, index) => {\r\n    if (val === set1 || val === set2) sets[index] = merged;\r\n  });\r\n  await carveHorizontaly(grid, col, row, setGrid);\r\n};\r\n\r\n/**\r\n * For each element in the set, randomly decide whether to remove it or not.\r\n * Ensures that there is at least one element left in the set.\r\n * @param s the set to manipulate.\r\n */\r\nconst removeRandomElements = (s: Set<number> | null): void => {\r\n  if (!s) throw new Error(\"Can't pop undefined set\");\r\n  for (let i = s.size; i > 1; i--) if (coinflip()) popRandomElementFromSet(s);\r\n};\r\n\r\nconst horizontalConnections = async (\r\n  sets: Array<Set<number> | null>,\r\n  row: number,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  for (let col = 1; col < grid[0].length; col += 2) {\r\n    // skip if out of bounds\r\n    if (!grid[row][col + 2]) continue;\r\n\r\n    const [set1, set2] = [sets[col], sets[col + 2]];\r\n\r\n    if (row !== grid.length - 2) {\r\n      if (coinflip())\r\n        // randomly join adjacent cells, given that they are disjoint\r\n        await mergeSets(sets, set1, set2, col, row, grid, setGrid);\r\n    }\r\n    // last row, connect all adjacent disjoint sets\r\n    else await mergeSets(sets, set1, set2, col, row, grid, setGrid);\r\n  }\r\n};\r\n\r\n/**\r\n * Randomly create vertical connections downward to the next row\r\n *\r\n * @param sets the array containing the state of the current row.\r\n * @param row y coordinate.\r\n * @param grid the grid to work with.\r\n * @param setGrid react hook to update the state of the grid.\r\n * @returns the sets in the next row.\r\n */\r\nconst verticalConnections = async (\r\n  sets: Array<Set<number> | null>,\r\n  row: number,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<Array<Set<number> | null>> => {\r\n  const unique = [...new Set(sets)];\r\n  for (let i = 1; i < unique.length; i++) removeRandomElements(unique[i]);\r\n\r\n  const nextRow: Array<Set<number> | null> = Array(grid[0].length).fill(null);\r\n\r\n  for (let i = 1; i < unique.length; i++) {\r\n    const set = unique[i];\r\n    if (!set) throw new Error('Undefined set');\r\n    for (const col of set) {\r\n      await carveVertically(grid, col, row, setGrid);\r\n      nextRow[col] = set;\r\n    }\r\n  }\r\n  return nextRow;\r\n};\r\n\r\nexport const Eller = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n  const [n, m] = [grid.length, grid[0].length];\r\n\r\n  // each cell in the row belongs to a set\r\n  // cells that share a set, also shares a path\r\n  let sets: Array<Set<number> | null> = Array(m).fill(null);\r\n\r\n  for (let row = 1; row < n; row += 2) {\r\n    // give undiscovered cells from previous iteration a set\r\n    populate(sets);\r\n\r\n    await horizontalConnections(sets, row, grid, setGrid);\r\n    // last row: skip creating vertical connections at the bottom of the grid\r\n    if (row === n - 2) return;\r\n    sets = await verticalConnections(sets, row, grid, setGrid);\r\n  }\r\n};\r\n","import {\r\n  carvePassageBetweenAdjacentCoordinates,\r\n  markAllCellsAsWalls,\r\n  popRandomElementFromSet,\r\n} from '../../utils';\r\nimport { Cell, Coord } from '../model/Cell';\r\n\r\ninterface Edge {\r\n  p: Coord;\r\n  q: Coord;\r\n}\r\n\r\n// Simple Tree data structure to see if two \"sets\" are disjoint\r\nclass Tree {\r\n  parent: Tree | undefined;\r\n\r\n  root(): Tree {\r\n    return this.parent ? this.parent.root() : this;\r\n  }\r\n\r\n  isConnected(tree: Tree): boolean {\r\n    return this.root() === tree.root();\r\n  }\r\n\r\n  connect(tree: Tree): void {\r\n    tree.root().parent = this;\r\n  }\r\n}\r\n\r\n// Returns a set of all possible edges in the given grid\r\nconst setOfPossibleEdges = (grid: Cell[][]): Set<Edge> => {\r\n  const edges = new Set<Edge>();\r\n  for (let row = 1; row < grid.length; row++) {\r\n    if (row % 2 === 0) continue;\r\n    for (let col = 1; col < grid[0].length; col++) {\r\n      if (col % 2 === 0) continue;\r\n      const x = col + 2;\r\n      const y = row + 2;\r\n      // East neighbour\r\n      if (x < grid[0].length - 1)\r\n        edges.add({ p: { x: col, y: row }, q: { x: x, y: row } });\r\n      // South neighbour\r\n      if (y < grid.length - 1)\r\n        edges.add({ p: { x: col, y: row }, q: { x: col, y } });\r\n    }\r\n  }\r\n  return edges;\r\n};\r\n\r\nexport const Kruskal = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n\r\n  // each cell is assigned a set to indicate who they belong to\r\n  const sets: Tree[][] = Array.from(Array(grid.length), () =>\r\n    Array.from(Array(grid[0].length), () => new Tree())\r\n  );\r\n\r\n  const edges = setOfPossibleEdges(grid);\r\n\r\n  while (edges.size !== 0) {\r\n    const { p, q } = popRandomElementFromSet(edges);\r\n    const [set1, set2] = [sets[p.y][p.x], sets[q.y][q.x]];\r\n    if (!set1.isConnected(set2)) {\r\n      set1.connect(set2);\r\n      await carvePassageBetweenAdjacentCoordinates(p, q, grid, setGrid);\r\n    }\r\n  }\r\n};\r\n","import {\r\n  adjacentCoords,\r\n  carvePassageBetweenAdjacentCoordinates,\r\n  markAllCellsAsWalls,\r\n  popRandomElementFromSet,\r\n  randomNumber,\r\n  randomOddCoordinates,\r\n} from '../../utils';\r\nimport { Cell, Coord } from '../model/Cell';\r\n\r\n// Retrieves adjacent coordinates that are passages\r\nconst passages = (grid: Cell[][], c: Coord): Coord[] => {\r\n  return adjacentCoords(c, grid.length, grid[0].length, 2).filter(\r\n    (coord) => !grid[coord.y][coord.x].isWall\r\n  );\r\n};\r\n\r\n// Retrieves adjacent coordinates that are walls\r\nconst walls = (grid: Cell[][], c: Coord): Coord[] => {\r\n  return adjacentCoords(c, grid.length, grid[0].length, 2).filter(\r\n    (coord) => grid[coord.y][coord.x].isWall\r\n  );\r\n};\r\n\r\n// Add walls adjacent to the given coordinate, whilst also removing it\r\nconst mark = (coord: Coord, grid: Cell[][], frontier: Set<Coord>): void => {\r\n  walls(grid, coord).forEach((item) => frontier.add(item));\r\n  frontier.delete(coord);\r\n};\r\n\r\nexport const Prim = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n\r\n  const startCoord = randomOddCoordinates(grid.length, grid[0].length);\r\n  const frontier = new Set<Coord>();\r\n\r\n  // need to mark the first cell as path manually otherwise it's gonna crash\r\n  grid[startCoord.y][startCoord.x].isWall = false;\r\n  mark(startCoord, grid, frontier);\r\n\r\n  while (frontier.size !== 0) {\r\n    const p = popRandomElementFromSet(frontier);\r\n\r\n    // Skip if it has already been converted to a path\r\n    if (!grid[p.y][p.x].isWall) continue;\r\n\r\n    const neighbours = passages(grid, p);\r\n    if (neighbours.length !== 0) {\r\n      const q = neighbours[randomNumber(0, neighbours.length - 1)];\r\n      await carvePassageBetweenAdjacentCoordinates(p, q, grid, setGrid);\r\n    }\r\n    mark(p, grid, frontier);\r\n  }\r\n};\r\n","import React from 'react';\r\n\r\nimport {\r\n  adjacentCoords,\r\n  carvePassageBetweenAdjacentCoordinates,\r\n  markAllCellsAsWalls,\r\n  randomOddCoordinates,\r\n} from '../../utils';\r\nimport { Cell } from '../model/Cell';\r\n\r\nexport const shuffle = <T>(array: T[]): T[] => {\r\n  const temp = [...array];\r\n  for (let i = temp.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [temp[i], temp[j]] = [temp[j], temp[i]]; // shorthand for swap\r\n  }\r\n  return temp;\r\n};\r\n\r\nconst carvePassagesFrom = async (\r\n  x: number,\r\n  y: number,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const neighbours = shuffle(\r\n    adjacentCoords({ x, y }, grid.length, grid[0].length, 2)\r\n  );\r\n  visited[y][x] = true;\r\n\r\n  for (const n of neighbours) {\r\n    if (!visited[n.y][n.x]) {\r\n      visited[n.y][n.x] = true;\r\n      await carvePassageBetweenAdjacentCoordinates({ x, y }, n, grid, setGrid);\r\n      await carvePassagesFrom(n.x, n.y, grid, setGrid, visited);\r\n    }\r\n  }\r\n};\r\n\r\nexport const RecursiveBacktracking = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n  const [n, m] = [grid.length, grid[0].length];\r\n  const visited: boolean[][] = Array.from(Array(n), () => Array(m).fill(false));\r\n  const { x, y } = randomOddCoordinates(n, m);\r\n  await carvePassagesFrom(x, y, grid, setGrid, visited);\r\n};\r\n","/* eslint-disable @typescript-eslint/no-use-before-define */\r\nimport React from 'react';\r\n\r\nimport { randomNumber, sleep } from '../../utils';\r\nimport { Cell } from '../model/Cell';\r\n\r\nconst addHWall = async (\r\n  grid: Cell[][],\r\n  minX: number,\r\n  maxX: number,\r\n  y: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const hole = Math.floor(randomNumber(minX, maxX) / 2) * 2 + 1;\r\n  for (let i = minX; i <= maxX; i++) {\r\n    if (i === hole) visited[y][i] = true;\r\n    else if (!visited[y][i] && !grid[y][i].isStart && !grid[y][i].isFinish)\r\n      grid[y][i].isWall = true;\r\n  }\r\n  setGrid([...grid]);\r\n  await sleep(1);\r\n};\r\n\r\nconst addVWall = async (\r\n  grid: Cell[][],\r\n  minY: number,\r\n  maxY: number,\r\n  x: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const hole = Math.floor(randomNumber(minY, maxY) / 2) * 2 + 1;\r\n  for (let i = minY; i <= maxY; i++) {\r\n    if (i === hole) visited[i][x] = true;\r\n    else if (!visited[i][x] && !grid[i][x].isStart && !grid[i][x].isFinish)\r\n      grid[i][x].isWall = true;\r\n  }\r\n  setGrid([...grid]);\r\n  await sleep(1);\r\n};\r\n\r\nconst addOuterWalls = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  // vertical walls\r\n  for (let i = 0; i < grid.length; i++) {\r\n    grid[i][0].isWall = true;\r\n    grid[i][grid[0].length - 1].isWall = true;\r\n  }\r\n  // horizontal walls\r\n  for (let i = 0; i < grid[0].length; i++) {\r\n    grid[0][i].isWall = true;\r\n    grid[grid.length - 1][i].isWall = true;\r\n  }\r\n  setGrid([...grid]);\r\n};\r\n\r\nconst divideHorizontally = async (\r\n  grid: Cell[][],\r\n  minX: number,\r\n  maxX: number,\r\n  minY: number,\r\n  maxY: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const y = Math.floor(randomNumber(minY, maxY) / 2) * 2;\r\n  await addHWall(grid, minX, maxX, y, setGrid, visited);\r\n  // upper chamber\r\n  await divide(grid, minX, maxX, minY, y - 1, setGrid, visited);\r\n  // lower chamber\r\n  await divide(grid, minX, maxX, y + 1, maxY, setGrid, visited);\r\n};\r\n\r\nconst divideVertically = async (\r\n  grid: Cell[][],\r\n  minX: number,\r\n  maxX: number,\r\n  minY: number,\r\n  maxY: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const x = Math.floor(randomNumber(minX, maxX) / 2) * 2;\r\n  await addVWall(grid, minY, maxY, x, setGrid, visited);\r\n  // left chamber\r\n  await divide(grid, minX, x - 1, minY, maxY, setGrid, visited);\r\n  // right chamber\r\n  await divide(grid, x + 1, maxX, minY, maxY, setGrid, visited);\r\n};\r\n\r\nconst divide = async (\r\n  grid: Cell[][],\r\n  minX: number,\r\n  maxX: number,\r\n  minY: number,\r\n  maxY: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  if (maxX - minX < 2 || maxY - minY < 2) return;\r\n  if (maxX - minX < maxY - minY) {\r\n    divideHorizontally(grid, minX, maxX, minY, maxY, setGrid, visited);\r\n  } else if (maxY - minY < maxX - minX) {\r\n    divideVertically(grid, minX, maxX, minY, maxY, setGrid, visited);\r\n  } else {\r\n    if (randomNumber(0, 1) === 0)\r\n      divideHorizontally(grid, minX, maxX, minY, maxY, setGrid, visited);\r\n    else divideVertically(grid, minX, maxX, minY, maxY, setGrid, visited);\r\n  }\r\n};\r\n\r\nexport const RecursiveDivision = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  const visited: boolean[][] = Array.from(Array(grid.length), () =>\r\n    Array(grid[0].length).fill(false)\r\n  );\r\n  await addOuterWalls(grid, setGrid);\r\n  await divide(\r\n    grid,\r\n    1,\r\n    grid[0].length - 2,\r\n    1,\r\n    grid.length - 2,\r\n    setGrid,\r\n    visited\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { Cell } from '../model/Cell';\r\nimport { BinaryTree } from './BinaryTree';\r\nimport { Eller } from './Eller';\r\nimport { Kruskal } from './Kruskal';\r\nimport { Prim } from './Prim';\r\nimport { RecursiveBacktracking } from './RecursiveBacktracking';\r\nimport { RecursiveDivision } from './RecursiveDivision';\r\n\r\ntype mazeFunc = (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n) => Promise<void>;\r\n\r\nexport const getMazeAlgorithm = (algorithmType: string): mazeFunc => {\r\n  if (algorithmType === 'division') return RecursiveDivision;\r\n  else if (algorithmType === 'backtracking') return RecursiveBacktracking;\r\n  else if (algorithmType === 'binary') return BinaryTree;\r\n  else if (algorithmType === 'prim') return Prim;\r\n  else if (algorithmType === 'kruskal') return Kruskal;\r\n  else if (algorithmType === 'eller') return Eller;\r\n  else throw new Error('Invalid argument for Maze Algorithm');\r\n};\r\n","import React from 'react';\r\n\r\nimport PriorityQueue from 'ts-priority-queue';\r\n\r\nimport { adjacentCoords, extractPath, isSameCoord, sleep } from '../../utils';\r\nimport { Cell, Coord } from '../model/Cell';\r\nimport { PQEntry, Result } from '../model/PQEntry';\r\n\r\n// _____Different tie breakers_____\r\n/**\r\n * Calulates the Manhattan distance between the given coordinates.\r\n * @param p the first coordinate.\r\n * @param q the second coordinate.\r\n * @returns the Manhattan distance between the two coordinates.\r\n */\r\nconst manhattanDistance = (p: Coord, q: Coord): number =>\r\n  Math.abs(p.x - q.x) + Math.abs(p.y - q.y);\r\n\r\n/**\r\n * Nudge the scale of [h] slightly so that the heuristic favours nodes closer to the goal.\r\n * - Inadmissible heuristic\r\n * From {@link https://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html}\r\n * @param p the current coordinate.\r\n * @param q the target coordinate.\r\n * @returns modified heuristic.\r\n */\r\nconst fudge = (p: Coord, q: Coord): number => {\r\n  const heuristic = manhattanDistance(p, q);\r\n  return heuristic * (1 + 1 / 1000);\r\n};\r\n\r\n/**\r\n * Heuristic that prefers a path that lies along the straight line from the start to the\r\n * goal\r\n * - Inadmissible heuristic\r\n * From {@link https://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html}\r\n * @param start starting coordinate.\r\n * @param p the current coordinate.\r\n * @param q the target coordinate.\r\n * @returns modified heuristic.\r\n */\r\nconst crossProduct = (start: Coord, p: Coord, q: Coord): number => {\r\n  const dx1 = p.x - q.x;\r\n  const dy1 = p.y - q.y;\r\n  const dx2 = start.x - q.x;\r\n  const dy2 = start.y - q.y;\r\n  const cross = Math.abs(dx1 * dy2 - dx2 * dy1);\r\n  const heuristic = manhattanDistance(p, q);\r\n  return heuristic + cross * 0.001;\r\n};\r\n\r\n// Delegate calculation of heuristic\r\nconst guessCost = (\r\n  start: Coord,\r\n  p: Coord,\r\n  q: Coord,\r\n  heuristic = 'manhattan'\r\n): number => {\r\n  if (heuristic === 'manhattan') return manhattanDistance(p, q);\r\n  else if (heuristic === 'fudge') return fudge(p, q);\r\n  else if (heuristic === 'cross') return crossProduct(start, p, q);\r\n  else throw new Error('Invalid heuristic type');\r\n};\r\n\r\n/**\r\n * A* search algorithm\r\n * @param start the starting coordinate.\r\n * @param goal the target coordinate.\r\n * @param grid the grid that has the state of every cell.\r\n * @param setGrid react hook to update the state of the grid.\r\n * @returns the path from start to goal if the algorithm successfully found the target.\r\n */\r\nexport const astar = async (\r\n  start: Coord,\r\n  goal: Coord,\r\n  grid: Cell[][],\r\n  setState: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  heuristic?: string\r\n): Promise<Result> => {\r\n  const [n, m] = [grid.length, grid[0].length];\r\n\r\n  // Auxiliary array keeping track of visited cells\r\n  const visited: boolean[][] = Array.from(Array(n), () => Array(m).fill(false));\r\n\r\n  const pq = new PriorityQueue<PQEntry>({\r\n    comparator: (p1, p2) => {\r\n      // bug: 'if (p1.guessCost)' will return false if p1.guessCost is 0\r\n      if (\r\n        typeof p1.guessCost !== 'undefined' &&\r\n        typeof p2.guessCost !== 'undefined'\r\n      )\r\n        return p1.costToHere + p1.guessCost - (p2.costToHere + p2.guessCost);\r\n      else throw new Error(\"Undefined field 'guessCost' in PQEntry\");\r\n    },\r\n  });\r\n\r\n  // Add starting cell to be searched\r\n  pq.queue({\r\n    coord: start,\r\n    costToHere: 0,\r\n    backPointer: null,\r\n    guessCost: guessCost(start, start, goal, heuristic),\r\n  });\r\n\r\n  while (pq.length !== 0) {\r\n    const entry = pq.dequeue();\r\n\r\n    if (isSameCoord(entry.coord, goal))\r\n      return { success: true, path: extractPath(entry) };\r\n\r\n    if (\r\n      !visited[entry.coord.y][entry.coord.x] &&\r\n      !grid[entry.coord.y][entry.coord.x].isWall\r\n    ) {\r\n      visited[entry.coord.y][entry.coord.x] = true;\r\n\r\n      // mark visited cells\r\n      grid[entry.coord.y][entry.coord.x].isActive = true;\r\n      setState([...grid]);\r\n      await sleep(1);\r\n\r\n      for (const c of adjacentCoords(entry.coord, n, m)) {\r\n        const costToNext = entry.costToHere + 1;\r\n        pq.queue({\r\n          coord: c,\r\n          costToHere: costToNext,\r\n          backPointer: entry,\r\n          guessCost: guessCost(start, c, goal, heuristic),\r\n        });\r\n      }\r\n    }\r\n  }\r\n  return { success: false, path: null };\r\n};\r\n","import React from 'react';\r\n\r\nimport PriorityQueue from 'ts-priority-queue';\r\n\r\nimport { adjacentCoords, extractPath, isSameCoord, sleep } from '../../utils';\r\nimport { Cell, Coord } from '../model/Cell';\r\nimport { PQEntry, Result } from '../model/PQEntry';\r\n\r\n/**\r\n * Uniform-Cost Search\r\n * @param start the starting coordinate.\r\n * @param goal the target coordinate.\r\n * @param grid the grid that has the state of every cell.\r\n * @param setGrid react hook to update the state of the grid.\r\n * @returns the path from start to goal if the algorithm successfully found the target.\r\n */\r\nexport const UCS = async (\r\n  start: Coord,\r\n  goal: Coord,\r\n  grid: Cell[][],\r\n  setState: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<Result> => {\r\n  const [n, m] = [grid.length, grid[0].length];\r\n\r\n  // Auxiliary array keeping track of visited cells\r\n  const visited: boolean[][] = Array.from(Array(n), () => Array(m).fill(false));\r\n\r\n  const pq = new PriorityQueue<PQEntry>({\r\n    comparator: (p1, p2) => p1.costToHere - p2.costToHere,\r\n  });\r\n\r\n  // Add starting cell to be searched\r\n  pq.queue({ coord: start, costToHere: 0, backPointer: null });\r\n\r\n  while (pq.length !== 0) {\r\n    const entry = pq.dequeue();\r\n\r\n    if (isSameCoord(entry.coord, goal))\r\n      return { success: true, path: extractPath(entry) };\r\n\r\n    if (\r\n      !visited[entry.coord.y][entry.coord.x] &&\r\n      !grid[entry.coord.y][entry.coord.x].isWall\r\n    ) {\r\n      visited[entry.coord.y][entry.coord.x] = true;\r\n\r\n      // mark visited cells\r\n      grid[entry.coord.y][entry.coord.x].isActive = true;\r\n      setState([...grid]);\r\n      await sleep(1);\r\n\r\n      for (const c of adjacentCoords(entry.coord, n, m)) {\r\n        const costToNext = entry.costToHere + 1;\r\n        pq.queue({ coord: c, costToHere: costToNext, backPointer: entry });\r\n      }\r\n    }\r\n  }\r\n  return { success: false, path: null };\r\n};\r\n","import { Cell, Coord } from '../model/Cell';\r\nimport { Result } from '../model/PQEntry';\r\nimport { astar } from './Astar';\r\nimport { UCS } from './UCS';\r\n\r\ntype pathfindingFunc = (\r\n  start: Coord,\r\n  finish: Coord,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  heuristic?: string\r\n) => Promise<Result>;\r\n\r\nexport const getPathfindingAlgorithm = (algorithm: string): pathfindingFunc => {\r\n  if (algorithm === 'ucs') return UCS;\r\n  else if (algorithm === 'astar') return astar;\r\n  else throw new Error('Incorrect type for pathfinding algorithm');\r\n};\r\n","import React from 'react';\r\n\r\nimport { ButtonGroup, ToggleButton } from 'react-bootstrap';\r\n\r\ninterface Algorithm {\r\n  name: string;\r\n  value: string;\r\n}\r\n\r\ninterface Props {\r\n  defaultAlgorithm: string;\r\n  algorithms: Algorithm[];\r\n  setAlgorithm: React.Dispatch<React.SetStateAction<string>>;\r\n}\r\n\r\nexport const AlgorithmButtonGroup: React.FC<Props> = ({\r\n  defaultAlgorithm,\r\n  algorithms,\r\n  setAlgorithm,\r\n}: Props) => {\r\n  return (\r\n    <ButtonGroup className=\"p-1\">\r\n      {algorithms.map((alg) => (\r\n        <ToggleButton\r\n          key={alg.value}\r\n          type=\"radio\"\r\n          variant=\"outline-warning\"\r\n          value={alg.value}\r\n          checked={defaultAlgorithm === alg.value}\r\n          onChange={(e) => setAlgorithm(e.currentTarget.value)}\r\n        >\r\n          {alg.name}\r\n        </ToggleButton>\r\n      ))}\r\n    </ButtonGroup>\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { Button } from 'react-bootstrap';\r\n\r\nimport { Cell } from '../../core/model/Cell';\r\nimport './CellButton.css';\r\n\r\ninterface Props {\r\n  cell: Cell;\r\n  mouseDown: boolean;\r\n  onMouseDown: (row: number, col: number) => void;\r\n  onMouseEnter: (row: number, col: number) => void;\r\n  onMouseUp: () => void;\r\n}\r\n\r\nconst cellColor = (cell: Cell): string => {\r\n  if (cell.isWall) return 'grey';\r\n  else if (cell.isStart) return 'yellow';\r\n  else if (cell.isFinish) return 'blue';\r\n  else if (cell.isPath) return 'Chartreuse';\r\n  // or tomato for brighter\r\n  else if (cell.isActive) return 'crimson';\r\n  else return 'azure';\r\n};\r\n\r\nconst cssAnimation = (cell: Cell): string => {\r\n  return cell.isPath ? 'finish' : cell.isActive ? 'visited' : '';\r\n};\r\n\r\nexport const CellButton: React.FC<Props> = ({\r\n  cell,\r\n  mouseDown,\r\n  onMouseDown,\r\n  onMouseEnter,\r\n  onMouseUp,\r\n}: Props) => {\r\n  return (\r\n    <Button\r\n      className={`cell ${cssAnimation(cell)}`}\r\n      style={{\r\n        backgroundColor: cellColor(cell),\r\n      }}\r\n      onMouseEnter={() => {\r\n        if (mouseDown) onMouseEnter(cell.coord.y, cell.coord.x);\r\n      }}\r\n      onMouseDown={() => onMouseDown(cell.coord.y, cell.coord.x)}\r\n      onMouseUp={onMouseUp}\r\n    />\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { Cell, Coord } from '../../core/model/Cell';\r\nimport { CellButton } from './CellButton';\r\n\r\ninterface Props {\r\n  grid: Cell[][];\r\n  mode: string;\r\n  setMode: React.Dispatch<React.SetStateAction<string>>;\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>;\r\n  start: Coord;\r\n  setStart: React.Dispatch<React.SetStateAction<Coord>>;\r\n  finish: Coord;\r\n  setFinish: React.Dispatch<React.SetStateAction<Coord>>;\r\n  searching: boolean;\r\n}\r\n\r\nexport const Grid: React.FC<Props> = ({\r\n  grid,\r\n  mode,\r\n  setMode,\r\n  setGrid,\r\n  start,\r\n  setStart,\r\n  finish,\r\n  setFinish,\r\n  searching,\r\n}: Props) => {\r\n  const [mouseDown, setMouseDown] = React.useState<boolean>(false);\r\n\r\n  const toggleWall = (row: number, col: number): void => {\r\n    const cell = grid[row][col];\r\n    if (!cell.isStart && !cell.isFinish) {\r\n      cell.isWall = !cell.isWall;\r\n      setGrid([...grid]);\r\n    }\r\n  };\r\n\r\n  const moveStart = (row: number, col: number): void => {\r\n    grid[start.y][start.x].isStart = false;\r\n    const cell: Cell = grid[row][col];\r\n    cell.isStart = true;\r\n    setStart(cell.coord);\r\n    setGrid([...grid]);\r\n  };\r\n\r\n  const moveFinish = (row: number, col: number): void => {\r\n    grid[finish.y][finish.x].isFinish = false;\r\n    const cell = grid[row][col];\r\n    cell.isFinish = true;\r\n    setFinish(cell.coord);\r\n    setGrid([...grid]);\r\n  };\r\n\r\n  const handleMouseUp = (): void => setMouseDown(false);\r\n\r\n  const handleMouseDown = (row: number, col: number): void => {\r\n    if (grid[row][col].isStart) setMode('start');\r\n    else if (grid[row][col].isFinish) setMode('finish');\r\n    else {\r\n      setMode('wall');\r\n      toggleWall(row, col);\r\n    }\r\n    setMouseDown(true);\r\n  };\r\n\r\n  const handleMouseEnter = (row: number, col: number): void => {\r\n    if (mouseDown) {\r\n      if (mode === 'wall') toggleWall(row, col);\r\n      else if (mode === 'start' && !searching) moveStart(row, col);\r\n      else if (mode === 'finish' && !searching) moveFinish(row, col);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      {/* 🐰 🥚 */}\r\n      <button\r\n        style={{\r\n          background: 'transparent',\r\n          border: 'none',\r\n          outline: 'none',\r\n          display: 'block',\r\n          height: '5px',\r\n          width: '5px',\r\n          cursor: 'pointer',\r\n          marginBottom: '5px',\r\n        }}\r\n        onClick={() => {\r\n          for (let i = 0; i < grid.length; i++) {\r\n            grid[i][0].isWall = true;\r\n            grid[i][grid[0].length - 1].isWall = true;\r\n          }\r\n          // horizontal walls\r\n          for (let i = 0; i < grid[0].length; i++) {\r\n            grid[0][i].isWall = true;\r\n            grid[grid.length - 1][i].isWall = true;\r\n          }\r\n          for (let i = 0; i < grid.length - 1; i++) {\r\n            for (let j = 0; j < grid[0].length - 1; j++) {\r\n              if (i % 2 === 0 && j % 2 === 0) grid[i][j].isWall = true;\r\n            }\r\n          }\r\n          setGrid([...grid]);\r\n        }}\r\n      />\r\n      <div\r\n        onMouseDown={() => {\r\n          setMouseDown(true);\r\n        }}\r\n        onMouseUp={() => {\r\n          setMouseDown(false);\r\n        }}\r\n        onMouseLeave={() => {\r\n          setMouseDown(false);\r\n        }}\r\n      >\r\n        {grid.map((row, i) => (\r\n          <div key={i}>\r\n            {row.map((c, j) => (\r\n              <CellButton\r\n                cell={c}\r\n                key={j}\r\n                mouseDown={mouseDown}\r\n                onMouseDown={handleMouseDown}\r\n                onMouseEnter={handleMouseEnter}\r\n                onMouseUp={handleMouseUp}\r\n              />\r\n            ))}\r\n          </div>\r\n        ))}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { Popover } from 'react-bootstrap';\r\n\r\n/**\r\n * Basic popover explaining the different ways to calculate heuristic for A*\r\n */\r\nexport const popover = (\r\n  <Popover id=\"popover-basic\">\r\n    <Popover.Title as=\"h3\">A* Heuristic</Popover.Title>\r\n    <Popover.Content>\r\n      Different methods of calculating the heuristic in A*\r\n      <ul>\r\n        <li>\r\n          <strong>Manhattan distance</strong>:\r\n          <ul>\r\n            <li>Guarantees shortest path.</li>\r\n            <li>Trading speed for accuracy.</li>\r\n          </ul>\r\n        </li>\r\n        <li>\r\n          <strong>Fudge</strong>:\r\n          <ul>\r\n            <li>\r\n              Similar to A* except that the heuristic favours nodes closer to\r\n              the target.\r\n            </li>\r\n            <li>Finds a more direct route.</li>\r\n            <li>Inadmissible heuristic.</li>\r\n          </ul>\r\n        </li>\r\n        <li>\r\n          <strong>Cross</strong>:\r\n          <ul>\r\n            <li>\r\n              Prefers path that are along the straight line from the starting\r\n              point to the target.\r\n            </li>\r\n            <li>Nicer diagonal paths.</li>\r\n            <li>Inadmissible heuristic.</li>\r\n          </ul>\r\n        </li>\r\n      </ul>\r\n    </Popover.Content>\r\n  </Popover>\r\n);\r\n","import React from 'react';\r\n\r\nimport {\r\n  Button,\r\n  Dropdown,\r\n  DropdownButton,\r\n  OverlayTrigger,\r\n  SplitButton,\r\n} from 'react-bootstrap';\r\n\r\nimport { popover } from './Popover';\r\n\r\ninterface NameValue {\r\n  name: string;\r\n  value: string;\r\n}\r\n\r\ninterface Props {\r\n  algorithm: string;\r\n  AlgorithmButtonGroup: React.ReactNode;\r\n  heuristic: string;\r\n  heuristics: NameValue[];\r\n  setHeuristic: React.Dispatch<React.SetStateAction<string>>;\r\n  resetGrid: () => void;\r\n  removePath: () => void;\r\n  search: () => Promise<void>;\r\n  mazes: NameValue[];\r\n  generateMaze: (algorithmType: string) => Promise<void>;\r\n}\r\n\r\nexport const Panel: React.FC<Props> = ({\r\n  algorithm,\r\n  AlgorithmButtonGroup,\r\n  heuristic,\r\n  heuristics,\r\n  setHeuristic,\r\n  resetGrid,\r\n  removePath,\r\n  search,\r\n  mazes,\r\n  generateMaze,\r\n}: Props) => {\r\n  return (\r\n    <div\r\n      style={{\r\n        display: 'flex',\r\n        justifyContent: 'center',\r\n        alignItems: 'center',\r\n      }}\r\n    >\r\n      <DropdownButton variant=\"success\" title=\"Mazes\" menuAlign=\"left\">\r\n        {mazes.map((m, i) => (\r\n          <Dropdown.Item\r\n            as=\"button\"\r\n            key={i}\r\n            onClick={() => generateMaze(m.value)}\r\n          >\r\n            {m.name}\r\n          </Dropdown.Item>\r\n        ))}\r\n      </DropdownButton>\r\n      <SplitButton\r\n        id=\"reset\"\r\n        className=\"m-2\"\r\n        variant=\"danger\"\r\n        title={'Reset'}\r\n        toggleLabel=\"\"\r\n        onClick={resetGrid}\r\n      >\r\n        <Dropdown.Item onClick={removePath}>Clear path</Dropdown.Item>\r\n      </SplitButton>\r\n      <Button onClick={search} variant=\"primary\" className=\"m-1\">\r\n        Search!\r\n      </Button>\r\n      {AlgorithmButtonGroup}\r\n      <OverlayTrigger placement=\"right\" overlay={popover}>\r\n        <DropdownButton\r\n          alignRight={true}\r\n          className=\"m-1\"\r\n          variant=\"secondary\"\r\n          title={heuristic.charAt(0).toUpperCase() + heuristic.slice(1)}\r\n          disabled={algorithm !== 'astar'}\r\n        >\r\n          {heuristics.map((h) => (\r\n            <Dropdown.Item\r\n              as=\"button\"\r\n              key={h.value}\r\n              onClick={() => setHeuristic(h.value)}\r\n            >\r\n              {h.name}\r\n            </Dropdown.Item>\r\n          ))}\r\n        </DropdownButton>\r\n      </OverlayTrigger>\r\n    </div>\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { Col, Container, Row } from 'react-bootstrap';\r\n\r\nimport { getMazeAlgorithm } from '../../core/maze/MazeFactory';\r\nimport { Cell, Coord } from '../../core/model/Cell';\r\nimport { Result } from '../../core/model/PQEntry';\r\nimport { getPathfindingAlgorithm } from '../../core/pathfinding/PathfindingFactory';\r\nimport { closestOddCoord, sleep } from '../../utils';\r\nimport { AlgorithmButtonGroup } from '../common/AlgorithmButtonGroup';\r\nimport { Grid } from './Grid';\r\nimport { Panel } from './Panel';\r\n\r\nconst algorithms = [\r\n  { name: 'UCS', value: 'ucs' },\r\n  { name: 'A*', value: 'astar' },\r\n];\r\nconst mazes = [\r\n  { name: 'Recursive Division', value: 'division' },\r\n  { name: 'Recursive Backtracking', value: 'backtracking' },\r\n  { name: 'Binary Tree (Southeast bias)', value: 'binary' },\r\n  { name: \"Prim's Algorithm\", value: 'prim' },\r\n  { name: \"Kruskal's Algorithm\", value: 'kruskal' },\r\n  { name: \"Eller's Algorithm\", value: 'eller' },\r\n];\r\nconst heuristics = [\r\n  { name: 'Manhattan distance', value: 'manhattan' },\r\n  { name: 'Fudge', value: 'fudge' },\r\n  { name: 'Cross', value: 'cross' },\r\n];\r\n\r\n// Calculate how many cells fit the screen horizontally and vertically\r\nconst calculateCells = (): [number, number] => {\r\n  const noHorizontalCells = Math.floor(window.innerWidth / 30);\r\n  const noVerticalCells = Math.floor((window.innerHeight - 160) / 30);\r\n  // maze algorithm requires maze to have odd size\r\n  return [\r\n    noHorizontalCells % 2 === 0 ? noHorizontalCells - 1 : noHorizontalCells,\r\n    noVerticalCells % 2 === 0 ? noVerticalCells - 1 : noVerticalCells,\r\n  ];\r\n};\r\n\r\nconst newGrid = (start: Coord, finish: Coord): Cell[][] => {\r\n  const [n, m] = calculateCells();\r\n  const grid: Cell[][] = [...Array(m)].map((_, i) => {\r\n    return [...Array(n)].map((_, j) => ({\r\n      coord: { x: j, y: i },\r\n      isActive: false,\r\n      isPath: false,\r\n      isStart: false,\r\n      isFinish: false,\r\n      isWall: false,\r\n    }));\r\n  });\r\n  grid[start.y][start.x].isStart = true;\r\n  grid[finish.y][finish.x].isFinish = true;\r\n  return grid;\r\n};\r\n\r\nconst removePath = (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): void => {\r\n  for (let row = 0; row < grid.length; row++)\r\n    for (let col = 0; col < grid[0].length; col++) {\r\n      const cell = grid[row][col];\r\n      if (cell.isPath) cell.isPath = false;\r\n      if (cell.isActive) cell.isActive = false;\r\n    }\r\n  setGrid([...grid]);\r\n};\r\n\r\n// Draw the path received from pathfinding algorithm\r\nconst drawPath = async (\r\n  res: Result,\r\n  grid: Cell[][],\r\n  setState: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  if (res.path) {\r\n    for (const c of res.path) {\r\n      grid[c.y][c.x].isPath = true;\r\n      setState([...grid]);\r\n      await sleep(1);\r\n    }\r\n  }\r\n};\r\n\r\nexport const PathfindingVisualizer: React.FC = () => {\r\n  const [algorithm, setAlgorithm] = React.useState<string>('astar');\r\n  // to disable moving starting and finish cells during search\r\n  const [searching, setSearching] = React.useState<boolean>(false);\r\n  const [start, setStart] = React.useState<Coord>({ x: 1, y: 3 });\r\n  const [finish, setFinish] = React.useState<Coord>({ x: 7, y: 3 });\r\n  const [grid, setGrid] = React.useState<Cell[][]>(newGrid(start, finish));\r\n  const [mode, setMode] = React.useState<string>('wall');\r\n  const [heuristic, setHeuristic] = React.useState<string>('manhattan');\r\n\r\n  const search = async (): Promise<void> => {\r\n    const searcher = getPathfindingAlgorithm(algorithm);\r\n    setSearching(true);\r\n    await searcher(start, finish, grid, setGrid, heuristic).then(\r\n      async (res) => {\r\n        if (res.success) await drawPath(res, grid, setGrid);\r\n      }\r\n    );\r\n    setSearching(false);\r\n  };\r\n\r\n  // Move start and finish to odd coordinates (if they aren't already on odd coordinates)\r\n  const relocateStartAndFinishToOddCoords = (): void => {\r\n    grid[start.y][start.x].isStart = false;\r\n    grid[finish.y][finish.x].isFinish = false;\r\n    const newStart = closestOddCoord(start);\r\n    const newFinish = closestOddCoord(finish);\r\n    grid[newStart.y][newStart.x].isStart = true;\r\n    grid[newFinish.y][newFinish.x].isFinish = true;\r\n    setGrid([...grid]);\r\n    setStart(newStart);\r\n    setFinish(newFinish);\r\n  };\r\n\r\n  const generateMaze = async (algorithmType: string): Promise<void> => {\r\n    relocateStartAndFinishToOddCoords();\r\n    const mazeGenerator = getMazeAlgorithm(algorithmType);\r\n    await mazeGenerator(grid, setGrid);\r\n  };\r\n\r\n  return (\r\n    <Container fluid={true} style={{ padding: '0' }}>\r\n      <Row>\r\n        <Col\r\n          style={{\r\n            display: 'flex',\r\n            justifyContent: 'center',\r\n            alignItems: 'center',\r\n          }}\r\n        >\r\n          <Panel\r\n            AlgorithmButtonGroup={\r\n              <AlgorithmButtonGroup\r\n                defaultAlgorithm={algorithm}\r\n                algorithms={algorithms}\r\n                setAlgorithm={setAlgorithm}\r\n              />\r\n            }\r\n            algorithm={algorithm}\r\n            heuristic={heuristic}\r\n            heuristics={heuristics}\r\n            setHeuristic={setHeuristic}\r\n            resetGrid={() => setGrid(newGrid(start, finish))}\r\n            removePath={() => removePath(grid, setGrid)}\r\n            search={search}\r\n            mazes={mazes}\r\n            generateMaze={generateMaze}\r\n          />\r\n        </Col>\r\n      </Row>\r\n      <Row className=\"justify-content-center\">\r\n        <Col md=\"auto\">\r\n          <Grid\r\n            grid={grid}\r\n            mode={mode}\r\n            setMode={setMode}\r\n            setGrid={setGrid}\r\n            start={start}\r\n            setStart={setStart}\r\n            finish={finish}\r\n            setFinish={setFinish}\r\n            searching={searching}\r\n          />\r\n        </Col>\r\n      </Row>\r\n    </Container>\r\n  );\r\n};\r\n","export type Color = '#FF0000' | '#0000FF' | '#7CFC00';\r\nexport const RED: Color = '#FF0000';\r\nexport const BLUE: Color = '#0000FF';\r\nexport const GREEN: Color = '#7CFC00';\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN, BLUE } from '../model/Color';\r\n\r\nconst animation = async (\r\n  bars: Bar[],\r\n  j: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  bars[j].color = RED;\r\n  bars[j + 1].color = GREEN;\r\n  setState([...bars]);\r\n  await sleep(delay);\r\n  bars[j].color = BLUE;\r\n  bars[j + 1].color = BLUE;\r\n};\r\n\r\nexport const bubbleSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  const n: number = bars.length;\r\n  let greatestElementIndex: number = bars.length;\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    for (let j = 0; j < n - 1; j++) {\r\n      if (bars[j].num > bars[j + 1].num) {\r\n        swap(bars, j, j + 1);\r\n        await animation(bars, j, setState, delay);\r\n      }\r\n\r\n      if (j === greatestElementIndex - 2) {\r\n        // make the iteration's greatest element green (sorted partition)\r\n        greatestElementIndex--;\r\n        bars[greatestElementIndex].color = RED;\r\n        setState([...bars]);\r\n      }\r\n    }\r\n  }\r\n};\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN, BLUE } from '../model/Color';\r\n\r\nexport const cocktailSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  let swapped = true;\r\n  let start = 0;\r\n  let end = bars.length;\r\n\r\n  while (swapped) {\r\n    swapped = false;\r\n\r\n    // bottom to top\r\n    for (let i = start; i < end - 1; i++) {\r\n      if (bars[i].num > bars[i + 1].num) {\r\n        swap(bars, i, i + 1);\r\n        swapped = true;\r\n      }\r\n      bars[i].color = BLUE;\r\n      bars[i + 1].color = GREEN;\r\n      setState([...bars]);\r\n      await sleep(delay);\r\n    }\r\n\r\n    // mark this iterations greatest element\r\n    bars[end - 1].color = RED;\r\n    setState([...bars]);\r\n\r\n    // exit if sorted\r\n    if (!swapped) break;\r\n\r\n    swapped = false;\r\n    end--;\r\n\r\n    // top to bottom\r\n    for (let i = end - 1; i >= start; i--) {\r\n      if (bars[i].num > bars[i + 1].num) {\r\n        swap(bars, i, i + 1);\r\n        swapped = true;\r\n      }\r\n      if (i !== end - 1) bars[i + 1].color = BLUE;\r\n      bars[i].color = GREEN;\r\n      setState([...bars]);\r\n      await sleep(delay);\r\n    }\r\n    // mark this iterations smallest element\r\n    bars[start].color = RED;\r\n    setState([...bars]);\r\n\r\n    start++;\r\n  }\r\n};\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, BLUE } from '../model/Color';\r\n\r\nconst animation = async (\r\n  bars: Bar[],\r\n  x: number,\r\n  y: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  bars[x].color = RED;\r\n  bars[y].color = RED;\r\n  setState([...bars]);\r\n  await sleep(delay);\r\n  bars[x].color = BLUE;\r\n  bars[y].color = BLUE;\r\n  setState([...bars]);\r\n};\r\n\r\nconst heapify = async (\r\n  bars: Bar[],\r\n  n: number,\r\n  i: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  let largest = i;\r\n  const left = 2 * i + 1;\r\n  const right = 2 * i + 2;\r\n\r\n  if (left < n && bars[left].num > bars[largest].num) largest = left;\r\n\r\n  if (right < n && bars[right].num > bars[largest].num) largest = right;\r\n\r\n  if (largest !== i) {\r\n    swap(bars, i, largest);\r\n    await animation(bars, i, largest, setState, delay);\r\n    // recursively heapify sub-tree\r\n    await heapify(bars, n, largest, setState, delay);\r\n  }\r\n};\r\n\r\nexport const heapSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  const n = bars.length;\r\n\r\n  // build max-heap\r\n  for (let i = Math.floor(n / 2 - 1); i >= 0; i--) {\r\n    await heapify(bars, n, i, setState, delay);\r\n  }\r\n\r\n  for (let i = n - 1; i > 0; i--) {\r\n    // Move root to the end\r\n    swap(bars, 0, i, setState);\r\n\r\n    // mark sorted partition\r\n    bars[i].color = RED;\r\n\r\n    // heapify reduced heap\r\n    await heapify(bars, i, 0, setState, delay);\r\n  }\r\n};\r\n","import React, { SetStateAction } from 'react';\r\n\r\nimport { sleep } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN } from '../model/Color';\r\n\r\nexport const insertionSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  const n: number = bars.length;\r\n\r\n  bars[0].color = RED;\r\n\r\n  for (let i = 1; i < n; i++) {\r\n    const value: Bar = bars[i];\r\n    let hole: number = i;\r\n\r\n    bars[hole].color = RED;\r\n\r\n    while (hole > 0 && bars[hole - 1].num > value.num) {\r\n      await sleep(delay);\r\n      bars[hole] = bars[hole - 1];\r\n\r\n      bars[hole].color = GREEN;\r\n      if (hole + 1 < bars.length) bars[hole + 1].color = RED;\r\n\r\n      setState([...bars]);\r\n      hole--;\r\n    }\r\n\r\n    bars[hole].color = RED;\r\n\r\n    bars[hole] = value;\r\n    setState([...bars]);\r\n  }\r\n};\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, BLUE } from '../model/Color';\r\n\r\nconst nextGap = (gap: number): number => (gap <= 1 ? 0 : Math.ceil(gap / 2.0));\r\n\r\nconst animation = async (\r\n  bars: Bar[],\r\n  x: number,\r\n  y: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  bars[x].color = RED;\r\n  bars[y].color = RED;\r\n\r\n  setState([...bars]);\r\n  await sleep(delay);\r\n\r\n  bars[x].color = BLUE;\r\n  bars[y].color = BLUE;\r\n};\r\n\r\n/**\r\n * In-place Merge Sort\r\n *\r\n * Approach 2 from {@link https://www.geeksforgeeks.org/in-place-merge-sort/}.\r\n *\r\n * @param bars The array to be sorted.\r\n * @param start The left index of the array.\r\n * @param end The right index of the array.\r\n * @param setState Hook for changing the state.\r\n * @param delay Time in between each animation.\r\n */\r\nconst inPlaceMerge = async (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  let gap: number = end - start + 1;\r\n\r\n  for (gap = nextGap(gap); gap > 0; gap = nextGap(gap)) {\r\n    for (let i = start; i + gap <= end; i++) {\r\n      const j = i + gap;\r\n      if (bars[i].num > bars[j].num) {\r\n        swap(bars, i, j);\r\n        await animation(bars, i, j, setState, delay);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nconst _sort = async (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  if (start === end) return;\r\n\r\n  const mid = Math.floor((start + end) / 2);\r\n  await _sort(bars, start, mid, setState, delay);\r\n  await _sort(bars, mid + 1, end, setState, delay);\r\n\r\n  await inPlaceMerge(bars, start, end, setState, delay);\r\n};\r\n\r\nexport const mergeSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  await _sort(bars, 0, bars.length - 1, setState, delay);\r\n};\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN, BLUE } from '../model/Color';\r\n\r\nconst animation = async (\r\n  bars: Bar[],\r\n  i: number,\r\n  partitionIndex: number,\r\n  start: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  bars[i].color = GREEN;\r\n  bars[partitionIndex].color = RED;\r\n  setState([...bars]);\r\n  await sleep(delay);\r\n  if (i !== start) {\r\n    // only reset indices after start\r\n    bars[i].color = BLUE;\r\n    bars[partitionIndex].color = BLUE;\r\n  }\r\n};\r\n\r\n/**\r\n * Median of three\r\n *\r\n * Puts the median at the last index of the array and returns the pivot value\r\n *\r\n * @param bars The array to be sorted.\r\n * @param start The left index of the array.\r\n * @param end The right index of the array.\r\n * @returns The pivot value.\r\n */\r\nconst getMedian = (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>\r\n): number => {\r\n  const midpoint: number = Math.floor((start + end) / 2);\r\n  if (bars[start].num > bars[midpoint].num) swap(bars, start, midpoint);\r\n  if (bars[start] > bars[end]) swap(bars, start, end);\r\n  if (bars[midpoint] > bars[end]) swap(bars, midpoint, end);\r\n\r\n  swap(bars, midpoint, end, setState);\r\n  return bars[end].num;\r\n};\r\n\r\nconst partition = async (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<number> => {\r\n  const pivotIndex: number = end;\r\n  const pivot = getMedian(bars, start, end, setState);\r\n  let partitionIndex = start;\r\n\r\n  // Mark pivot\r\n  bars[pivotIndex].color = RED;\r\n  setState([...bars]);\r\n\r\n  for (let i = start; i < end; i++) {\r\n    if (bars[i].num <= pivot) {\r\n      swap(bars, i, partitionIndex, setState);\r\n\r\n      await animation(bars, i, partitionIndex, start, setState, delay);\r\n\r\n      partitionIndex++;\r\n    }\r\n  }\r\n\r\n  // Unmark pivot and starting pointer\r\n  bars[start].color = BLUE;\r\n  bars[pivotIndex].color = BLUE;\r\n  setState([...bars]);\r\n\r\n  swap(bars, partitionIndex, pivotIndex, setState);\r\n  return partitionIndex;\r\n};\r\n\r\nconst _sort = async (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  if (start < end) {\r\n    const partitionIndex: number = await partition(\r\n      bars,\r\n      start,\r\n      end,\r\n      setState,\r\n      delay\r\n    );\r\n    await _sort(bars, start, partitionIndex - 1, setState, delay);\r\n    await _sort(bars, partitionIndex + 1, end, setState, delay);\r\n  }\r\n};\r\n\r\nexport const quicksort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  await _sort(bars, 0, bars.length - 1, setState, delay);\r\n};\r\n","import React, { SetStateAction } from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN, BLUE } from '../model/Color';\r\n\r\nexport const selectionSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  const n: number = bars.length;\r\n  for (let i = 0; i < n - 1; i++) {\r\n    let iMin: number = i;\r\n    for (let j: number = i + 1; j < n; j++) {\r\n      if (bars[j].num < bars[iMin].num) iMin = j;\r\n\r\n      if (j === n - 1) {\r\n        // Mark the smallest element in the unsorted array\r\n        bars[iMin].color = GREEN;\r\n        setState([...bars]);\r\n      }\r\n    }\r\n\r\n    swap(bars, i, iMin);\r\n\r\n    await sleep(delay);\r\n    bars[iMin].color = BLUE; // Unmark\r\n    bars[i].color = RED;\r\n    setState([...bars]);\r\n  }\r\n\r\n  // manually make last element red cause yeah\r\n  bars[bars.length - 1].color = RED;\r\n  setState([...bars]);\r\n};\r\n","import { Bar } from '../model/Bar';\r\nimport { bubbleSort } from './BubbleSort';\r\nimport { cocktailSort } from './CocktailSort';\r\nimport { heapSort } from './HeapSort';\r\nimport { insertionSort } from './InsertionSort';\r\nimport { mergeSort } from './MergeSort';\r\nimport { quicksort } from './QuickSort';\r\nimport { selectionSort } from './SelectionSort';\r\n\r\ntype sortingFunc = (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n) => Promise<void>;\r\n\r\nexport const getSortingAlgorithm = (algorithm: string): sortingFunc => {\r\n  if (algorithm === 'selection') return selectionSort;\r\n  else if (algorithm === 'insertion') return insertionSort;\r\n  else if (algorithm === 'bubble') return bubbleSort;\r\n  else if (algorithm === 'quick') return quicksort;\r\n  else if (algorithm === 'merge') return mergeSort;\r\n  else if (algorithm === 'cocktail') return cocktailSort;\r\n  else if (algorithm === 'heap') return heapSort;\r\n  else throw new Error('Incorrect type for sorting algorithm');\r\n};\r\n","import React, { SetStateAction } from 'react';\r\n\r\nimport { Button } from 'react-bootstrap';\r\n\r\nimport { Bar } from '../../core/model/Bar';\r\n\r\ninterface Props {\r\n  num: number;\r\n  handleNumberChange: (e: React.ChangeEvent<HTMLInputElement>) => void;\r\n  sort: () => Promise<void>;\r\n  reset: () => void;\r\n  setBars: React.Dispatch<SetStateAction<Bar[]>>;\r\n  delay: number;\r\n  setDelay: React.Dispatch<SetStateAction<number>>;\r\n}\r\n\r\nexport const Panel: React.FC<Props> = ({\r\n  num,\r\n  handleNumberChange,\r\n  sort,\r\n  reset,\r\n  delay,\r\n  setDelay,\r\n}: Props) => {\r\n  const renderRangeSlider = (): JSX.Element => (\r\n    <label className=\"mx-2\" style={{ width: '10%', textAlign: 'left' }}>\r\n      Delay\r\n      <input\r\n        name=\"foo\"\r\n        type=\"range\"\r\n        min=\"1\"\r\n        max=\"100\"\r\n        value={delay}\r\n        className=\"slider\"\r\n        onChange={(e) => setDelay(parseInt(e.target.value))}\r\n      />\r\n    </label>\r\n  );\r\n\r\n  return (\r\n    <span>\r\n      {renderRangeSlider()}\r\n      <input\r\n        className=\"input-number\"\r\n        name=\"no. bars\"\r\n        type=\"number\"\r\n        value={num}\r\n        step={5}\r\n        min=\"5\"\r\n        max=\"150\"\r\n        onChange={handleNumberChange}\r\n        onKeyDown={(e) => e.preventDefault()}\r\n      />\r\n      <Button onClick={reset} className=\"mx-2\" variant=\"danger\">\r\n        Reset\r\n      </Button>\r\n      <Button onClick={sort}>Sort</Button>\r\n    </span>\r\n  );\r\n};\r\n","import React, { useState, useEffect } from 'react';\r\n\r\nimport './SortingVisualizer.css';\r\nimport { Col, Container, Row } from 'react-bootstrap';\r\n\r\nimport { Bar } from '../../core/model/Bar';\r\nimport { BLUE, GREEN } from '../../core/model/Color';\r\nimport { getSortingAlgorithm } from '../../core/sorting/SortingFactory';\r\nimport { sleep } from '../../utils';\r\nimport { AlgorithmButtonGroup } from '../common/AlgorithmButtonGroup';\r\nimport { Panel } from './Panel';\r\n\r\nconst algorithms = [\r\n  { name: 'Insertion Sort', value: 'insertion' },\r\n  { name: 'Selection Sort', value: 'selection' },\r\n  { name: 'Bubble Sort', value: 'bubble' },\r\n  { name: 'Quicksort', value: 'quick' },\r\n  { name: 'Merge Sort', value: 'merge' },\r\n  { name: 'Cocktail Sort', value: 'cocktail' },\r\n  { name: 'Heap Sort', value: 'heap' },\r\n];\r\n\r\nexport const SortingVisualizer: React.FC = () => {\r\n  const [bars, setBars] = useState<Bar[]>([]);\r\n  const [num, setNum] = useState<number>(90);\r\n  const [algorithm, setAlgorithm] = useState<string>('insertion');\r\n  const [delay, setDelay] = useState<number>(1);\r\n\r\n  const resetBars = (): void =>\r\n    setBars(\r\n      [...Array(num)].map(() => ({\r\n        num: Math.floor(Math.random() * 80) + 1,\r\n        color: BLUE,\r\n      }))\r\n    );\r\n\r\n  useEffect((): void => {\r\n    resetBars();\r\n  }, [num]); // eslint-disable-line react-hooks/exhaustive-deps\r\n\r\n  // Green progressive animation\r\n  const finish = async (\r\n    bars: Bar[],\r\n    setState: React.Dispatch<React.SetStateAction<Bar[]>>\r\n  ): Promise<void> => {\r\n    for (let i = 0; i < bars.length; i++) {\r\n      bars[i].color = GREEN;\r\n      setState([...bars]);\r\n      await sleep(1);\r\n    }\r\n  };\r\n\r\n  const sort = async (): Promise<void> => {\r\n    const sorter = getSortingAlgorithm(algorithm);\r\n    await sorter(bars, setBars, delay);\r\n    await finish(bars, setBars);\r\n  };\r\n\r\n  const handleNumberChange = (e: React.ChangeEvent<HTMLInputElement>): void => {\r\n    const { value, min, max } = e.target;\r\n    setNum(Math.max(Number(min), Math.min(Number(max), Number(value))));\r\n  };\r\n\r\n  const renderBars = (): JSX.Element => (\r\n    <div className=\"sorting-container\">\r\n      {bars.map((bar: Bar, idx) => (\r\n        <div\r\n          key={`b-${idx}`}\r\n          className=\"bar\"\r\n          style={{\r\n            backgroundColor: `${bar.color}`,\r\n            width: '1vw',\r\n            height: `${bar.num}vmin`,\r\n          }}\r\n        />\r\n      ))}\r\n    </div>\r\n  );\r\n\r\n  return (\r\n    <Container fluid={true} style={{ padding: '0' }}>\r\n      <Row className=\"app-vanish text-center justify-content-center\">\r\n        <Col md=\"auto\">\r\n          <Panel\r\n            num={num}\r\n            handleNumberChange={handleNumberChange}\r\n            reset={resetBars}\r\n            setBars={setBars}\r\n            sort={sort}\r\n            delay={delay}\r\n            setDelay={setDelay}\r\n          />\r\n          <AlgorithmButtonGroup\r\n            defaultAlgorithm={algorithm}\r\n            algorithms={algorithms}\r\n            setAlgorithm={setAlgorithm}\r\n          />\r\n        </Col>\r\n      </Row>\r\n      <Row className=\"justify-content-center\">\r\n        <Col md=\"auto\">{renderBars()}</Col>\r\n      </Row>\r\n    </Container>\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport './App.css';\r\nimport { HashRouter as Router, Switch, Route } from 'react-router-dom';\r\n\r\nimport { Header } from './components/common/Header';\r\nimport { PathfindingVisualizer } from './components/pathfinding/PathfindingVisualizer';\r\nimport { SortingVisualizer } from './components/sorting/SortingVisualizer';\r\n\r\nconst App = (): JSX.Element => {\r\n  return (\r\n    <Router>\r\n      <Header />\r\n      <Switch>\r\n        <Route exact path={['/', '/sorting']} component={SortingVisualizer} />\r\n        <Route path=\"/pathfinding\" component={PathfindingVisualizer} />\r\n      </Switch>\r\n    </Router>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from 'react';\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}