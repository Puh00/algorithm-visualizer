{"version":3,"sources":["components/common/Header.tsx","assets/github.png","utils/Sleep.ts","utils/Array.ts","utils/Path.ts","utils/Coordinates.ts","utils/Random.ts","utils/Maze.ts","core/maze/BinaryTree.ts","core/maze/Eller.ts","core/maze/Kruskal.ts","core/maze/Prim.ts","core/maze/RecursiveBacktracking.ts","core/maze/RecursiveDivision.ts","core/maze/MazeFactory.ts","core/pathfinding/Astar.ts","core/pathfinding/UCS.ts","core/pathfinding/PathfindingFactory.ts","components/common/AlgorithmButtonGroup.tsx","components/pathfinding/CellButton.tsx","components/pathfinding/Grid.tsx","components/pathfinding/Popover.tsx","components/pathfinding/Panel.tsx","components/pathfinding/PathfindingVisualizer.tsx","core/model/Color.ts","core/sorting/BubbleSort.ts","core/sorting/CocktailSort.ts","core/sorting/HeapSort.ts","core/sorting/InsertionSort.ts","core/sorting/MergeSort.ts","core/sorting/QuickSort.ts","core/sorting/SelectionSort.ts","core/sorting/SortingFactory.ts","components/sorting/Panel.tsx","components/sorting/SortingVisualizer.tsx","App.tsx","index.tsx"],"names":["Header","Navbar","expand","bg","variant","className","Container","Brand","href","OverlayTrigger","placement","overlay","Tooltip","id","src","alt","Toggle","aria-controls","Collapse","Nav","Link","as","to","sleep","delay","Promise","resolve","setTimeout","swap","arr","x","y","setState","extractPath","entry","path","pqe","unshift","coord","backPointer","yDir","xDir","adjacentCoords","c","n","m","offset","coords","i","row","col","push","isSameCoord","c1","c2","alignmentBetweenCoordinates","p","q","Math","max","min","Error","randomNumber","floor","random","randomOddCoordinates","popRandomElementFromSet","set","size","rs","Array","from","values","delete","markAllCellsAsWalls","grid","setGrid","length","isWall","carveHorizontaly","a","carveVertically","carvePassageBetweenAdjacentCoordinates","alignment","BinaryTree","dirs","dir","coinflip","populate","sets","Set","_mergeSets","set1","set2","merged","forEach","value","add","mergeSets","val","index","removeRandomElements","s","horizontalConnections","verticalConnections","unique","nextRow","fill","Eller","Tree","parent","this","root","tree","setOfPossibleEdges","edges","Kruskal","isConnected","connect","passages","filter","mark","frontier","walls","item","Prim","startCoord","neighbours","shuffle","array","temp","j","carvePassagesFrom","visited","RecursiveBacktracking","addHWall","minX","maxX","hole","isStart","isFinish","addVWall","minY","maxY","addOuterWalls","divideHorizontally","divide","divideVertically","RecursiveDivision","getMazeAlgorithm","algorithmType","manhattanDistance","abs","fudge","crossProduct","start","dx1","dy1","dx2","dy2","cross","guessCost","heuristic","astar","goal","pq","PriorityQueue","comparator","p1","p2","costToHere","queue","dequeue","success","isActive","costToNext","UCS","getPathfindingAlgorithm","algorithm","AlgorithmButtonGroup","defaultAlgorithm","algorithms","setAlgorithm","ButtonGroup","map","alg","ToggleButton","type","checked","onChange","e","currentTarget","name","cellColor","cell","isPath","cssAnimation","CellButton","mouseDown","onMouseDown","onMouseEnter","onMouseUp","Button","style","backgroundColor","Grid","mode","setMode","setStart","finish","setFinish","searching","React","useState","setMouseDown","toggleWall","handleMouseUp","handleMouseDown","handleMouseEnter","moveFinish","moveStart","background","border","outline","display","height","width","cursor","marginBottom","onClick","onMouseLeave","popover","Popover","Title","Content","Panel","heuristics","setHeuristic","resetGrid","removePath","search","mazes","generateMaze","justifyContent","alignItems","DropdownButton","title","menuAlign","Dropdown","Item","SplitButton","toggleLabel","alignRight","charAt","toUpperCase","slice","disabled","h","newGrid","noHorizontalCells","window","innerWidth","noVerticalCells","innerHeight","calculateCells","_","drawPath","res","PathfindingVisualizer","setSearching","searcher","then","mazeGenerator","fluid","padding","Row","Col","md","RED","BLUE","GREEN","animation","bars","color","bubbleSort","greatestElementIndex","num","cocktailSort","swapped","end","heapify","largest","right","left","heapSort","insertionSort","nextGap","gap","ceil","inPlaceMerge","_sort","mid","mergeSort","partitionIndex","getMedian","midpoint","partition","pivotIndex","pivot","quicksort","selectionSort","iMin","getSortingAlgorithm","handleNumberChange","sort","reset","setDelay","textAlign","parseInt","target","step","onKeyDown","preventDefault","SortingVisualizer","setBars","setNum","resetBars","useEffect","sorter","Number","bar","idx","App","exact","component","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.701ad104.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nimport {\r\n  Container,\r\n  Nav,\r\n  Navbar,\r\n  OverlayTrigger,\r\n  Tooltip,\r\n} from 'react-bootstrap';\r\nimport { Link } from 'react-router-dom';\r\n\r\nimport logo from '../../assets/github.png';\r\n\r\nexport const Header = (): JSX.Element => {\r\n  return (\r\n    <Navbar expand=\"md\" bg=\"dark\" variant=\"dark\" className=\"app-vanish\">\r\n      <Container>\r\n        <Navbar.Brand href=\"https://github.com/Puh00/algorithm-visualizer\">\r\n          <OverlayTrigger\r\n            placement=\"bottom\"\r\n            overlay={<Tooltip id=\"tip\">View Project</Tooltip>}\r\n          >\r\n            <img src={logo} alt=\"github logo\" />\r\n          </OverlayTrigger>\r\n        </Navbar.Brand>\r\n        <Navbar.Toggle aria-controls=\"basic-navbar-nav\" />\r\n        <Navbar.Collapse id=\"basic-navbar-nav\">\r\n          <Nav className=\"me-auto\">\r\n            <Nav.Link as={Link} to=\"/sorting\">\r\n              Sorting\r\n            </Nav.Link>\r\n            <Nav.Link as={Link} to=\"/pathfinding\">\r\n              Pathfinding\r\n            </Nav.Link>\r\n          </Nav>\r\n        </Navbar.Collapse>\r\n      </Container>\r\n    </Navbar>\r\n  );\r\n};\r\n","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RERCMUIwOUY4NkNFMTFFM0FBNTJFRTMzNTJEMUJDNDYiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RERCMUIwOUU4NkNFMTFFM0FBNTJFRTMzNTJEMUJDNDYiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU1MTc4QTJBOTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU1MTc4QTJCOTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+jUqS1wAAApVJREFUeNq0l89rE1EQx3e3gVJoSPzZeNEWPKgHoa0HBak0iHiy/4C3WvDmoZ56qJ7txVsPQu8qlqqHIhRKJZceesmhioQEfxTEtsoSpdJg1u/ABJ7Pmc1m8zLwgWTmzcw3L+/te+tHUeQltONgCkyCi2AEDHLsJ6iBMlgHL8FeoqokoA2j4CloRMmtwTmj7erHBXPgCWhG6a3JNXKdCiDl1cidVbXZkJoXQRi5t5BrxwoY71FzU8S4JuAIqFkJ2+BFSlEh525b/hr3+k/AklDkNsf6wTT4yv46KIMNpsy+iMdMc47HNWxbsgVcUn7FmLAzzoFAWDsBx+wVP6bUpp5ewI+DOeUx0Wd9D8F70BTGNjkWtqnhmT1JQAHcUgZd8Lo3rQb1LAT8eJVUfgGvHQigGp+V2Z0iAUUl8QH47kAA1XioxIo+bRN8OG8F/oBjwv+Z1nJgX5jpdzQDw0LCjsPmrcW7I/iHScCAEDj03FtD8A0EyuChHgg4KTlJQF3wZ7WELppnBX+dBFSVpJsOBWi1qiRgSwnOgoyD5hmuJdkWCVhTgnTvW3AgYIFrSbZGh0UW/Io5Vp+DQoK7o80pztWMemZbgxeNwCNwDbw1fIfgGZjhU6xPaJgBV8BdsMw5cbZoHsenwYFxkZzl83xTSKTiviCAfCsJLysH3POfC8m8NegyGAGfLP/VmGmfSChgXroR0RSWjEFv2J/nG84cuKFMf4sTCZqXuJd4KaXFVjEG3+tw4eXbNK/YC9oXXs3O8NY8y99L4BXY5cvLY/Bb2VZ58EOJVcB18DHJq9lRsKr8inyKGVjlmh29mtHs3AHfuhCwy1vXT/Nu2GKQt+UHsGdctyX6eQyNvc+5sfX9Dl7Pe2J/BRgAl2CpwmrsHR0AAAAASUVORK5CYII=\"","export const sleep = (delay: number): Promise<void> =>\r\n  new Promise((resolve) => setTimeout(resolve, delay));\r\n","export const swap = <T>(\r\n  arr: T[],\r\n  x: number,\r\n  y: number,\r\n  setState?: React.Dispatch<React.SetStateAction<T[]>>\r\n): void => {\r\n  [arr[y], arr[x]] = [arr[x], arr[y]];\r\n  if (setState) setState([...arr]);\r\n};\r\n","import { Coord } from '../core/model/Cell';\r\nimport { PQEntry } from '../core/model/PQEntry';\r\n\r\n/**\r\n * Extract the full path from start to goal\r\n * @param entry the final priority queue entry\r\n * @returns the path from start to goal as a list of cells\r\n */\r\nexport const extractPath = (entry: PQEntry): Coord[] => {\r\n  const path = [];\r\n  let pqe: PQEntry | null = entry;\r\n  while (pqe !== null) {\r\n    path.unshift(pqe.coord);\r\n    pqe = pqe.backPointer;\r\n  }\r\n  return path;\r\n};\r\n","import { Coord } from '../core/model/Cell';\r\n\r\n// Direction vectors: [Up, Right, Down, Left]\r\nconst yDir = [-1, 0, 1, 0];\r\nconst xDir = [0, 1, 0, -1];\r\n\r\n/**\r\n * Retrieves adjacent coordinates that shares a border with the given coordinate.\r\n * @param c the coordinate to evaluate.\r\n * @param n the height of the grid.\r\n * @param m the width of the grid.\r\n * @param offset by default, the function will only give neighbours that are 1 unit away.\r\n * @returns adjacent coordinates that are within bounds.\r\n */\r\nexport const adjacentCoords = (\r\n  c: Coord,\r\n  n: number,\r\n  m: number,\r\n  offset = 1\r\n): Coord[] => {\r\n  const coords: Coord[] = [];\r\n  for (let i = 0; i < 4; i++) {\r\n    const row = c.y + yDir[i] * offset;\r\n    const col = c.x + xDir[i] * offset;\r\n    if (row >= 0 && col >= 0 && row < n && col < m) {\r\n      coords.push({ x: col, y: row });\r\n    }\r\n  }\r\n  return coords;\r\n};\r\n\r\n// Since Typescript compare by references...\r\nexport const isSameCoord = (c1: Coord, c2: Coord): boolean =>\r\n  c1.x === c2.x && c1.y === c2.y;\r\n\r\ntype dir = 'HORIZONTAL' | 'VERTICAL';\r\n\r\n/**\r\n * Calculates the alignement between two coordinates.\r\n * @param p the first coordinate.\r\n * @param q the second coordinate.\r\n * @throws will throw an error if the coordinates are neither vertically or\r\n * horizontally aligned\r\n * @returns the alignment between the coordinates.\r\n */\r\nexport const alignmentBetweenCoordinates = (p: Coord, q: Coord): dir => {\r\n  if (Math.max(p.y, q.y) - Math.min(p.y, q.y) === 0) return 'HORIZONTAL';\r\n  else if (Math.max(p.x, q.x) - Math.min(p.x, q.x) === 0) return 'VERTICAL';\r\n  else throw new Error('Neither horizontally or vertically aligned');\r\n};\r\n","import { Coord } from '../core/model/Cell';\r\n\r\n// inclusive: [min, max]\r\nexport const randomNumber = (min: number, max: number): number =>\r\n  Math.floor(Math.random() * (max - min + 1) + min);\r\n\r\n/**\r\n * Produces a random odd coordinate within the bounds of the given paramters\r\n * @param n Vertical size.\r\n * @param m Horizontal size.\r\n * @returns a random odd coordinate.\r\n */\r\nexport const randomOddCoordinates = (n: number, m: number): Coord => {\r\n  const x = randomNumber(2, m - 1);\r\n  const y = randomNumber(2, n - 1);\r\n  return { x: x % 2 === 0 ? x - 1 : x, y: y % 2 === 0 ? y - 1 : y };\r\n};\r\n\r\n/**\r\n * Removes a random element from the set and returns that object as the\r\n * value of this function\r\n * @param set the set to pick a random element from.\r\n * @throws will throw an error if the set is empty.\r\n * @returns the randomly picked element.\r\n */\r\nexport const popRandomElementFromSet = <T>(set: Set<T>): T => {\r\n  if (set.size === 0) throw new Error('Empty Set');\r\n  const rs = Array.from(set.values())[Math.floor(Math.random() * set.size)];\r\n  set.delete(rs);\r\n  return rs;\r\n};\r\n","import { alignmentBetweenCoordinates, sleep } from '.';\r\nimport { Cell, Coord } from '../core/model/Cell';\r\n\r\n/**\r\n * Convert each cell in the grid to a wall.\r\n * @param grid the grid that has the state of every cell.\r\n * @param setGrid react hook to update the state of the grid.\r\n */\r\nexport const markAllCellsAsWalls = (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): void => {\r\n  for (let row = 0; row < grid.length; row++) {\r\n    for (let col = 0; col < grid[0].length; col++) {\r\n      grid[row][col].isWall = true;\r\n    }\r\n  }\r\n  setGrid([...grid]);\r\n};\r\n\r\n/**\r\n * Carves to the right from the given coordinate.\r\n * @param grid the grid to carve upon.\r\n * @param x x coordinate.\r\n * @param y y coordinate.\r\n * @param setGrid react hook to update the state of the grid.\r\n */\r\nexport const carveHorizontaly = async (\r\n  grid: Cell[][],\r\n  x: number,\r\n  y: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  for (let i = 0; i < 3; i++) grid[y][x + i].isWall = false;\r\n  setGrid([...grid]);\r\n  await sleep(1);\r\n};\r\n\r\n/**\r\n * Carves downwards from the given coordinate.\r\n * @param grid the grid to carve upon.\r\n * @param x x coordinate.\r\n * @param y y coordinate.\r\n * @param setGrid react hook to update the state of the grid.\r\n */\r\nexport const carveVertically = async (\r\n  grid: Cell[][],\r\n  x: number,\r\n  y: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  for (let i = 0; i < 3; i++) grid[y + i][x].isWall = false;\r\n  setGrid([...grid]);\r\n  await sleep(1);\r\n};\r\n\r\n/**\r\n * Carve a passage between two coordinates if and only if they are adjacent\r\n * and vertically or horizontally aligned.\r\n * @param p starting coordinate.\r\n * @param q target coordinate.\r\n * @param grid the grid to carve upon.\r\n * @param setGrid react hook to update the state.\r\n */\r\nexport const carvePassageBetweenAdjacentCoordinates = async (\r\n  p: Coord,\r\n  q: Coord,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  const alignment = alignmentBetweenCoordinates(p, q);\r\n  if (alignment === 'HORIZONTAL')\r\n    // current cell and neighbour are horizontally aligned\r\n    await carveHorizontaly(grid, Math.min(p.x, q.x), p.y, setGrid);\r\n  else if (alignment === 'VERTICAL')\r\n    // ...vertically aligned\r\n    await carveVertically(grid, p.x, Math.min(p.y, q.y), setGrid);\r\n};\r\n","import {\r\n  carveHorizontaly,\r\n  carveVertically,\r\n  markAllCellsAsWalls,\r\n  randomNumber,\r\n} from '../../utils';\r\nimport { Cell } from '../model/Cell';\r\n\r\n// Binary Tree with Southeast bias\r\nexport const BinaryTree = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n\r\n  for (let row = 1; row < grid.length; row++) {\r\n    if (row % 2 === 0) continue;\r\n    for (let col = 1; col < grid[0].length; col++) {\r\n      if (col % 2 === 0) continue;\r\n      const dirs: string[] = [];\r\n      // if within bounds add the direction\r\n      if (col + 2 < grid[0].length - 1) dirs.push('EAST');\r\n      if (row + 2 < grid.length - 1) dirs.push('SOUTH');\r\n\r\n      const dir = dirs[randomNumber(0, dirs.length - 1)];\r\n      if (dir === 'EAST') await carveHorizontaly(grid, col, row, setGrid);\r\n      else if (dir === 'SOUTH') await carveVertically(grid, col, row, setGrid);\r\n    }\r\n  }\r\n};\r\n","import {\r\n  carveHorizontaly,\r\n  carveVertically,\r\n  markAllCellsAsWalls,\r\n  popRandomElementFromSet,\r\n} from '../../utils';\r\nimport { Cell } from '../model/Cell';\r\n\r\nconst coinflip = (): boolean => Math.random() > 0.5;\r\n\r\n/**\r\n * Replaces all of the null values in the current row with a new set\r\n * @param sets the array containing the sets of the current row.\r\n */\r\nconst populate = (sets: Array<Set<number> | null>): void => {\r\n  for (let i = 1; i < sets.length; i += 2) if (!sets[i]) sets[i] = new Set([i]);\r\n};\r\n\r\nconst _mergeSets = (\r\n  set1: Set<number> | null,\r\n  set2: Set<number> | null\r\n): Set<number> => {\r\n  if (!set1 || !set2) throw new Error(\"Can't merge undefined sets\");\r\n  const merged: Set<number> = new Set();\r\n  set1.forEach((value) => merged.add(value));\r\n  set2.forEach((value) => merged.add(value));\r\n  return merged;\r\n};\r\n\r\n/**\r\n * Merge two sets if and only if they are disjoint.\r\n *\r\n * Also updates previous sets to match with the newly merged set.\r\n *\r\n * @param sets the array containing the sets of the current row.\r\n * @param set1 the first coordinate's set.\r\n * @param set2 the second coordinate's set.\r\n * @param col x coordinate.\r\n * @param row y coordinate.\r\n * @param grid the grid to work with.\r\n * @param setGrid react hook to update the state of the grid.\r\n */\r\nconst mergeSets = async (\r\n  sets: Array<Set<number> | null>,\r\n  set1: Set<number> | null,\r\n  set2: Set<number> | null,\r\n  col: number,\r\n  row: number,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  if (set1 === set2) return;\r\n  const merged = _mergeSets(set1, set2);\r\n  [sets[col], sets[col + 2]] = [merged, merged];\r\n  // manually update earlier identical sets\r\n  sets.forEach((val, index) => {\r\n    if (val === set1 || val === set2) sets[index] = merged;\r\n  });\r\n  await carveHorizontaly(grid, col, row, setGrid);\r\n};\r\n\r\n/**\r\n * For each element in the set, randomly decide whether to remove it or not.\r\n * Ensures that there is at least one element left in the set.\r\n * @param s the set to manipulate.\r\n */\r\nconst removeRandomElements = (s: Set<number> | null): void => {\r\n  if (!s) throw new Error(\"Can't pop undefined set\");\r\n  for (let i = s.size; i > 1; i--) if (coinflip()) popRandomElementFromSet(s);\r\n};\r\n\r\nconst horizontalConnections = async (\r\n  sets: Array<Set<number> | null>,\r\n  row: number,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  for (let col = 1; col < grid[0].length; col += 2) {\r\n    // skip if out of bounds\r\n    if (!grid[row][col + 2]) continue;\r\n\r\n    const [set1, set2] = [sets[col], sets[col + 2]];\r\n\r\n    if (row !== grid.length - 2) {\r\n      if (coinflip())\r\n        // randomly join adjacent cells, given that they are disjoint\r\n        await mergeSets(sets, set1, set2, col, row, grid, setGrid);\r\n    }\r\n    // last row, connect all adjacent disjoint sets\r\n    else await mergeSets(sets, set1, set2, col, row, grid, setGrid);\r\n  }\r\n};\r\n\r\n/**\r\n * Randomly create vertical connections downward to the next row\r\n *\r\n * @param sets the array containing the state of the current row.\r\n * @param row y coordinate.\r\n * @param grid the grid to work with.\r\n * @param setGrid react hook to update the state of the grid.\r\n * @returns the sets in the next row.\r\n */\r\nconst verticalConnections = async (\r\n  sets: Array<Set<number> | null>,\r\n  row: number,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<Array<Set<number> | null>> => {\r\n  const unique = [...new Set(sets)];\r\n  for (let i = 1; i < unique.length; i++) removeRandomElements(unique[i]);\r\n\r\n  const nextRow: Array<Set<number> | null> = Array(grid[0].length).fill(null);\r\n\r\n  for (let i = 1; i < unique.length; i++) {\r\n    const set = unique[i];\r\n    if (!set) throw new Error('Undefined set');\r\n    for (const col of set) {\r\n      await carveVertically(grid, col, row, setGrid);\r\n      nextRow[col] = set;\r\n    }\r\n  }\r\n  return nextRow;\r\n};\r\n\r\nexport const Eller = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n  const [n, m] = [grid.length, grid[0].length];\r\n\r\n  // each cell in the row belongs to a set\r\n  // cells that share a set, also shares a path\r\n  let sets: Array<Set<number> | null> = Array(m).fill(null);\r\n\r\n  for (let row = 1; row < n; row += 2) {\r\n    // give undiscovered cells from previous iteration a set\r\n    populate(sets);\r\n\r\n    await horizontalConnections(sets, row, grid, setGrid);\r\n    // last row: skip creating vertical connections at the bottom of the grid\r\n    if (row === n - 2) return;\r\n    sets = await verticalConnections(sets, row, grid, setGrid);\r\n  }\r\n};\r\n","import {\r\n  carvePassageBetweenAdjacentCoordinates,\r\n  markAllCellsAsWalls,\r\n  popRandomElementFromSet,\r\n} from '../../utils';\r\nimport { Cell, Coord } from '../model/Cell';\r\n\r\ninterface Edge {\r\n  p: Coord;\r\n  q: Coord;\r\n}\r\n\r\n// Simple Tree data structure to see if two \"sets\" are disjoint\r\nclass Tree {\r\n  parent: Tree | undefined;\r\n\r\n  root(): Tree {\r\n    return this.parent ? this.parent.root() : this;\r\n  }\r\n\r\n  isConnected(tree: Tree): boolean {\r\n    return this.root() === tree.root();\r\n  }\r\n\r\n  connect(tree: Tree): void {\r\n    tree.root().parent = this;\r\n  }\r\n}\r\n\r\n// Returns a set of all possible edges in the given grid\r\nconst setOfPossibleEdges = (grid: Cell[][]): Set<Edge> => {\r\n  const edges = new Set<Edge>();\r\n  for (let row = 1; row < grid.length; row++) {\r\n    if (row % 2 === 0) continue;\r\n    for (let col = 1; col < grid[0].length; col++) {\r\n      if (col % 2 === 0) continue;\r\n      const x = col + 2;\r\n      const y = row + 2;\r\n      // East neighbour\r\n      if (x < grid[0].length - 1)\r\n        edges.add({ p: { x: col, y: row }, q: { x: x, y: row } });\r\n      // South neighbour\r\n      if (y < grid.length - 1)\r\n        edges.add({ p: { x: col, y: row }, q: { x: col, y } });\r\n    }\r\n  }\r\n  return edges;\r\n};\r\n\r\nexport const Kruskal = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n\r\n  // each cell is assigned a set to indicate who they belong to\r\n  const sets: Tree[][] = Array.from(Array(grid.length), () =>\r\n    Array.from(Array(grid[0].length), () => new Tree())\r\n  );\r\n\r\n  const edges = setOfPossibleEdges(grid);\r\n\r\n  while (edges.size !== 0) {\r\n    const { p, q } = popRandomElementFromSet(edges);\r\n    const [set1, set2] = [sets[p.y][p.x], sets[q.y][q.x]];\r\n    if (!set1.isConnected(set2)) {\r\n      set1.connect(set2);\r\n      await carvePassageBetweenAdjacentCoordinates(p, q, grid, setGrid);\r\n    }\r\n  }\r\n};\r\n","import {\r\n  adjacentCoords,\r\n  carvePassageBetweenAdjacentCoordinates,\r\n  markAllCellsAsWalls,\r\n  popRandomElementFromSet,\r\n  randomNumber,\r\n  randomOddCoordinates,\r\n} from '../../utils';\r\nimport { Cell, Coord } from '../model/Cell';\r\n\r\n// Retrieves adjacent coordinates that are passages\r\nconst passages = (grid: Cell[][], c: Coord): Coord[] => {\r\n  return adjacentCoords(c, grid.length, grid[0].length, 2).filter(\r\n    (coord) => !grid[coord.y][coord.x].isWall\r\n  );\r\n};\r\n\r\n// Retrieves adjacent coordinates that are walls\r\nconst walls = (grid: Cell[][], c: Coord): Coord[] => {\r\n  return adjacentCoords(c, grid.length, grid[0].length, 2).filter(\r\n    (coord) => grid[coord.y][coord.x].isWall\r\n  );\r\n};\r\n\r\n// Add walls adjacent to the given coordinate, whilst also removing it\r\nconst mark = (coord: Coord, grid: Cell[][], frontier: Set<Coord>): void => {\r\n  walls(grid, coord).forEach((item) => frontier.add(item));\r\n  frontier.delete(coord);\r\n};\r\n\r\nexport const Prim = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n\r\n  const startCoord = randomOddCoordinates(grid.length, grid[0].length);\r\n  const frontier = new Set<Coord>();\r\n\r\n  // need to mark the first cell as path manually otherwise it's gonna crash\r\n  grid[startCoord.y][startCoord.x].isWall = false;\r\n  mark(startCoord, grid, frontier);\r\n\r\n  while (frontier.size !== 0) {\r\n    const p = popRandomElementFromSet(frontier);\r\n\r\n    // Skip if it has already been converted to a path\r\n    if (!grid[p.y][p.x].isWall) continue;\r\n\r\n    const neighbours = passages(grid, p);\r\n    if (neighbours.length !== 0) {\r\n      const q = neighbours[randomNumber(0, neighbours.length - 1)];\r\n      await carvePassageBetweenAdjacentCoordinates(p, q, grid, setGrid);\r\n    }\r\n    mark(p, grid, frontier);\r\n  }\r\n};\r\n","import React from 'react';\r\n\r\nimport {\r\n  adjacentCoords,\r\n  carvePassageBetweenAdjacentCoordinates,\r\n  markAllCellsAsWalls,\r\n  randomOddCoordinates,\r\n} from '../../utils';\r\nimport { Cell } from '../model/Cell';\r\n\r\nexport const shuffle = <T>(array: T[]): T[] => {\r\n  const temp = [...array];\r\n  for (let i = temp.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [temp[i], temp[j]] = [temp[j], temp[i]]; // shorthand for swap\r\n  }\r\n  return temp;\r\n};\r\n\r\nconst carvePassagesFrom = async (\r\n  x: number,\r\n  y: number,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const neighbours = shuffle(\r\n    adjacentCoords({ x, y }, grid.length, grid[0].length, 2)\r\n  );\r\n  visited[y][x] = true;\r\n\r\n  for (const n of neighbours) {\r\n    if (!visited[n.y][n.x]) {\r\n      visited[n.y][n.x] = true;\r\n      await carvePassageBetweenAdjacentCoordinates({ x, y }, n, grid, setGrid);\r\n      await carvePassagesFrom(n.x, n.y, grid, setGrid, visited);\r\n    }\r\n  }\r\n};\r\n\r\nexport const RecursiveBacktracking = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n  const [n, m] = [grid.length, grid[0].length];\r\n  const visited: boolean[][] = Array.from(Array(n), () => Array(m).fill(false));\r\n  const { x, y } = randomOddCoordinates(n, m);\r\n  await carvePassagesFrom(x, y, grid, setGrid, visited);\r\n};\r\n","/* eslint-disable @typescript-eslint/no-use-before-define */\r\nimport React from 'react';\r\n\r\nimport { randomNumber, sleep } from '../../utils';\r\nimport { Cell } from '../model/Cell';\r\n\r\nconst addHWall = async (\r\n  grid: Cell[][],\r\n  minX: number,\r\n  maxX: number,\r\n  y: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const hole = Math.floor(randomNumber(minX, maxX) / 2) * 2 + 1;\r\n  for (let i = minX; i <= maxX; i++) {\r\n    if (i === hole) visited[y][i] = true;\r\n    else if (!visited[y][i] && !grid[y][i].isStart && !grid[y][i].isFinish)\r\n      grid[y][i].isWall = true;\r\n  }\r\n  setGrid([...grid]);\r\n  await sleep(1);\r\n};\r\n\r\nconst addVWall = async (\r\n  grid: Cell[][],\r\n  minY: number,\r\n  maxY: number,\r\n  x: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const hole = Math.floor(randomNumber(minY, maxY) / 2) * 2 + 1;\r\n  for (let i = minY; i <= maxY; i++) {\r\n    if (i === hole) visited[i][x] = true;\r\n    else if (!visited[i][x] && !grid[i][x].isStart && !grid[i][x].isFinish)\r\n      grid[i][x].isWall = true;\r\n  }\r\n  setGrid([...grid]);\r\n  await sleep(1);\r\n};\r\n\r\nconst addOuterWalls = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  // vertical walls\r\n  for (let i = 0; i < grid.length; i++) {\r\n    grid[i][0].isWall = true;\r\n    grid[i][grid[0].length - 1].isWall = true;\r\n  }\r\n  // horizontal walls\r\n  for (let i = 0; i < grid[0].length; i++) {\r\n    grid[0][i].isWall = true;\r\n    grid[grid.length - 1][i].isWall = true;\r\n  }\r\n  setGrid([...grid]);\r\n};\r\n\r\nconst divideHorizontally = async (\r\n  grid: Cell[][],\r\n  minX: number,\r\n  maxX: number,\r\n  minY: number,\r\n  maxY: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const y = Math.floor(randomNumber(minY, maxY) / 2) * 2;\r\n  await addHWall(grid, minX, maxX, y, setGrid, visited);\r\n  // upper chamber\r\n  await divide(grid, minX, maxX, minY, y - 1, setGrid, visited);\r\n  // lower chamber\r\n  await divide(grid, minX, maxX, y + 1, maxY, setGrid, visited);\r\n};\r\n\r\nconst divideVertically = async (\r\n  grid: Cell[][],\r\n  minX: number,\r\n  maxX: number,\r\n  minY: number,\r\n  maxY: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const x = Math.floor(randomNumber(minX, maxX) / 2) * 2;\r\n  await addVWall(grid, minY, maxY, x, setGrid, visited);\r\n  // left chamber\r\n  await divide(grid, minX, x - 1, minY, maxY, setGrid, visited);\r\n  // right chamber\r\n  await divide(grid, x + 1, maxX, minY, maxY, setGrid, visited);\r\n};\r\n\r\nconst divide = async (\r\n  grid: Cell[][],\r\n  minX: number,\r\n  maxX: number,\r\n  minY: number,\r\n  maxY: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  if (maxX - minX < 2 || maxY - minY < 2) return;\r\n  if (maxX - minX < maxY - minY) {\r\n    divideHorizontally(grid, minX, maxX, minY, maxY, setGrid, visited);\r\n  } else if (maxY - minY < maxX - minX) {\r\n    divideVertically(grid, minX, maxX, minY, maxY, setGrid, visited);\r\n  } else {\r\n    if (randomNumber(0, 1) === 0)\r\n      divideHorizontally(grid, minX, maxX, minY, maxY, setGrid, visited);\r\n    else divideVertically(grid, minX, maxX, minY, maxY, setGrid, visited);\r\n  }\r\n};\r\n\r\nexport const RecursiveDivision = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  const visited: boolean[][] = Array.from(Array(grid.length), () =>\r\n    Array(grid[0].length).fill(false)\r\n  );\r\n  await addOuterWalls(grid, setGrid);\r\n  await divide(\r\n    grid,\r\n    1,\r\n    grid[0].length - 2,\r\n    1,\r\n    grid.length - 2,\r\n    setGrid,\r\n    visited\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { Cell } from '../model/Cell';\r\nimport { BinaryTree } from './BinaryTree';\r\nimport { Eller } from './Eller';\r\nimport { Kruskal } from './Kruskal';\r\nimport { Prim } from './Prim';\r\nimport { RecursiveBacktracking } from './RecursiveBacktracking';\r\nimport { RecursiveDivision } from './RecursiveDivision';\r\n\r\ntype mazeFunc = (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n) => Promise<void>;\r\n\r\nexport const getMazeAlgorithm = (algorithmType: string): mazeFunc => {\r\n  if (algorithmType === 'division') return RecursiveDivision;\r\n  else if (algorithmType === 'backtracking') return RecursiveBacktracking;\r\n  else if (algorithmType === 'binary') return BinaryTree;\r\n  else if (algorithmType === 'prim') return Prim;\r\n  else if (algorithmType === 'kruskal') return Kruskal;\r\n  else if (algorithmType === 'eller') return Eller;\r\n  else throw new Error('Invalid argument for Maze Algorithm');\r\n};\r\n","import React from 'react';\r\n\r\nimport PriorityQueue from 'ts-priority-queue';\r\n\r\nimport { adjacentCoords, extractPath, isSameCoord, sleep } from '../../utils';\r\nimport { Cell, Coord } from '../model/Cell';\r\nimport { PQEntry, Result } from '../model/PQEntry';\r\n\r\n// _____Different tie breakers_____\r\n/**\r\n * Calulates the Manhattan distance between the given coordinates.\r\n * @param p the first coordinate.\r\n * @param q the second coordinate.\r\n * @returns the Manhattan distance between the two coordinates.\r\n */\r\nconst manhattanDistance = (p: Coord, q: Coord): number =>\r\n  Math.abs(p.x - q.x) + Math.abs(p.y - q.y);\r\n\r\n/**\r\n * Nudge the scale of [h] slightly so that the heuristic favours nodes closer to the goal.\r\n * - Inadmissible heuristic\r\n * From {@link https://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html}\r\n * @param p the current coordinate.\r\n * @param q the target coordinate.\r\n * @returns modified heuristic.\r\n */\r\nconst fudge = (p: Coord, q: Coord): number => {\r\n  const heuristic = manhattanDistance(p, q);\r\n  return heuristic * (1 + 1 / 1000);\r\n};\r\n\r\n/**\r\n * Heuristic that prefers a path that lies along the straight line from the start to the\r\n * goal\r\n * - Inadmissible heuristic\r\n * From {@link https://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html}\r\n * @param start starting coordinate.\r\n * @param p the current coordinate.\r\n * @param q the target coordinate.\r\n * @returns modified heuristic.\r\n */\r\nconst crossProduct = (start: Coord, p: Coord, q: Coord): number => {\r\n  const dx1 = p.x - q.x;\r\n  const dy1 = p.y - q.y;\r\n  const dx2 = start.x - q.x;\r\n  const dy2 = start.y - q.y;\r\n  const cross = Math.abs(dx1 * dy2 - dx2 * dy1);\r\n  const heuristic = manhattanDistance(p, q);\r\n  return heuristic + cross * 0.001;\r\n};\r\n\r\n// Delegate calculation of heuristic\r\nconst guessCost = (\r\n  start: Coord,\r\n  p: Coord,\r\n  q: Coord,\r\n  heuristic = 'manhattan'\r\n): number => {\r\n  if (heuristic === 'manhattan') return manhattanDistance(p, q);\r\n  else if (heuristic === 'fudge') return fudge(p, q);\r\n  else if (heuristic === 'cross') return crossProduct(start, p, q);\r\n  else throw new Error('Invalid heuristic type');\r\n};\r\n\r\n/**\r\n * A* search algorithm\r\n * @param start the starting coordinate.\r\n * @param goal the target coordinate.\r\n * @param grid the grid that has the state of every cell.\r\n * @param setGrid react hook to update the state of the grid.\r\n * @returns the path from start to goal if the algorithm successfully found the target.\r\n */\r\nexport const astar = async (\r\n  start: Coord,\r\n  goal: Coord,\r\n  grid: Cell[][],\r\n  setState: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  heuristic?: string\r\n): Promise<Result> => {\r\n  const [n, m] = [grid.length, grid[0].length];\r\n\r\n  // Auxiliary array keeping track of visited cells\r\n  const visited: boolean[][] = Array.from(Array(n), () => Array(m).fill(false));\r\n\r\n  const pq = new PriorityQueue<PQEntry>({\r\n    comparator: (p1, p2) => {\r\n      // bug: 'if (p1.guessCost)' will return false if p1.guessCost is 0\r\n      if (\r\n        typeof p1.guessCost !== 'undefined' &&\r\n        typeof p2.guessCost !== 'undefined'\r\n      )\r\n        return p1.costToHere + p1.guessCost - (p2.costToHere + p2.guessCost);\r\n      else throw new Error(\"Undefined field 'guessCost' in PQEntry\");\r\n    },\r\n  });\r\n\r\n  // Add starting cell to be searched\r\n  pq.queue({\r\n    coord: start,\r\n    costToHere: 0,\r\n    backPointer: null,\r\n    guessCost: guessCost(start, start, goal, heuristic),\r\n  });\r\n\r\n  while (pq.length !== 0) {\r\n    const entry = pq.dequeue();\r\n\r\n    if (isSameCoord(entry.coord, goal))\r\n      return { success: true, path: extractPath(entry) };\r\n\r\n    if (\r\n      !visited[entry.coord.y][entry.coord.x] &&\r\n      !grid[entry.coord.y][entry.coord.x].isWall\r\n    ) {\r\n      visited[entry.coord.y][entry.coord.x] = true;\r\n\r\n      // mark visited cells\r\n      grid[entry.coord.y][entry.coord.x].isActive = true;\r\n      setState([...grid]);\r\n      await sleep(1);\r\n\r\n      for (const c of adjacentCoords(entry.coord, n, m)) {\r\n        const costToNext = entry.costToHere + 1;\r\n        pq.queue({\r\n          coord: c,\r\n          costToHere: costToNext,\r\n          backPointer: entry,\r\n          guessCost: guessCost(start, c, goal, heuristic),\r\n        });\r\n      }\r\n    }\r\n  }\r\n  return { success: false, path: null };\r\n};\r\n","import React from 'react';\r\n\r\nimport PriorityQueue from 'ts-priority-queue';\r\n\r\nimport { adjacentCoords, extractPath, isSameCoord, sleep } from '../../utils';\r\nimport { Cell, Coord } from '../model/Cell';\r\nimport { PQEntry, Result } from '../model/PQEntry';\r\n\r\n/**\r\n * Uniform-Cost Search\r\n * @param start the starting coordinate.\r\n * @param goal the target coordinate.\r\n * @param grid the grid that has the state of every cell.\r\n * @param setGrid react hook to update the state of the grid.\r\n * @returns the path from start to goal if the algorithm successfully found the target.\r\n */\r\nexport const UCS = async (\r\n  start: Coord,\r\n  goal: Coord,\r\n  grid: Cell[][],\r\n  setState: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<Result> => {\r\n  const [n, m] = [grid.length, grid[0].length];\r\n\r\n  // Auxiliary array keeping track of visited cells\r\n  const visited: boolean[][] = Array.from(Array(n), () => Array(m).fill(false));\r\n\r\n  const pq = new PriorityQueue<PQEntry>({\r\n    comparator: (p1, p2) => p1.costToHere - p2.costToHere,\r\n  });\r\n\r\n  // Add starting cell to be searched\r\n  pq.queue({ coord: start, costToHere: 0, backPointer: null });\r\n\r\n  while (pq.length !== 0) {\r\n    const entry = pq.dequeue();\r\n\r\n    if (isSameCoord(entry.coord, goal))\r\n      return { success: true, path: extractPath(entry) };\r\n\r\n    if (\r\n      !visited[entry.coord.y][entry.coord.x] &&\r\n      !grid[entry.coord.y][entry.coord.x].isWall\r\n    ) {\r\n      visited[entry.coord.y][entry.coord.x] = true;\r\n\r\n      // mark visited cells\r\n      grid[entry.coord.y][entry.coord.x].isActive = true;\r\n      setState([...grid]);\r\n      await sleep(1);\r\n\r\n      for (const c of adjacentCoords(entry.coord, n, m)) {\r\n        const costToNext = entry.costToHere + 1;\r\n        pq.queue({ coord: c, costToHere: costToNext, backPointer: entry });\r\n      }\r\n    }\r\n  }\r\n  return { success: false, path: null };\r\n};\r\n","import { Cell, Coord } from '../model/Cell';\r\nimport { Result } from '../model/PQEntry';\r\nimport { astar } from './Astar';\r\nimport { UCS } from './UCS';\r\n\r\ntype pathfindingFunc = (\r\n  start: Coord,\r\n  finish: Coord,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  heuristic?: string\r\n) => Promise<Result>;\r\n\r\nexport const getPathfindingAlgorithm = (algorithm: string): pathfindingFunc => {\r\n  if (algorithm === 'ucs') return UCS;\r\n  else if (algorithm === 'astar') return astar;\r\n  else throw new Error('Incorrect type for pathfinding algorithm');\r\n};\r\n","import React from 'react';\r\n\r\nimport { ButtonGroup, ToggleButton } from 'react-bootstrap';\r\n\r\ninterface Algorithm {\r\n  name: string;\r\n  value: string;\r\n}\r\n\r\ninterface Props {\r\n  defaultAlgorithm: string;\r\n  algorithms: Algorithm[];\r\n  setAlgorithm: React.Dispatch<React.SetStateAction<string>>;\r\n}\r\n\r\nexport const AlgorithmButtonGroup: React.FC<Props> = ({\r\n  defaultAlgorithm,\r\n  algorithms,\r\n  setAlgorithm,\r\n}: Props) => {\r\n  return (\r\n    <ButtonGroup className=\"p-1\">\r\n      {algorithms.map((alg) => (\r\n        <ToggleButton\r\n          key={alg.value}\r\n          type=\"radio\"\r\n          variant=\"outline-warning\"\r\n          value={alg.value}\r\n          checked={defaultAlgorithm === alg.value}\r\n          onChange={(e) => setAlgorithm(e.currentTarget.value)}\r\n        >\r\n          {alg.name}\r\n        </ToggleButton>\r\n      ))}\r\n    </ButtonGroup>\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { Button } from 'react-bootstrap';\r\n\r\nimport { Cell } from '../../core/model/Cell';\r\nimport './CellButton.css';\r\n\r\ninterface Props {\r\n  cell: Cell;\r\n  mouseDown: boolean;\r\n  onMouseDown: (row: number, col: number) => void;\r\n  onMouseEnter: (row: number, col: number) => void;\r\n  onMouseUp: () => void;\r\n}\r\n\r\nconst cellColor = (cell: Cell): string => {\r\n  if (cell.isWall) return 'grey';\r\n  else if (cell.isStart) return 'yellow';\r\n  else if (cell.isFinish) return 'blue';\r\n  else if (cell.isPath) return 'Chartreuse';\r\n  // or tomato for brighter\r\n  else if (cell.isActive) return 'crimson';\r\n  else return 'azure';\r\n};\r\n\r\nconst cssAnimation = (cell: Cell): string => {\r\n  return cell.isPath ? 'finish' : cell.isActive ? 'visited' : '';\r\n};\r\n\r\nexport const CellButton: React.FC<Props> = ({\r\n  cell,\r\n  mouseDown,\r\n  onMouseDown,\r\n  onMouseEnter,\r\n  onMouseUp,\r\n}: Props) => {\r\n  return (\r\n    <Button\r\n      className={`cell ${cssAnimation(cell)}`}\r\n      style={{\r\n        backgroundColor: cellColor(cell),\r\n      }}\r\n      onMouseEnter={() => {\r\n        if (mouseDown) onMouseEnter(cell.coord.y, cell.coord.x);\r\n      }}\r\n      onMouseDown={() => onMouseDown(cell.coord.y, cell.coord.x)}\r\n      onMouseUp={onMouseUp}\r\n    />\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { Cell, Coord } from '../../core/model/Cell';\r\nimport { CellButton } from './CellButton';\r\n\r\ninterface Props {\r\n  grid: Cell[][];\r\n  mode: string;\r\n  setMode: React.Dispatch<React.SetStateAction<string>>;\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>;\r\n  start: Coord;\r\n  setStart: React.Dispatch<React.SetStateAction<Coord>>;\r\n  finish: Coord;\r\n  setFinish: React.Dispatch<React.SetStateAction<Coord>>;\r\n  searching: boolean;\r\n}\r\n\r\nexport const Grid: React.FC<Props> = ({\r\n  grid,\r\n  mode,\r\n  setMode,\r\n  setGrid,\r\n  start,\r\n  setStart,\r\n  finish,\r\n  setFinish,\r\n  searching,\r\n}: Props) => {\r\n  const [mouseDown, setMouseDown] = React.useState<boolean>(false);\r\n\r\n  const toggleWall = (row: number, col: number): void => {\r\n    const cell = grid[row][col];\r\n    if (!cell.isStart && !cell.isFinish) {\r\n      cell.isWall = !cell.isWall;\r\n      setGrid([...grid]);\r\n    }\r\n  };\r\n\r\n  const moveStart = (row: number, col: number): void => {\r\n    grid[start.y][start.x].isStart = false;\r\n    const cell: Cell = grid[row][col];\r\n    cell.isStart = true;\r\n    setStart(cell.coord);\r\n    setGrid([...grid]);\r\n  };\r\n\r\n  const moveFinish = (row: number, col: number): void => {\r\n    grid[finish.y][finish.x].isFinish = false;\r\n    const cell = grid[row][col];\r\n    cell.isFinish = true;\r\n    setFinish(cell.coord);\r\n    setGrid([...grid]);\r\n  };\r\n\r\n  const handleMouseUp = (): void => setMouseDown(false);\r\n\r\n  const handleMouseDown = (row: number, col: number): void => {\r\n    if (grid[row][col].isStart) setMode('start');\r\n    else if (grid[row][col].isFinish) setMode('finish');\r\n    else {\r\n      setMode('wall');\r\n      toggleWall(row, col);\r\n    }\r\n    setMouseDown(true);\r\n  };\r\n\r\n  const handleMouseEnter = (row: number, col: number): void => {\r\n    if (mouseDown) {\r\n      if (mode === 'wall') toggleWall(row, col);\r\n      else if (mode === 'start' && !searching) moveStart(row, col);\r\n      else if (mode === 'finish' && !searching) moveFinish(row, col);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      {/* 🐰 🥚 */}\r\n      <button\r\n        style={{\r\n          background: 'transparent',\r\n          border: 'none',\r\n          outline: 'none',\r\n          display: 'block',\r\n          height: '5px',\r\n          width: '5px',\r\n          cursor: 'pointer',\r\n          marginBottom: '5px',\r\n        }}\r\n        onClick={() => {\r\n          for (let i = 0; i < grid.length; i++) {\r\n            grid[i][0].isWall = true;\r\n            grid[i][grid[0].length - 1].isWall = true;\r\n          }\r\n          // horizontal walls\r\n          for (let i = 0; i < grid[0].length; i++) {\r\n            grid[0][i].isWall = true;\r\n            grid[grid.length - 1][i].isWall = true;\r\n          }\r\n          for (let i = 0; i < grid.length - 1; i++) {\r\n            for (let j = 0; j < grid[0].length - 1; j++) {\r\n              if (i % 2 === 0 && j % 2 === 0) grid[i][j].isWall = true;\r\n            }\r\n          }\r\n          setGrid([...grid]);\r\n        }}\r\n      />\r\n      <div\r\n        onMouseDown={() => {\r\n          setMouseDown(true);\r\n        }}\r\n        onMouseUp={() => {\r\n          setMouseDown(false);\r\n        }}\r\n        onMouseLeave={() => {\r\n          setMouseDown(false);\r\n        }}\r\n      >\r\n        {grid.map((row, i) => (\r\n          <div key={i}>\r\n            {row.map((c, j) => (\r\n              <CellButton\r\n                cell={c}\r\n                key={j}\r\n                mouseDown={mouseDown}\r\n                onMouseDown={handleMouseDown}\r\n                onMouseEnter={handleMouseEnter}\r\n                onMouseUp={handleMouseUp}\r\n              />\r\n            ))}\r\n          </div>\r\n        ))}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { Popover } from 'react-bootstrap';\r\n\r\n/**\r\n * Basic popover explaining the different ways to calculate heuristic for A*\r\n */\r\nexport const popover = (\r\n  <Popover id=\"popover-basic\">\r\n    <Popover.Title as=\"h3\">A* Heuristic</Popover.Title>\r\n    <Popover.Content>\r\n      Different methods of calculating the heuristic in A*\r\n      <ul>\r\n        <li>\r\n          <strong>Manhattan distance</strong>:\r\n          <ul>\r\n            <li>Guarantees shortest path.</li>\r\n            <li>Trading speed for accuracy.</li>\r\n          </ul>\r\n        </li>\r\n        <li>\r\n          <strong>Fudge</strong>:\r\n          <ul>\r\n            <li>\r\n              Similar to A* except that the heuristic favours nodes closer to\r\n              the target.\r\n            </li>\r\n            <li>Finds a more direct route.</li>\r\n            <li>Inadmissible heuristic.</li>\r\n          </ul>\r\n        </li>\r\n        <li>\r\n          <strong>Cross</strong>:\r\n          <ul>\r\n            <li>\r\n              Prefers path that are along the straight line from the starting\r\n              point to the target.\r\n            </li>\r\n            <li>Nicer diagonal paths.</li>\r\n            <li>Inadmissible heuristic.</li>\r\n          </ul>\r\n        </li>\r\n      </ul>\r\n    </Popover.Content>\r\n  </Popover>\r\n);\r\n","import React from 'react';\r\n\r\nimport {\r\n  Button,\r\n  Dropdown,\r\n  DropdownButton,\r\n  OverlayTrigger,\r\n  SplitButton,\r\n} from 'react-bootstrap';\r\n\r\nimport { popover } from './Popover';\r\n\r\ninterface NameValue {\r\n  name: string;\r\n  value: string;\r\n}\r\n\r\ninterface Props {\r\n  algorithm: string;\r\n  AlgorithmButtonGroup: React.ReactNode;\r\n  heuristic: string;\r\n  heuristics: NameValue[];\r\n  setHeuristic: React.Dispatch<React.SetStateAction<string>>;\r\n  resetGrid: () => void;\r\n  removePath: () => void;\r\n  search: () => Promise<void>;\r\n  mazes: NameValue[];\r\n  generateMaze: (algorithmType: string) => Promise<void>;\r\n}\r\n\r\nexport const Panel: React.FC<Props> = ({\r\n  algorithm,\r\n  AlgorithmButtonGroup,\r\n  heuristic,\r\n  heuristics,\r\n  setHeuristic,\r\n  resetGrid,\r\n  removePath,\r\n  search,\r\n  mazes,\r\n  generateMaze,\r\n}: Props) => {\r\n  return (\r\n    <div\r\n      style={{\r\n        display: 'flex',\r\n        justifyContent: 'center',\r\n        alignItems: 'center',\r\n      }}\r\n    >\r\n      <DropdownButton variant=\"success\" title=\"Mazes\" menuAlign=\"left\">\r\n        {mazes.map((m, i) => (\r\n          <Dropdown.Item\r\n            as=\"button\"\r\n            key={i}\r\n            onClick={() => generateMaze(m.value)}\r\n          >\r\n            {m.name}\r\n          </Dropdown.Item>\r\n        ))}\r\n      </DropdownButton>\r\n      <SplitButton\r\n        id=\"reset\"\r\n        className=\"m-2\"\r\n        variant=\"danger\"\r\n        title={'Reset'}\r\n        toggleLabel=\"\"\r\n        onClick={resetGrid}\r\n      >\r\n        <Dropdown.Item onClick={removePath}>Clear path</Dropdown.Item>\r\n      </SplitButton>\r\n      <Button onClick={search} variant=\"primary\" className=\"m-1\">\r\n        Search!\r\n      </Button>\r\n      {AlgorithmButtonGroup}\r\n      <OverlayTrigger placement=\"right\" overlay={popover}>\r\n        <DropdownButton\r\n          alignRight={true}\r\n          className=\"m-1\"\r\n          variant=\"secondary\"\r\n          title={heuristic.charAt(0).toUpperCase() + heuristic.slice(1)}\r\n          disabled={algorithm !== 'astar'}\r\n        >\r\n          {heuristics.map((h) => (\r\n            <Dropdown.Item\r\n              as=\"button\"\r\n              key={h.value}\r\n              onClick={() => setHeuristic(h.value)}\r\n            >\r\n              {h.name}\r\n            </Dropdown.Item>\r\n          ))}\r\n        </DropdownButton>\r\n      </OverlayTrigger>\r\n    </div>\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { Col, Container, Row } from 'react-bootstrap';\r\n\r\nimport { getMazeAlgorithm } from '../../core/maze/MazeFactory';\r\nimport { Cell, Coord } from '../../core/model/Cell';\r\nimport { Result } from '../../core/model/PQEntry';\r\nimport { getPathfindingAlgorithm } from '../../core/pathfinding/PathfindingFactory';\r\nimport { sleep } from '../../utils';\r\nimport { AlgorithmButtonGroup } from '../common/AlgorithmButtonGroup';\r\nimport { Grid } from './Grid';\r\nimport { Panel } from './Panel';\r\n\r\nconst algorithms = [\r\n  { name: 'UCS', value: 'ucs' },\r\n  { name: 'A*', value: 'astar' },\r\n];\r\nconst mazes = [\r\n  { name: 'Recursive Division', value: 'division' },\r\n  { name: 'Recursive Backtracking', value: 'backtracking' },\r\n  { name: 'Binary Tree (Southeast bias)', value: 'binary' },\r\n  { name: \"Prim's Algorithm\", value: 'prim' },\r\n  { name: \"Kruskal's Algorithm\", value: 'kruskal' },\r\n  { name: \"Eller's Algorithm\", value: 'eller' },\r\n];\r\nconst heuristics = [\r\n  { name: 'Manhattan distance', value: 'manhattan' },\r\n  { name: 'Fudge', value: 'fudge' },\r\n  { name: 'Cross', value: 'cross' },\r\n];\r\n\r\n// Calculate how many cells fit the screen horizontally and vertically\r\nconst calculateCells = (): [number, number] => {\r\n  const noHorizontalCells = Math.floor(window.innerWidth / 30);\r\n  const noVerticalCells = Math.floor((window.innerHeight - 160) / 30);\r\n  // maze algorithm requires maze to have odd size\r\n  return [\r\n    noHorizontalCells % 2 === 0 ? noHorizontalCells - 1 : noHorizontalCells,\r\n    noVerticalCells % 2 === 0 ? noVerticalCells - 1 : noVerticalCells,\r\n  ];\r\n};\r\n\r\nconst newGrid = (start: Coord, finish: Coord): Cell[][] => {\r\n  const [n, m] = calculateCells();\r\n  const grid: Cell[][] = [...Array(m)].map((_, i) => {\r\n    return [...Array(n)].map((_, j) => ({\r\n      coord: { x: j, y: i },\r\n      isActive: false,\r\n      isPath: false,\r\n      isStart: false,\r\n      isFinish: false,\r\n      isWall: false,\r\n    }));\r\n  });\r\n  grid[start.y][start.x].isStart = true;\r\n  grid[finish.y][finish.x].isFinish = true;\r\n  return grid;\r\n};\r\n\r\nconst removePath = (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): void => {\r\n  for (let row = 0; row < grid.length; row++)\r\n    for (let col = 0; col < grid[0].length; col++) {\r\n      const cell = grid[row][col];\r\n      if (cell.isPath) cell.isPath = false;\r\n      if (cell.isActive) cell.isActive = false;\r\n    }\r\n  setGrid([...grid]);\r\n};\r\n\r\n// Draw the path received from pathfinding algorithm\r\nconst drawPath = async (\r\n  res: Result,\r\n  grid: Cell[][],\r\n  setState: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  if (res.path) {\r\n    for (const c of res.path) {\r\n      grid[c.y][c.x].isPath = true;\r\n      setState([...grid]);\r\n      await sleep(1);\r\n    }\r\n  }\r\n};\r\n\r\nexport const PathfindingVisualizer: React.FC = () => {\r\n  const [algorithm, setAlgorithm] = React.useState<string>('astar');\r\n  // to disable moving starting and finish cells during search\r\n  const [searching, setSearching] = React.useState<boolean>(false);\r\n  const [start, setStart] = React.useState<Coord>({ x: 1, y: 3 });\r\n  const [finish, setFinish] = React.useState<Coord>({ x: 7, y: 3 });\r\n  const [grid, setGrid] = React.useState<Cell[][]>(newGrid(start, finish));\r\n  const [mode, setMode] = React.useState<string>('wall');\r\n  const [heuristic, setHeuristic] = React.useState<string>('manhattan');\r\n\r\n  const search = async (): Promise<void> => {\r\n    const searcher = getPathfindingAlgorithm(algorithm);\r\n    setSearching(true);\r\n    await searcher(start, finish, grid, setGrid, heuristic).then(\r\n      async (res) => {\r\n        if (res.success) await drawPath(res, grid, setGrid);\r\n      }\r\n    );\r\n    setSearching(false);\r\n  };\r\n\r\n  const generateMaze = async (algorithmType: string): Promise<void> => {\r\n    const mazeGenerator = getMazeAlgorithm(algorithmType);\r\n    await mazeGenerator(grid, setGrid);\r\n  };\r\n\r\n  return (\r\n    <Container fluid={true} style={{ padding: '0' }}>\r\n      <Row>\r\n        <Col\r\n          style={{\r\n            display: 'flex',\r\n            justifyContent: 'center',\r\n            alignItems: 'center',\r\n          }}\r\n        >\r\n          <Panel\r\n            AlgorithmButtonGroup={\r\n              <AlgorithmButtonGroup\r\n                defaultAlgorithm={algorithm}\r\n                algorithms={algorithms}\r\n                setAlgorithm={setAlgorithm}\r\n              />\r\n            }\r\n            algorithm={algorithm}\r\n            heuristic={heuristic}\r\n            heuristics={heuristics}\r\n            setHeuristic={setHeuristic}\r\n            resetGrid={() => setGrid(newGrid(start, finish))}\r\n            removePath={() => removePath(grid, setGrid)}\r\n            search={search}\r\n            mazes={mazes}\r\n            generateMaze={generateMaze}\r\n          />\r\n        </Col>\r\n      </Row>\r\n      <Row className=\"justify-content-center\">\r\n        <Col md=\"auto\">\r\n          <Grid\r\n            grid={grid}\r\n            mode={mode}\r\n            setMode={setMode}\r\n            setGrid={setGrid}\r\n            start={start}\r\n            setStart={setStart}\r\n            finish={finish}\r\n            setFinish={setFinish}\r\n            searching={searching}\r\n          />\r\n        </Col>\r\n      </Row>\r\n    </Container>\r\n  );\r\n};\r\n","export type Color = '#FF0000' | '#0000FF' | '#7CFC00';\r\nexport const RED: Color = '#FF0000';\r\nexport const BLUE: Color = '#0000FF';\r\nexport const GREEN: Color = '#7CFC00';\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN, BLUE } from '../model/Color';\r\n\r\nconst animation = async (\r\n  bars: Bar[],\r\n  j: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  bars[j].color = RED;\r\n  bars[j + 1].color = GREEN;\r\n  setState([...bars]);\r\n  await sleep(delay);\r\n  bars[j].color = BLUE;\r\n  bars[j + 1].color = BLUE;\r\n};\r\n\r\nexport const bubbleSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  const n: number = bars.length;\r\n  let greatestElementIndex: number = bars.length;\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    for (let j = 0; j < n - 1; j++) {\r\n      if (bars[j].num > bars[j + 1].num) {\r\n        swap(bars, j, j + 1);\r\n        await animation(bars, j, setState, delay);\r\n      }\r\n\r\n      if (j === greatestElementIndex - 2) {\r\n        // make the iteration's greatest element green (sorted partition)\r\n        greatestElementIndex--;\r\n        bars[greatestElementIndex].color = RED;\r\n        setState([...bars]);\r\n      }\r\n    }\r\n  }\r\n};\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN, BLUE } from '../model/Color';\r\n\r\nexport const cocktailSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  let swapped = true;\r\n  let start = 0;\r\n  let end = bars.length;\r\n\r\n  while (swapped) {\r\n    swapped = false;\r\n\r\n    // bottom to top\r\n    for (let i = start; i < end - 1; i++) {\r\n      if (bars[i].num > bars[i + 1].num) {\r\n        swap(bars, i, i + 1);\r\n        swapped = true;\r\n      }\r\n      bars[i].color = BLUE;\r\n      bars[i + 1].color = GREEN;\r\n      setState([...bars]);\r\n      await sleep(delay);\r\n    }\r\n\r\n    // mark this iterations greatest element\r\n    bars[end - 1].color = RED;\r\n    setState([...bars]);\r\n\r\n    // exit if sorted\r\n    if (!swapped) break;\r\n\r\n    swapped = false;\r\n    end--;\r\n\r\n    // top to bottom\r\n    for (let i = end - 1; i >= start; i--) {\r\n      if (bars[i].num > bars[i + 1].num) {\r\n        swap(bars, i, i + 1);\r\n        swapped = true;\r\n      }\r\n      if (i !== end - 1) bars[i + 1].color = BLUE;\r\n      bars[i].color = GREEN;\r\n      setState([...bars]);\r\n      await sleep(delay);\r\n    }\r\n    // mark this iterations smallest element\r\n    bars[start].color = RED;\r\n    setState([...bars]);\r\n\r\n    start++;\r\n  }\r\n};\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, BLUE } from '../model/Color';\r\n\r\nconst animation = async (\r\n  bars: Bar[],\r\n  x: number,\r\n  y: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  bars[x].color = RED;\r\n  bars[y].color = RED;\r\n  setState([...bars]);\r\n  await sleep(delay);\r\n  bars[x].color = BLUE;\r\n  bars[y].color = BLUE;\r\n  setState([...bars]);\r\n};\r\n\r\nconst heapify = async (\r\n  bars: Bar[],\r\n  n: number,\r\n  i: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  let largest = i;\r\n  const left = 2 * i + 1;\r\n  const right = 2 * i + 2;\r\n\r\n  if (left < n && bars[left].num > bars[largest].num) largest = left;\r\n\r\n  if (right < n && bars[right].num > bars[largest].num) largest = right;\r\n\r\n  if (largest !== i) {\r\n    swap(bars, i, largest);\r\n    await animation(bars, i, largest, setState, delay);\r\n    // recursively heapify sub-tree\r\n    await heapify(bars, n, largest, setState, delay);\r\n  }\r\n};\r\n\r\nexport const heapSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  const n = bars.length;\r\n\r\n  // build max-heap\r\n  for (let i = Math.floor(n / 2 - 1); i >= 0; i--) {\r\n    await heapify(bars, n, i, setState, delay);\r\n  }\r\n\r\n  for (let i = n - 1; i > 0; i--) {\r\n    // Move root to the end\r\n    swap(bars, 0, i, setState);\r\n\r\n    // mark sorted partition\r\n    bars[i].color = RED;\r\n\r\n    // heapify reduced heap\r\n    await heapify(bars, i, 0, setState, delay);\r\n  }\r\n};\r\n","import React, { SetStateAction } from 'react';\r\n\r\nimport { sleep } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN } from '../model/Color';\r\n\r\nexport const insertionSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  const n: number = bars.length;\r\n\r\n  bars[0].color = RED;\r\n\r\n  for (let i = 1; i < n; i++) {\r\n    const value: Bar = bars[i];\r\n    let hole: number = i;\r\n\r\n    bars[hole].color = RED;\r\n\r\n    while (hole > 0 && bars[hole - 1].num > value.num) {\r\n      await sleep(delay);\r\n      bars[hole] = bars[hole - 1];\r\n\r\n      bars[hole].color = GREEN;\r\n      if (hole + 1 < bars.length) bars[hole + 1].color = RED;\r\n\r\n      setState([...bars]);\r\n      hole--;\r\n    }\r\n\r\n    bars[hole].color = RED;\r\n\r\n    bars[hole] = value;\r\n    setState([...bars]);\r\n  }\r\n};\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, BLUE } from '../model/Color';\r\n\r\nconst nextGap = (gap: number): number => (gap <= 1 ? 0 : Math.ceil(gap / 2.0));\r\n\r\nconst animation = async (\r\n  bars: Bar[],\r\n  x: number,\r\n  y: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  bars[x].color = RED;\r\n  bars[y].color = RED;\r\n\r\n  setState([...bars]);\r\n  await sleep(delay);\r\n\r\n  bars[x].color = BLUE;\r\n  bars[y].color = BLUE;\r\n};\r\n\r\n/**\r\n * In-place Merge Sort\r\n *\r\n * Approach 2 from {@link https://www.geeksforgeeks.org/in-place-merge-sort/}.\r\n *\r\n * @param bars The array to be sorted.\r\n * @param start The left index of the array.\r\n * @param end The right index of the array.\r\n * @param setState Hook for changing the state.\r\n * @param delay Time in between each animation.\r\n */\r\nconst inPlaceMerge = async (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  let gap: number = end - start + 1;\r\n\r\n  for (gap = nextGap(gap); gap > 0; gap = nextGap(gap)) {\r\n    for (let i = start; i + gap <= end; i++) {\r\n      const j = i + gap;\r\n      if (bars[i].num > bars[j].num) {\r\n        swap(bars, i, j);\r\n        await animation(bars, i, j, setState, delay);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nconst _sort = async (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  if (start === end) return;\r\n\r\n  const mid = Math.floor((start + end) / 2);\r\n  await _sort(bars, start, mid, setState, delay);\r\n  await _sort(bars, mid + 1, end, setState, delay);\r\n\r\n  await inPlaceMerge(bars, start, end, setState, delay);\r\n};\r\n\r\nexport const mergeSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  await _sort(bars, 0, bars.length - 1, setState, delay);\r\n};\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN, BLUE } from '../model/Color';\r\n\r\nconst animation = async (\r\n  bars: Bar[],\r\n  i: number,\r\n  partitionIndex: number,\r\n  start: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  bars[i].color = GREEN;\r\n  bars[partitionIndex].color = RED;\r\n  setState([...bars]);\r\n  await sleep(delay);\r\n  if (i !== start) {\r\n    // only reset indices after start\r\n    bars[i].color = BLUE;\r\n    bars[partitionIndex].color = BLUE;\r\n  }\r\n};\r\n\r\n/**\r\n * Median of three\r\n *\r\n * Puts the median at the last index of the array and returns the pivot value\r\n *\r\n * @param bars The array to be sorted.\r\n * @param start The left index of the array.\r\n * @param end The right index of the array.\r\n * @returns The pivot value.\r\n */\r\nconst getMedian = (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>\r\n): number => {\r\n  const midpoint: number = Math.floor((start + end) / 2);\r\n  if (bars[start].num > bars[midpoint].num) swap(bars, start, midpoint);\r\n  if (bars[start] > bars[end]) swap(bars, start, end);\r\n  if (bars[midpoint] > bars[end]) swap(bars, midpoint, end);\r\n\r\n  swap(bars, midpoint, end, setState);\r\n  return bars[end].num;\r\n};\r\n\r\nconst partition = async (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<number> => {\r\n  const pivotIndex: number = end;\r\n  const pivot = getMedian(bars, start, end, setState);\r\n  let partitionIndex = start;\r\n\r\n  // Mark pivot\r\n  bars[pivotIndex].color = RED;\r\n  setState([...bars]);\r\n\r\n  for (let i = start; i < end; i++) {\r\n    if (bars[i].num <= pivot) {\r\n      swap(bars, i, partitionIndex, setState);\r\n\r\n      await animation(bars, i, partitionIndex, start, setState, delay);\r\n\r\n      partitionIndex++;\r\n    }\r\n  }\r\n\r\n  // Unmark pivot and starting pointer\r\n  bars[start].color = BLUE;\r\n  bars[pivotIndex].color = BLUE;\r\n  setState([...bars]);\r\n\r\n  swap(bars, partitionIndex, pivotIndex, setState);\r\n  return partitionIndex;\r\n};\r\n\r\nconst _sort = async (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  if (start < end) {\r\n    const partitionIndex: number = await partition(\r\n      bars,\r\n      start,\r\n      end,\r\n      setState,\r\n      delay\r\n    );\r\n    await _sort(bars, start, partitionIndex - 1, setState, delay);\r\n    await _sort(bars, partitionIndex + 1, end, setState, delay);\r\n  }\r\n};\r\n\r\nexport const quicksort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  await _sort(bars, 0, bars.length - 1, setState, delay);\r\n};\r\n","import React, { SetStateAction } from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN, BLUE } from '../model/Color';\r\n\r\nexport const selectionSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  const n: number = bars.length;\r\n  for (let i = 0; i < n - 1; i++) {\r\n    let iMin: number = i;\r\n    for (let j: number = i + 1; j < n; j++) {\r\n      if (bars[j].num < bars[iMin].num) iMin = j;\r\n\r\n      if (j === n - 1) {\r\n        // Mark the smallest element in the unsorted array\r\n        bars[iMin].color = GREEN;\r\n        setState([...bars]);\r\n      }\r\n    }\r\n\r\n    swap(bars, i, iMin);\r\n\r\n    await sleep(delay);\r\n    bars[iMin].color = BLUE; // Unmark\r\n    bars[i].color = RED;\r\n    setState([...bars]);\r\n  }\r\n\r\n  // manually make last element red cause yeah\r\n  bars[bars.length - 1].color = RED;\r\n  setState([...bars]);\r\n};\r\n","import { Bar } from '../model/Bar';\r\nimport { bubbleSort } from './BubbleSort';\r\nimport { cocktailSort } from './CocktailSort';\r\nimport { heapSort } from './HeapSort';\r\nimport { insertionSort } from './InsertionSort';\r\nimport { mergeSort } from './MergeSort';\r\nimport { quicksort } from './QuickSort';\r\nimport { selectionSort } from './SelectionSort';\r\n\r\ntype sortingFunc = (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n) => Promise<void>;\r\n\r\nexport const getSortingAlgorithm = (algorithm: string): sortingFunc => {\r\n  if (algorithm === 'selection') return selectionSort;\r\n  else if (algorithm === 'insertion') return insertionSort;\r\n  else if (algorithm === 'bubble') return bubbleSort;\r\n  else if (algorithm === 'quick') return quicksort;\r\n  else if (algorithm === 'merge') return mergeSort;\r\n  else if (algorithm === 'cocktail') return cocktailSort;\r\n  else if (algorithm === 'heap') return heapSort;\r\n  else throw new Error('Incorrect type for sorting algorithm');\r\n};\r\n","import React, { SetStateAction } from 'react';\r\n\r\nimport { Button } from 'react-bootstrap';\r\n\r\nimport { Bar } from '../../core/model/Bar';\r\n\r\ninterface Props {\r\n  num: number;\r\n  handleNumberChange: (e: React.ChangeEvent<HTMLInputElement>) => void;\r\n  sort: () => Promise<void>;\r\n  reset: () => void;\r\n  setBars: React.Dispatch<SetStateAction<Bar[]>>;\r\n  delay: number;\r\n  setDelay: React.Dispatch<SetStateAction<number>>;\r\n}\r\n\r\nexport const Panel: React.FC<Props> = ({\r\n  num,\r\n  handleNumberChange,\r\n  sort,\r\n  reset,\r\n  delay,\r\n  setDelay,\r\n}: Props) => {\r\n  const renderRangeSlider = (): JSX.Element => (\r\n    <label className=\"mx-2\" style={{ width: '10%', textAlign: 'left' }}>\r\n      Delay\r\n      <input\r\n        name=\"foo\"\r\n        type=\"range\"\r\n        min=\"1\"\r\n        max=\"100\"\r\n        value={delay}\r\n        className=\"slider\"\r\n        onChange={(e) => setDelay(parseInt(e.target.value))}\r\n      />\r\n    </label>\r\n  );\r\n\r\n  return (\r\n    <span>\r\n      {renderRangeSlider()}\r\n      <input\r\n        className=\"input-number\"\r\n        name=\"no. bars\"\r\n        type=\"number\"\r\n        value={num}\r\n        step={5}\r\n        min=\"5\"\r\n        max=\"150\"\r\n        onChange={handleNumberChange}\r\n        onKeyDown={(e) => e.preventDefault()}\r\n      />\r\n      <Button onClick={reset} className=\"mx-2\" variant=\"danger\">\r\n        Reset\r\n      </Button>\r\n      <Button onClick={sort}>Sort</Button>\r\n    </span>\r\n  );\r\n};\r\n","import React, { useState, useEffect } from 'react';\r\n\r\nimport './SortingVisualizer.css';\r\nimport { Col, Container, Row } from 'react-bootstrap';\r\n\r\nimport { Bar } from '../../core/model/Bar';\r\nimport { BLUE, GREEN } from '../../core/model/Color';\r\nimport { getSortingAlgorithm } from '../../core/sorting/SortingFactory';\r\nimport { sleep } from '../../utils';\r\nimport { AlgorithmButtonGroup } from '../common/AlgorithmButtonGroup';\r\nimport { Panel } from './Panel';\r\n\r\nconst algorithms = [\r\n  { name: 'Insertion Sort', value: 'insertion' },\r\n  { name: 'Selection Sort', value: 'selection' },\r\n  { name: 'Bubble Sort', value: 'bubble' },\r\n  { name: 'Quicksort', value: 'quick' },\r\n  { name: 'Merge Sort', value: 'merge' },\r\n  { name: 'Cocktail Sort', value: 'cocktail' },\r\n  { name: 'Heap Sort', value: 'heap' },\r\n];\r\n\r\nexport const SortingVisualizer: React.FC = () => {\r\n  const [bars, setBars] = useState<Bar[]>([]);\r\n  const [num, setNum] = useState<number>(90);\r\n  const [algorithm, setAlgorithm] = useState<string>('insertion');\r\n  const [delay, setDelay] = useState<number>(1);\r\n\r\n  const resetBars = (): void =>\r\n    setBars(\r\n      [...Array(num)].map(() => ({\r\n        num: Math.floor(Math.random() * 80) + 1,\r\n        color: BLUE,\r\n      }))\r\n    );\r\n\r\n  useEffect((): void => {\r\n    resetBars();\r\n  }, [num]); // eslint-disable-line react-hooks/exhaustive-deps\r\n\r\n  // Green progressive animation\r\n  const finish = async (\r\n    bars: Bar[],\r\n    setState: React.Dispatch<React.SetStateAction<Bar[]>>\r\n  ): Promise<void> => {\r\n    for (let i = 0; i < bars.length; i++) {\r\n      bars[i].color = GREEN;\r\n      setState([...bars]);\r\n      await sleep(1);\r\n    }\r\n  };\r\n\r\n  const sort = async (): Promise<void> => {\r\n    const sorter = getSortingAlgorithm(algorithm);\r\n    await sorter(bars, setBars, delay);\r\n    await finish(bars, setBars);\r\n  };\r\n\r\n  const handleNumberChange = (e: React.ChangeEvent<HTMLInputElement>): void => {\r\n    const { value, min, max } = e.target;\r\n    setNum(Math.max(Number(min), Math.min(Number(max), Number(value))));\r\n  };\r\n\r\n  const renderBars = (): JSX.Element => (\r\n    <div className=\"sorting-container\">\r\n      {bars.map((bar: Bar, idx) => (\r\n        <div\r\n          key={`b-${idx}`}\r\n          className=\"bar\"\r\n          style={{\r\n            backgroundColor: `${bar.color}`,\r\n            width: '1vw',\r\n            height: `${bar.num}vmin`,\r\n          }}\r\n        />\r\n      ))}\r\n    </div>\r\n  );\r\n\r\n  return (\r\n    <Container fluid={true} style={{ padding: '0' }}>\r\n      <Row className=\"app-vanish text-center justify-content-center\">\r\n        <Col md=\"auto\">\r\n          <Panel\r\n            num={num}\r\n            handleNumberChange={handleNumberChange}\r\n            reset={resetBars}\r\n            setBars={setBars}\r\n            sort={sort}\r\n            delay={delay}\r\n            setDelay={setDelay}\r\n          />\r\n          <AlgorithmButtonGroup\r\n            defaultAlgorithm={algorithm}\r\n            algorithms={algorithms}\r\n            setAlgorithm={setAlgorithm}\r\n          />\r\n        </Col>\r\n      </Row>\r\n      <Row className=\"justify-content-center\">\r\n        <Col md=\"auto\">{renderBars()}</Col>\r\n      </Row>\r\n    </Container>\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport './App.css';\r\nimport { HashRouter as Router, Switch, Route } from 'react-router-dom';\r\n\r\nimport { Header } from './components/common/Header';\r\nimport { PathfindingVisualizer } from './components/pathfinding/PathfindingVisualizer';\r\nimport { SortingVisualizer } from './components/sorting/SortingVisualizer';\r\n\r\nconst App = (): JSX.Element => {\r\n  return (\r\n    <Router>\r\n      <Header />\r\n      <Switch>\r\n        <Route exact path={['/', '/sorting']} component={SortingVisualizer} />\r\n        <Route path=\"/pathfinding\" component={PathfindingVisualizer} />\r\n      </Switch>\r\n    </Router>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from 'react';\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}