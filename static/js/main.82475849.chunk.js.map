{"version":3,"sources":["components/common/Header.tsx","assets/github.png","utils/Sleep.ts","utils/Array.ts","utils/Path.ts","utils/Coordinates.ts","utils/Random.ts","utils/Maze.ts","core/maze/BinaryTree.ts","core/maze/Eller.ts","core/maze/Kruskal.ts","core/maze/Prim.ts","core/maze/RecursiveBacktracking.ts","core/maze/RecursiveDivision.ts","core/maze/MazeFactory.ts","core/pathfinding/Astar.ts","core/pathfinding/Bidirectional.ts","core/pathfinding/UCS.ts","core/pathfinding/PathfindingFactory.ts","components/common/AlgorithmButtonGroup.tsx","components/pathfinding/CellButton.tsx","components/pathfinding/Grid.tsx","components/pathfinding/Popover.tsx","components/pathfinding/Panel.tsx","components/pathfinding/PathfindingVisualizer.tsx","core/model/Color.ts","core/sorting/BubbleSort.ts","core/sorting/CocktailSort.ts","core/sorting/HeapSort.ts","core/sorting/InsertionSort.ts","core/sorting/MergeSort.ts","core/sorting/QuickSort.ts","core/sorting/SelectionSort.ts","core/sorting/SortingFactory.ts","components/sorting/Panel.tsx","components/sorting/SortingVisualizer.tsx","App.tsx","index.tsx"],"names":["Header","Navbar","expand","bg","variant","className","Container","Brand","href","OverlayTrigger","placement","overlay","Tooltip","id","src","alt","Toggle","aria-controls","Collapse","Nav","Link","as","to","sleep","delay","Promise","resolve","setTimeout","swap","arr","x","y","setState","extractPath","entry","path","pqe","unshift","coord","backPointer","console","log","length","reversePath","prev","current","next","Error","mergePath","pqe1","pqe2","yDir","xDir","adjacentCoords","c","n","m","offset","coords","i","row","col","push","isSameCoord","c1","c2","alignmentBetweenCoordinates","p","q","Math","max","min","closestOddCoord","randomNumber","floor","random","randomOddCoordinates","popRandomElementFromSet","set","size","rs","Array","from","values","delete","markAllCellsAsWalls","grid","setGrid","isWall","carveHorizontaly","a","carveVertically","carvePassageBetweenAdjacentCoordinates","alignment","BinaryTree","dirs","dir","coinflip","populate","sets","Set","_mergeSets","set1","set2","merged","forEach","value","add","mergeSets","val","index","removeRandomElements","s","horizontalConnections","verticalConnections","unique","nextRow","fill","Eller","Tree","parent","this","root","tree","setOfPossibleEdges","edges","Kruskal","isConnected","connect","passages","filter","mark","frontier","walls","item","Prim","startCoord","neighbours","shuffle","array","temp","j","carvePassagesFrom","visited","RecursiveBacktracking","addHWall","minX","maxX","hole","isStart","isFinish","addVWall","minY","maxY","addOuterWalls","divideHorizontally","divide","divideVertically","RecursiveDivision","getMazeAlgorithm","algorithmType","manhattanDistance","abs","fudge","crossProduct","start","dx1","dy1","dx2","dy2","cross","guessCost","heuristic","astar","goal","pq","PriorityQueue","comparator","p1","p2","costToHere","queue","dequeue","success","isActive","costToNext","Bidirectional","originalPqueue","pqueue","visitedR","pqueueR","entryR","mergedPQEntry","UCS","getPathfindingAlgorithm","algorithm","AlgorithmButtonGroup","defaultAlgorithm","algorithms","setAlgorithm","ButtonGroup","map","alg","ToggleButton","type","checked","onChange","e","currentTarget","name","cellColor","cell","isPath","cssAnimation","CellButton","mouseDown","onMouseDown","onMouseEnter","onMouseUp","Button","style","backgroundColor","Grid","mode","setMode","setStart","finish","setFinish","searching","React","useState","setMouseDown","toggleWall","handleMouseUp","handleMouseDown","handleMouseEnter","moveFinish","moveStart","background","border","outline","display","height","width","cursor","marginBottom","onClick","onMouseLeave","popover","Popover","Title","Content","Panel","heuristics","setHeuristic","resetGrid","removePath","search","mazes","generateMaze","DropdownButton","title","menuAlign","Dropdown","Item","SplitButton","toggleLabel","alignRight","charAt","toUpperCase","slice","disabled","h","newGrid","noHorizontalCells","window","innerWidth","noVerticalCells","innerHeight","calculateCells","_","drawPath","res","PathfindingVisualizer","setSearching","searcher","then","relocateStartAndFinishToOddCoords","newStart","newFinish","mazeGenerator","fluid","padding","Row","Col","md","RED","BLUE","GREEN","animation","bars","color","bubbleSort","greatestElementIndex","num","cocktailSort","swapped","end","heapify","largest","right","left","heapSort","insertionSort","nextGap","gap","ceil","inPlaceMerge","_sort","mid","mergeSort","partitionIndex","getMedian","midpoint","partition","pivotIndex","pivot","quicksort","selectionSort","iMin","getSortingAlgorithm","handleNumberChange","sort","reset","setDelay","textAlign","parseInt","target","step","onKeyDown","preventDefault","SortingVisualizer","setBars","setNum","resetBars","useEffect","sorter","Number","bar","idx","App","component","exact","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.82475849.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nimport {\r\n  Container,\r\n  Nav,\r\n  Navbar,\r\n  OverlayTrigger,\r\n  Tooltip,\r\n} from 'react-bootstrap';\r\nimport { Link } from 'react-router-dom';\r\n\r\nimport logo from '../../assets/github.png';\r\n\r\nexport const Header = (): JSX.Element => {\r\n  return (\r\n    <Navbar expand=\"md\" bg=\"dark\" variant=\"dark\" className=\"app-vanish\">\r\n      <Container>\r\n        <Navbar.Brand href=\"https://github.com/Puh00/algorithm-visualizer\">\r\n          <OverlayTrigger\r\n            placement=\"bottom\"\r\n            overlay={<Tooltip id=\"tip\">View Project</Tooltip>}\r\n          >\r\n            <img src={logo} alt=\"github logo\" />\r\n          </OverlayTrigger>\r\n        </Navbar.Brand>\r\n        <Navbar.Toggle aria-controls=\"basic-navbar-nav\" />\r\n        <Navbar.Collapse id=\"basic-navbar-nav\">\r\n          <Nav className=\"me-auto\">\r\n            <Nav.Link as={Link} to=\"/sorting\">\r\n              Sorting\r\n            </Nav.Link>\r\n            <Nav.Link as={Link} to=\"/pathfinding\">\r\n              Pathfinding\r\n            </Nav.Link>\r\n          </Nav>\r\n        </Navbar.Collapse>\r\n      </Container>\r\n    </Navbar>\r\n  );\r\n};\r\n","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RERCMUIwOUY4NkNFMTFFM0FBNTJFRTMzNTJEMUJDNDYiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RERCMUIwOUU4NkNFMTFFM0FBNTJFRTMzNTJEMUJDNDYiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU1MTc4QTJBOTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU1MTc4QTJCOTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+jUqS1wAAApVJREFUeNq0l89rE1EQx3e3gVJoSPzZeNEWPKgHoa0HBak0iHiy/4C3WvDmoZ56qJ7txVsPQu8qlqqHIhRKJZceesmhioQEfxTEtsoSpdJg1u/ABJ7Pmc1m8zLwgWTmzcw3L+/te+tHUeQltONgCkyCi2AEDHLsJ6iBMlgHL8FeoqokoA2j4CloRMmtwTmj7erHBXPgCWhG6a3JNXKdCiDl1cidVbXZkJoXQRi5t5BrxwoY71FzU8S4JuAIqFkJ2+BFSlEh525b/hr3+k/AklDkNsf6wTT4yv46KIMNpsy+iMdMc47HNWxbsgVcUn7FmLAzzoFAWDsBx+wVP6bUpp5ewI+DOeUx0Wd9D8F70BTGNjkWtqnhmT1JQAHcUgZd8Lo3rQb1LAT8eJVUfgGvHQigGp+V2Z0iAUUl8QH47kAA1XioxIo+bRN8OG8F/oBjwv+Z1nJgX5jpdzQDw0LCjsPmrcW7I/iHScCAEDj03FtD8A0EyuChHgg4KTlJQF3wZ7WELppnBX+dBFSVpJsOBWi1qiRgSwnOgoyD5hmuJdkWCVhTgnTvW3AgYIFrSbZGh0UW/Io5Vp+DQoK7o80pztWMemZbgxeNwCNwDbw1fIfgGZjhU6xPaJgBV8BdsMw5cbZoHsenwYFxkZzl83xTSKTiviCAfCsJLysH3POfC8m8NegyGAGfLP/VmGmfSChgXroR0RSWjEFv2J/nG84cuKFMf4sTCZqXuJd4KaXFVjEG3+tw4eXbNK/YC9oXXs3O8NY8y99L4BXY5cvLY/Bb2VZ58EOJVcB18DHJq9lRsKr8inyKGVjlmh29mtHs3AHfuhCwy1vXT/Nu2GKQt+UHsGdctyX6eQyNvc+5sfX9Dl7Pe2J/BRgAl2CpwmrsHR0AAAAASUVORK5CYII=\"","export const sleep = (delay: number): Promise<void> =>\r\n  new Promise((resolve) => setTimeout(resolve, delay));\r\n","export const swap = <T>(\r\n  arr: T[],\r\n  x: number,\r\n  y: number,\r\n  setState?: React.Dispatch<React.SetStateAction<T[]>>\r\n): void => {\r\n  [arr[y], arr[x]] = [arr[x], arr[y]];\r\n  if (setState) setState([...arr]);\r\n};\r\n","import { Coord } from '../core/model/Cell';\r\nimport { PQEntry } from '../core/model/PQEntry';\r\n\r\n/**\r\n * Extract the full path from start to goal\r\n * @param entry the final priority queue entry\r\n * @returns the path from start to goal as a list of cells\r\n */\r\nexport const extractPath = (entry: PQEntry): Coord[] => {\r\n  const path = [];\r\n  let pqe: PQEntry | null = entry;\r\n  while (pqe !== null) {\r\n    path.unshift(pqe.coord);\r\n    pqe = pqe.backPointer;\r\n  }\r\n  console.log(path.length);\r\n  return path;\r\n};\r\n\r\n// essentially reverse a linked list\r\nexport const reversePath = (entry: PQEntry): PQEntry => {\r\n  let prev: PQEntry | null = null;\r\n  let current: PQEntry | null = entry;\r\n  let next: PQEntry | null = null;\r\n  while (current != null) {\r\n    next = current.backPointer;\r\n    current.backPointer = prev;\r\n    prev = current;\r\n    current = next;\r\n  }\r\n  if (prev === null) throw new Error(\"Couldn't reverse path\");\r\n  return prev;\r\n};\r\n\r\n/**\r\n * Merges two PQEntries.\r\n * @param pqe1 First PQEntry.\r\n * @param pqe2 Second PQEntry.\r\n * @returns a merged PQEntry.\r\n */\r\nexport const mergePath = (pqe1: PQEntry, pqe2: PQEntry): PQEntry => {\r\n  // traverse to head\r\n  let pqe: PQEntry = pqe2;\r\n  while (pqe.backPointer !== null) pqe = pqe.backPointer;\r\n  // link together the PQEntries\r\n  pqe.backPointer = pqe1;\r\n  return pqe2;\r\n};\r\n","import { Coord } from '../core/model/Cell';\r\n\r\n// Direction vectors: [Up, Right, Down, Left]\r\nconst yDir = [-1, 0, 1, 0];\r\nconst xDir = [0, 1, 0, -1];\r\n\r\n/**\r\n * Retrieves adjacent coordinates that shares a border with the given coordinate.\r\n * @param c the coordinate to evaluate.\r\n * @param n the height of the grid.\r\n * @param m the width of the grid.\r\n * @param offset by default, the function will only give neighbours that are 1 unit away.\r\n * @returns adjacent coordinates that are within bounds.\r\n */\r\nexport const adjacentCoords = (\r\n  c: Coord,\r\n  n: number,\r\n  m: number,\r\n  offset = 1\r\n): Coord[] => {\r\n  const coords: Coord[] = [];\r\n  for (let i = 0; i < 4; i++) {\r\n    const row = c.y + yDir[i] * offset;\r\n    const col = c.x + xDir[i] * offset;\r\n    if (row >= 0 && col >= 0 && row < n && col < m) {\r\n      coords.push({ x: col, y: row });\r\n    }\r\n  }\r\n  return coords;\r\n};\r\n\r\n// Since Typescript compare by references...\r\nexport const isSameCoord = (c1: Coord, c2: Coord): boolean =>\r\n  c1.x === c2.x && c1.y === c2.y;\r\n\r\ntype dir = 'HORIZONTAL' | 'VERTICAL';\r\n\r\n/**\r\n * Calculates the alignement between two coordinates.\r\n * @param p the first coordinate.\r\n * @param q the second coordinate.\r\n * @throws will throw an error if the coordinates are neither vertically or\r\n * horizontally aligned\r\n * @returns the alignment between the coordinates.\r\n */\r\nexport const alignmentBetweenCoordinates = (p: Coord, q: Coord): dir => {\r\n  if (Math.max(p.y, q.y) - Math.min(p.y, q.y) === 0) return 'HORIZONTAL';\r\n  else if (Math.max(p.x, q.x) - Math.min(p.x, q.x) === 0) return 'VERTICAL';\r\n  else throw new Error('Neither horizontally or vertically aligned');\r\n};\r\n\r\n/**\r\n * If {p} is not located at odd coordinates, modify it so that the coordinates are odd.\r\n * @param p the coordinates.\r\n * @returns odd coordinates.\r\n */\r\nexport const closestOddCoord = (p: Coord): Coord => {\r\n  if (p.x < 0 || p.y < 0) throw new Error('Invalid negative coordinate');\r\n  const x = p.x % 2 !== 0 ? p.x : p.x - 1 < 1 ? p.x + 1 : p.x - 1;\r\n  const y = p.y % 2 !== 0 ? p.y : p.y - 1 < 1 ? p.y + 1 : p.y - 1;\r\n  return { x, y };\r\n};\r\n","import { Coord } from '../core/model/Cell';\r\n\r\n// inclusive: [min, max]\r\nexport const randomNumber = (min: number, max: number): number =>\r\n  Math.floor(Math.random() * (max - min + 1) + min);\r\n\r\n/**\r\n * Produces a random odd coordinate within the bounds of the given paramters\r\n * @param n Vertical size.\r\n * @param m Horizontal size.\r\n * @returns a random odd coordinate.\r\n */\r\nexport const randomOddCoordinates = (n: number, m: number): Coord => {\r\n  const x = randomNumber(2, m - 1);\r\n  const y = randomNumber(2, n - 1);\r\n  return { x: x % 2 === 0 ? x - 1 : x, y: y % 2 === 0 ? y - 1 : y };\r\n};\r\n\r\n/**\r\n * Removes a random element from the set and returns that object as the\r\n * value of this function\r\n * @param set the set to pick a random element from.\r\n * @throws will throw an error if the set is empty.\r\n * @returns the randomly picked element.\r\n */\r\nexport const popRandomElementFromSet = <T>(set: Set<T>): T => {\r\n  if (set.size === 0) throw new Error('Empty Set');\r\n  const rs = Array.from(set.values())[Math.floor(Math.random() * set.size)];\r\n  set.delete(rs);\r\n  return rs;\r\n};\r\n","import { alignmentBetweenCoordinates, sleep } from '.';\r\nimport { Cell, Coord } from '../core/model/Cell';\r\n\r\n/**\r\n * Convert each cell in the grid to a wall.\r\n * @param grid the grid that has the state of every cell.\r\n * @param setGrid react hook to update the state of the grid.\r\n */\r\nexport const markAllCellsAsWalls = (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): void => {\r\n  for (let row = 0; row < grid.length; row++) {\r\n    for (let col = 0; col < grid[0].length; col++) {\r\n      grid[row][col].isWall = true;\r\n    }\r\n  }\r\n  setGrid([...grid]);\r\n};\r\n\r\n/**\r\n * Carves to the right from the given coordinate.\r\n * @param grid the grid to carve upon.\r\n * @param x x coordinate.\r\n * @param y y coordinate.\r\n * @param setGrid react hook to update the state of the grid.\r\n */\r\nexport const carveHorizontaly = async (\r\n  grid: Cell[][],\r\n  x: number,\r\n  y: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  for (let i = 0; i < 3; i++) grid[y][x + i].isWall = false;\r\n  setGrid([...grid]);\r\n  await sleep(1);\r\n};\r\n\r\n/**\r\n * Carves downwards from the given coordinate.\r\n * @param grid the grid to carve upon.\r\n * @param x x coordinate.\r\n * @param y y coordinate.\r\n * @param setGrid react hook to update the state of the grid.\r\n */\r\nexport const carveVertically = async (\r\n  grid: Cell[][],\r\n  x: number,\r\n  y: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  for (let i = 0; i < 3; i++) grid[y + i][x].isWall = false;\r\n  setGrid([...grid]);\r\n  await sleep(1);\r\n};\r\n\r\n/**\r\n * Carve a passage between two coordinates if and only if they are adjacent\r\n * and vertically or horizontally aligned.\r\n * @param p starting coordinate.\r\n * @param q target coordinate.\r\n * @param grid the grid to carve upon.\r\n * @param setGrid react hook to update the state.\r\n */\r\nexport const carvePassageBetweenAdjacentCoordinates = async (\r\n  p: Coord,\r\n  q: Coord,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  const alignment = alignmentBetweenCoordinates(p, q);\r\n  if (alignment === 'HORIZONTAL')\r\n    // current cell and neighbour are horizontally aligned\r\n    await carveHorizontaly(grid, Math.min(p.x, q.x), p.y, setGrid);\r\n  else if (alignment === 'VERTICAL')\r\n    // ...vertically aligned\r\n    await carveVertically(grid, p.x, Math.min(p.y, q.y), setGrid);\r\n};\r\n","import {\r\n  carveHorizontaly,\r\n  carveVertically,\r\n  markAllCellsAsWalls,\r\n  randomNumber,\r\n} from '../../utils';\r\nimport { Cell } from '../model/Cell';\r\n\r\n// Binary Tree with Southeast bias\r\nexport const BinaryTree = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n\r\n  for (let row = 1; row < grid.length; row++) {\r\n    if (row % 2 === 0) continue;\r\n    for (let col = 1; col < grid[0].length; col++) {\r\n      if (col % 2 === 0) continue;\r\n      const dirs: string[] = [];\r\n      // if within bounds add the direction\r\n      if (col + 2 < grid[0].length - 1) dirs.push('EAST');\r\n      if (row + 2 < grid.length - 1) dirs.push('SOUTH');\r\n\r\n      const dir = dirs[randomNumber(0, dirs.length - 1)];\r\n      if (dir === 'EAST') await carveHorizontaly(grid, col, row, setGrid);\r\n      else if (dir === 'SOUTH') await carveVertically(grid, col, row, setGrid);\r\n    }\r\n  }\r\n};\r\n","import {\r\n  carveHorizontaly,\r\n  carveVertically,\r\n  markAllCellsAsWalls,\r\n  popRandomElementFromSet,\r\n} from '../../utils';\r\nimport { Cell } from '../model/Cell';\r\n\r\nconst coinflip = (): boolean => Math.random() > 0.5;\r\n\r\n/**\r\n * Replaces all of the null values in the current row with a new set\r\n * @param sets the array containing the sets of the current row.\r\n */\r\nconst populate = (sets: Array<Set<number> | null>): void => {\r\n  for (let i = 1; i < sets.length; i += 2) if (!sets[i]) sets[i] = new Set([i]);\r\n};\r\n\r\nconst _mergeSets = (\r\n  set1: Set<number> | null,\r\n  set2: Set<number> | null\r\n): Set<number> => {\r\n  if (!set1 || !set2) throw new Error(\"Can't merge undefined sets\");\r\n  const merged: Set<number> = new Set();\r\n  set1.forEach((value) => merged.add(value));\r\n  set2.forEach((value) => merged.add(value));\r\n  return merged;\r\n};\r\n\r\n/**\r\n * Merge two sets if and only if they are disjoint.\r\n *\r\n * Also updates previous sets to match with the newly merged set.\r\n *\r\n * @param sets the array containing the sets of the current row.\r\n * @param set1 the first coordinate's set.\r\n * @param set2 the second coordinate's set.\r\n * @param col x coordinate.\r\n * @param row y coordinate.\r\n * @param grid the grid to work with.\r\n * @param setGrid react hook to update the state of the grid.\r\n */\r\nconst mergeSets = async (\r\n  sets: Array<Set<number> | null>,\r\n  set1: Set<number> | null,\r\n  set2: Set<number> | null,\r\n  col: number,\r\n  row: number,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  if (set1 === set2) return;\r\n  const merged = _mergeSets(set1, set2);\r\n  [sets[col], sets[col + 2]] = [merged, merged];\r\n  // manually update earlier identical sets\r\n  sets.forEach((val, index) => {\r\n    if (val === set1 || val === set2) sets[index] = merged;\r\n  });\r\n  await carveHorizontaly(grid, col, row, setGrid);\r\n};\r\n\r\n/**\r\n * For each element in the set, randomly decide whether to remove it or not.\r\n * Ensures that there is at least one element left in the set.\r\n * @param s the set to manipulate.\r\n */\r\nconst removeRandomElements = (s: Set<number> | null): void => {\r\n  if (!s) throw new Error(\"Can't pop undefined set\");\r\n  for (let i = s.size; i > 1; i--) if (coinflip()) popRandomElementFromSet(s);\r\n};\r\n\r\nconst horizontalConnections = async (\r\n  sets: Array<Set<number> | null>,\r\n  row: number,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  for (let col = 1; col < grid[0].length; col += 2) {\r\n    // skip if out of bounds\r\n    if (!grid[row][col + 2]) continue;\r\n\r\n    const [set1, set2] = [sets[col], sets[col + 2]];\r\n\r\n    if (row !== grid.length - 2) {\r\n      if (coinflip())\r\n        // randomly join adjacent cells, given that they are disjoint\r\n        await mergeSets(sets, set1, set2, col, row, grid, setGrid);\r\n    }\r\n    // last row, connect all adjacent disjoint sets\r\n    else await mergeSets(sets, set1, set2, col, row, grid, setGrid);\r\n  }\r\n};\r\n\r\n/**\r\n * Randomly create vertical connections downward to the next row\r\n *\r\n * @param sets the array containing the state of the current row.\r\n * @param row y coordinate.\r\n * @param grid the grid to work with.\r\n * @param setGrid react hook to update the state of the grid.\r\n * @returns the sets in the next row.\r\n */\r\nconst verticalConnections = async (\r\n  sets: Array<Set<number> | null>,\r\n  row: number,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<Array<Set<number> | null>> => {\r\n  const unique = [...new Set(sets)];\r\n  for (let i = 1; i < unique.length; i++) removeRandomElements(unique[i]);\r\n\r\n  const nextRow: Array<Set<number> | null> = Array(grid[0].length).fill(null);\r\n\r\n  for (let i = 1; i < unique.length; i++) {\r\n    const set = unique[i];\r\n    if (!set) throw new Error('Undefined set');\r\n    for (const col of set) {\r\n      await carveVertically(grid, col, row, setGrid);\r\n      nextRow[col] = set;\r\n    }\r\n  }\r\n  return nextRow;\r\n};\r\n\r\nexport const Eller = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n  const [n, m] = [grid.length, grid[0].length];\r\n\r\n  // each cell in the row belongs to a set\r\n  // cells that share a set, also shares a path\r\n  let sets: Array<Set<number> | null> = Array(m).fill(null);\r\n\r\n  for (let row = 1; row < n; row += 2) {\r\n    // give undiscovered cells from previous iteration a set\r\n    populate(sets);\r\n\r\n    await horizontalConnections(sets, row, grid, setGrid);\r\n    // last row: skip creating vertical connections at the bottom of the grid\r\n    if (row === n - 2) return;\r\n    sets = await verticalConnections(sets, row, grid, setGrid);\r\n  }\r\n};\r\n","import {\r\n  carvePassageBetweenAdjacentCoordinates,\r\n  markAllCellsAsWalls,\r\n  popRandomElementFromSet,\r\n} from '../../utils';\r\nimport { Cell, Coord } from '../model/Cell';\r\n\r\ninterface Edge {\r\n  p: Coord;\r\n  q: Coord;\r\n}\r\n\r\n// Simple Tree data structure to see if two \"sets\" are disjoint\r\nclass Tree {\r\n  parent: Tree | undefined;\r\n\r\n  root(): Tree {\r\n    return this.parent ? this.parent.root() : this;\r\n  }\r\n\r\n  isConnected(tree: Tree): boolean {\r\n    return this.root() === tree.root();\r\n  }\r\n\r\n  connect(tree: Tree): void {\r\n    tree.root().parent = this;\r\n  }\r\n}\r\n\r\n// Returns a set of all possible edges in the given grid\r\nconst setOfPossibleEdges = (grid: Cell[][]): Set<Edge> => {\r\n  const edges = new Set<Edge>();\r\n  for (let row = 1; row < grid.length; row++) {\r\n    if (row % 2 === 0) continue;\r\n    for (let col = 1; col < grid[0].length; col++) {\r\n      if (col % 2 === 0) continue;\r\n      const x = col + 2;\r\n      const y = row + 2;\r\n      // East neighbour\r\n      if (x < grid[0].length - 1)\r\n        edges.add({ p: { x: col, y: row }, q: { x: x, y: row } });\r\n      // South neighbour\r\n      if (y < grid.length - 1)\r\n        edges.add({ p: { x: col, y: row }, q: { x: col, y } });\r\n    }\r\n  }\r\n  return edges;\r\n};\r\n\r\nexport const Kruskal = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n\r\n  // each cell is assigned a set to indicate who they belong to\r\n  const sets: Tree[][] = Array.from(Array(grid.length), () =>\r\n    Array.from(Array(grid[0].length), () => new Tree())\r\n  );\r\n\r\n  const edges = setOfPossibleEdges(grid);\r\n\r\n  while (edges.size !== 0) {\r\n    const { p, q } = popRandomElementFromSet(edges);\r\n    const [set1, set2] = [sets[p.y][p.x], sets[q.y][q.x]];\r\n    if (!set1.isConnected(set2)) {\r\n      set1.connect(set2);\r\n      await carvePassageBetweenAdjacentCoordinates(p, q, grid, setGrid);\r\n    }\r\n  }\r\n};\r\n","import {\r\n  adjacentCoords,\r\n  carvePassageBetweenAdjacentCoordinates,\r\n  markAllCellsAsWalls,\r\n  popRandomElementFromSet,\r\n  randomNumber,\r\n  randomOddCoordinates,\r\n} from '../../utils';\r\nimport { Cell, Coord } from '../model/Cell';\r\n\r\n// Retrieves adjacent coordinates that are passages\r\nconst passages = (grid: Cell[][], c: Coord): Coord[] => {\r\n  return adjacentCoords(c, grid.length, grid[0].length, 2).filter(\r\n    (coord) => !grid[coord.y][coord.x].isWall\r\n  );\r\n};\r\n\r\n// Retrieves adjacent coordinates that are walls\r\nconst walls = (grid: Cell[][], c: Coord): Coord[] => {\r\n  return adjacentCoords(c, grid.length, grid[0].length, 2).filter(\r\n    (coord) => grid[coord.y][coord.x].isWall\r\n  );\r\n};\r\n\r\n// Add walls adjacent to the given coordinate, whilst also removing it\r\nconst mark = (coord: Coord, grid: Cell[][], frontier: Set<Coord>): void => {\r\n  walls(grid, coord).forEach((item) => frontier.add(item));\r\n  frontier.delete(coord);\r\n};\r\n\r\nexport const Prim = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n\r\n  const startCoord = randomOddCoordinates(grid.length, grid[0].length);\r\n  const frontier = new Set<Coord>();\r\n\r\n  // need to mark the first cell as path manually otherwise it's gonna crash\r\n  grid[startCoord.y][startCoord.x].isWall = false;\r\n  mark(startCoord, grid, frontier);\r\n\r\n  while (frontier.size !== 0) {\r\n    const p = popRandomElementFromSet(frontier);\r\n\r\n    // Skip if it has already been converted to a path\r\n    if (!grid[p.y][p.x].isWall) continue;\r\n\r\n    const neighbours = passages(grid, p);\r\n    if (neighbours.length !== 0) {\r\n      const q = neighbours[randomNumber(0, neighbours.length - 1)];\r\n      await carvePassageBetweenAdjacentCoordinates(p, q, grid, setGrid);\r\n    }\r\n    mark(p, grid, frontier);\r\n  }\r\n};\r\n","import React from 'react';\r\n\r\nimport {\r\n  adjacentCoords,\r\n  carvePassageBetweenAdjacentCoordinates,\r\n  markAllCellsAsWalls,\r\n  randomOddCoordinates,\r\n} from '../../utils';\r\nimport { Cell } from '../model/Cell';\r\n\r\nexport const shuffle = <T>(array: T[]): T[] => {\r\n  const temp = [...array];\r\n  for (let i = temp.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [temp[i], temp[j]] = [temp[j], temp[i]]; // shorthand for swap\r\n  }\r\n  return temp;\r\n};\r\n\r\nconst carvePassagesFrom = async (\r\n  x: number,\r\n  y: number,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const neighbours = shuffle(\r\n    adjacentCoords({ x, y }, grid.length, grid[0].length, 2)\r\n  );\r\n  visited[y][x] = true;\r\n\r\n  for (const n of neighbours) {\r\n    if (!visited[n.y][n.x]) {\r\n      visited[n.y][n.x] = true;\r\n      await carvePassageBetweenAdjacentCoordinates({ x, y }, n, grid, setGrid);\r\n      await carvePassagesFrom(n.x, n.y, grid, setGrid, visited);\r\n    }\r\n  }\r\n};\r\n\r\nexport const RecursiveBacktracking = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  markAllCellsAsWalls(grid, setGrid);\r\n  const [n, m] = [grid.length, grid[0].length];\r\n  const visited: boolean[][] = Array.from(Array(n), () => Array(m).fill(false));\r\n  const { x, y } = randomOddCoordinates(n, m);\r\n  await carvePassagesFrom(x, y, grid, setGrid, visited);\r\n};\r\n","/* eslint-disable @typescript-eslint/no-use-before-define */\r\nimport React from 'react';\r\n\r\nimport { randomNumber, sleep } from '../../utils';\r\nimport { Cell } from '../model/Cell';\r\n\r\nconst addHWall = async (\r\n  grid: Cell[][],\r\n  minX: number,\r\n  maxX: number,\r\n  y: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const hole = Math.floor(randomNumber(minX, maxX) / 2) * 2 + 1;\r\n  for (let i = minX; i <= maxX; i++) {\r\n    if (i === hole) visited[y][i] = true;\r\n    else if (!visited[y][i] && !grid[y][i].isStart && !grid[y][i].isFinish)\r\n      grid[y][i].isWall = true;\r\n  }\r\n  setGrid([...grid]);\r\n  await sleep(1);\r\n};\r\n\r\nconst addVWall = async (\r\n  grid: Cell[][],\r\n  minY: number,\r\n  maxY: number,\r\n  x: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const hole = Math.floor(randomNumber(minY, maxY) / 2) * 2 + 1;\r\n  for (let i = minY; i <= maxY; i++) {\r\n    if (i === hole) visited[i][x] = true;\r\n    else if (!visited[i][x] && !grid[i][x].isStart && !grid[i][x].isFinish)\r\n      grid[i][x].isWall = true;\r\n  }\r\n  setGrid([...grid]);\r\n  await sleep(1);\r\n};\r\n\r\nconst addOuterWalls = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  // vertical walls\r\n  for (let i = 0; i < grid.length; i++) {\r\n    grid[i][0].isWall = true;\r\n    grid[i][grid[0].length - 1].isWall = true;\r\n  }\r\n  // horizontal walls\r\n  for (let i = 0; i < grid[0].length; i++) {\r\n    grid[0][i].isWall = true;\r\n    grid[grid.length - 1][i].isWall = true;\r\n  }\r\n  setGrid([...grid]);\r\n};\r\n\r\nconst divideHorizontally = async (\r\n  grid: Cell[][],\r\n  minX: number,\r\n  maxX: number,\r\n  minY: number,\r\n  maxY: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const y = Math.floor(randomNumber(minY, maxY) / 2) * 2;\r\n  await addHWall(grid, minX, maxX, y, setGrid, visited);\r\n  // upper chamber\r\n  await divide(grid, minX, maxX, minY, y - 1, setGrid, visited);\r\n  // lower chamber\r\n  await divide(grid, minX, maxX, y + 1, maxY, setGrid, visited);\r\n};\r\n\r\nconst divideVertically = async (\r\n  grid: Cell[][],\r\n  minX: number,\r\n  maxX: number,\r\n  minY: number,\r\n  maxY: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  const x = Math.floor(randomNumber(minX, maxX) / 2) * 2;\r\n  await addVWall(grid, minY, maxY, x, setGrid, visited);\r\n  // left chamber\r\n  await divide(grid, minX, x - 1, minY, maxY, setGrid, visited);\r\n  // right chamber\r\n  await divide(grid, x + 1, maxX, minY, maxY, setGrid, visited);\r\n};\r\n\r\nconst divide = async (\r\n  grid: Cell[][],\r\n  minX: number,\r\n  maxX: number,\r\n  minY: number,\r\n  maxY: number,\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  visited: boolean[][]\r\n): Promise<void> => {\r\n  if (maxX - minX < 2 || maxY - minY < 2) return;\r\n  if (maxX - minX < maxY - minY) {\r\n    divideHorizontally(grid, minX, maxX, minY, maxY, setGrid, visited);\r\n  } else if (maxY - minY < maxX - minX) {\r\n    divideVertically(grid, minX, maxX, minY, maxY, setGrid, visited);\r\n  } else {\r\n    if (randomNumber(0, 1) === 0)\r\n      divideHorizontally(grid, minX, maxX, minY, maxY, setGrid, visited);\r\n    else divideVertically(grid, minX, maxX, minY, maxY, setGrid, visited);\r\n  }\r\n};\r\n\r\nexport const RecursiveDivision = async (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  const visited: boolean[][] = Array.from(Array(grid.length), () =>\r\n    Array(grid[0].length).fill(false)\r\n  );\r\n  await addOuterWalls(grid, setGrid);\r\n  await divide(\r\n    grid,\r\n    1,\r\n    grid[0].length - 2,\r\n    1,\r\n    grid.length - 2,\r\n    setGrid,\r\n    visited\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { Cell } from '../model/Cell';\r\nimport { BinaryTree } from './BinaryTree';\r\nimport { Eller } from './Eller';\r\nimport { Kruskal } from './Kruskal';\r\nimport { Prim } from './Prim';\r\nimport { RecursiveBacktracking } from './RecursiveBacktracking';\r\nimport { RecursiveDivision } from './RecursiveDivision';\r\n\r\ntype mazeFunc = (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n) => Promise<void>;\r\n\r\nexport const getMazeAlgorithm = (algorithmType: string): mazeFunc => {\r\n  if (algorithmType === 'division') return RecursiveDivision;\r\n  else if (algorithmType === 'backtracking') return RecursiveBacktracking;\r\n  else if (algorithmType === 'binary') return BinaryTree;\r\n  else if (algorithmType === 'prim') return Prim;\r\n  else if (algorithmType === 'kruskal') return Kruskal;\r\n  else if (algorithmType === 'eller') return Eller;\r\n  else throw new Error('Invalid argument for Maze Algorithm');\r\n};\r\n","import React from 'react';\r\n\r\nimport PriorityQueue from 'ts-priority-queue';\r\n\r\nimport { adjacentCoords, extractPath, isSameCoord, sleep } from '../../utils';\r\nimport { Cell, Coord } from '../model/Cell';\r\nimport { PQEntry, Result } from '../model/PQEntry';\r\n\r\n// _____Different tie breakers_____\r\n/**\r\n * Calulates the Manhattan distance between the given coordinates.\r\n * @param p the first coordinate.\r\n * @param q the second coordinate.\r\n * @returns the Manhattan distance between the two coordinates.\r\n */\r\nconst manhattanDistance = (p: Coord, q: Coord): number =>\r\n  Math.abs(p.x - q.x) + Math.abs(p.y - q.y);\r\n\r\n/**\r\n * Nudge the scale of [h] slightly so that the heuristic favours nodes closer to the goal.\r\n * - Inadmissible heuristic\r\n * From {@link https://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html}\r\n * @param p the current coordinate.\r\n * @param q the target coordinate.\r\n * @returns modified heuristic.\r\n */\r\nconst fudge = (p: Coord, q: Coord): number => {\r\n  const heuristic = manhattanDistance(p, q);\r\n  return heuristic * (1 + 1 / 1000);\r\n};\r\n\r\n/**\r\n * Heuristic that prefers a path that lies along the straight line from the start to the\r\n * goal\r\n * - Inadmissible heuristic\r\n * From {@link https://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html}\r\n * @param start starting coordinate.\r\n * @param p the current coordinate.\r\n * @param q the target coordinate.\r\n * @returns modified heuristic.\r\n */\r\nconst crossProduct = (start: Coord, p: Coord, q: Coord): number => {\r\n  const dx1 = p.x - q.x;\r\n  const dy1 = p.y - q.y;\r\n  const dx2 = start.x - q.x;\r\n  const dy2 = start.y - q.y;\r\n  const cross = Math.abs(dx1 * dy2 - dx2 * dy1);\r\n  const heuristic = manhattanDistance(p, q);\r\n  return heuristic + cross * 0.001;\r\n};\r\n\r\n// Delegate calculation of heuristic\r\nconst guessCost = (\r\n  start: Coord,\r\n  p: Coord,\r\n  q: Coord,\r\n  heuristic = 'manhattan'\r\n): number => {\r\n  if (heuristic === 'manhattan') return manhattanDistance(p, q);\r\n  else if (heuristic === 'fudge') return fudge(p, q);\r\n  else if (heuristic === 'cross') return crossProduct(start, p, q);\r\n  else throw new Error('Invalid heuristic type');\r\n};\r\n\r\n/**\r\n * A* search algorithm\r\n * @param start the starting coordinate.\r\n * @param goal the target coordinate.\r\n * @param grid the grid that has the state of every cell.\r\n * @param setGrid react hook to update the state of the grid.\r\n * @returns the path from start to goal if the algorithm successfully found the target.\r\n */\r\nexport const astar = async (\r\n  start: Coord,\r\n  goal: Coord,\r\n  grid: Cell[][],\r\n  setState: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  heuristic?: string\r\n): Promise<Result> => {\r\n  const [n, m] = [grid.length, grid[0].length];\r\n\r\n  // Auxiliary array keeping track of visited cells\r\n  const visited: boolean[][] = Array.from(Array(n), () => Array(m).fill(false));\r\n\r\n  const pq = new PriorityQueue<PQEntry>({\r\n    comparator: (p1, p2) => {\r\n      // bug: 'if (p1.guessCost)' will return false if p1.guessCost is 0\r\n      if (\r\n        typeof p1.guessCost !== 'undefined' &&\r\n        typeof p2.guessCost !== 'undefined'\r\n      )\r\n        return p1.costToHere + p1.guessCost - (p2.costToHere + p2.guessCost);\r\n      else throw new Error(\"Undefined field 'guessCost' in PQEntry\");\r\n    },\r\n  });\r\n\r\n  // Add starting cell to be searched\r\n  pq.queue({\r\n    coord: start,\r\n    costToHere: 0,\r\n    backPointer: null,\r\n    guessCost: guessCost(start, start, goal, heuristic),\r\n  });\r\n\r\n  while (pq.length !== 0) {\r\n    const entry = pq.dequeue();\r\n\r\n    if (isSameCoord(entry.coord, goal))\r\n      return { success: true, path: extractPath(entry) };\r\n\r\n    if (\r\n      !visited[entry.coord.y][entry.coord.x] &&\r\n      !grid[entry.coord.y][entry.coord.x].isWall\r\n    ) {\r\n      visited[entry.coord.y][entry.coord.x] = true;\r\n\r\n      // mark visited cells\r\n      grid[entry.coord.y][entry.coord.x].isActive = true;\r\n      setState([...grid]);\r\n      await sleep(1);\r\n\r\n      for (const c of adjacentCoords(entry.coord, n, m)) {\r\n        const costToNext = entry.costToHere + 1;\r\n        pq.queue({\r\n          coord: c,\r\n          costToHere: costToNext,\r\n          backPointer: entry,\r\n          guessCost: guessCost(start, c, goal, heuristic),\r\n        });\r\n      }\r\n    }\r\n  }\r\n  return { success: false, path: null };\r\n};\r\n","import React from 'react';\r\n\r\nimport PriorityQueue from 'ts-priority-queue';\r\n\r\nimport {\r\n  adjacentCoords,\r\n  extractPath,\r\n  mergePath,\r\n  reversePath,\r\n  sleep,\r\n} from '../../utils';\r\nimport { Cell, Coord } from '../model/Cell';\r\nimport { PQEntry, Result } from '../model/PQEntry';\r\n\r\n/**\r\n * Bidirectional Uniform-Cost Search\r\n * @param start the starting coordinate.\r\n * @param goal the target coordinate.\r\n * @param grid the grid that has the state of every cell.\r\n * @param setGrid react hook to update the state of the grid.\r\n * @returns the path from start to goal if the algorithm successfully found the target.\r\n */\r\nexport const Bidirectional = async (\r\n  start: Coord,\r\n  goal: Coord,\r\n  grid: Cell[][],\r\n  setState: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<Result> => {\r\n  const [n, m] = [grid.length, grid[0].length];\r\n  // flip-flop variable saying if the current pqueue is the original or the reversed\r\n  let originalPqueue = true;\r\n\r\n  // original pqueue\r\n  let visited: PQEntry[][] = Array.from(Array(n), () => Array(m).fill(null));\r\n  let pqueue = new PriorityQueue<PQEntry>({\r\n    comparator: (p1, p2) => p1.costToHere - p2.costToHere,\r\n  });\r\n  pqueue.queue({ coord: start, costToHere: 0, backPointer: null });\r\n\r\n  // reversed pqueue\r\n  let visitedR: PQEntry[][] = Array.from(Array(n), () => Array(m).fill(null));\r\n  let pqueueR = new PriorityQueue<PQEntry>({\r\n    comparator: (p1, p2) => p1.costToHere - p2.costToHere,\r\n  });\r\n  pqueueR.queue({ coord: goal, costToHere: 0, backPointer: null });\r\n\r\n  while (pqueue.length !== 0 && pqueueR.length !== 0) {\r\n    const entry = pqueue.dequeue();\r\n\r\n    if (visitedR[entry.coord.y][entry.coord.x]) {\r\n      // found a path\r\n      const entryR = reversePath(visitedR[entry.coord.y][entry.coord.x]);\r\n      // reverse the merged path if the current pqueue is not the original one\r\n      const mergedPQEntry = originalPqueue\r\n        ? mergePath(entry, entryR)\r\n        : reversePath(mergePath(entry, entryR));\r\n      return { success: true, path: extractPath(mergedPQEntry) };\r\n    }\r\n\r\n    if (\r\n      !visited[entry.coord.y][entry.coord.x] &&\r\n      !grid[entry.coord.y][entry.coord.x].isWall\r\n    ) {\r\n      visited[entry.coord.y][entry.coord.x] = entry;\r\n\r\n      // mark visited cells\r\n      grid[entry.coord.y][entry.coord.x].isActive = true;\r\n      setState([...grid]);\r\n      await sleep(1);\r\n\r\n      for (const c of adjacentCoords(entry.coord, n, m)) {\r\n        const costToNext = entry.costToHere + 1;\r\n        pqueue.queue({ coord: c, costToHere: costToNext, backPointer: entry });\r\n      }\r\n    }\r\n\r\n    // swap sides\r\n    originalPqueue = !originalPqueue;\r\n    [pqueue, pqueueR] = [pqueueR, pqueue];\r\n    [visited, visitedR] = [visitedR, visited];\r\n  }\r\n  return { success: false, path: null };\r\n};\r\n","import React from 'react';\r\n\r\nimport PriorityQueue from 'ts-priority-queue';\r\n\r\nimport { adjacentCoords, extractPath, isSameCoord, sleep } from '../../utils';\r\nimport { Cell, Coord } from '../model/Cell';\r\nimport { PQEntry, Result } from '../model/PQEntry';\r\n\r\n/**\r\n * Uniform-Cost Search\r\n * @param start the starting coordinate.\r\n * @param goal the target coordinate.\r\n * @param grid the grid that has the state of every cell.\r\n * @param setGrid react hook to update the state of the grid.\r\n * @returns the path from start to goal if the algorithm successfully found the target.\r\n */\r\nexport const UCS = async (\r\n  start: Coord,\r\n  goal: Coord,\r\n  grid: Cell[][],\r\n  setState: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<Result> => {\r\n  const [n, m] = [grid.length, grid[0].length];\r\n\r\n  // Auxiliary array keeping track of visited cells\r\n  const visited: boolean[][] = Array.from(Array(n), () => Array(m).fill(false));\r\n\r\n  const pq = new PriorityQueue<PQEntry>({\r\n    comparator: (p1, p2) => p1.costToHere - p2.costToHere,\r\n  });\r\n\r\n  // Add starting cell to be searched\r\n  pq.queue({ coord: start, costToHere: 0, backPointer: null });\r\n\r\n  while (pq.length !== 0) {\r\n    const entry = pq.dequeue();\r\n\r\n    if (isSameCoord(entry.coord, goal))\r\n      return { success: true, path: extractPath(entry) };\r\n\r\n    if (\r\n      !visited[entry.coord.y][entry.coord.x] &&\r\n      !grid[entry.coord.y][entry.coord.x].isWall\r\n    ) {\r\n      visited[entry.coord.y][entry.coord.x] = true;\r\n\r\n      // mark visited cells\r\n      grid[entry.coord.y][entry.coord.x].isActive = true;\r\n      setState([...grid]);\r\n      await sleep(1);\r\n\r\n      for (const c of adjacentCoords(entry.coord, n, m)) {\r\n        const costToNext = entry.costToHere + 1;\r\n        pq.queue({ coord: c, costToHere: costToNext, backPointer: entry });\r\n      }\r\n    }\r\n  }\r\n  return { success: false, path: null };\r\n};\r\n","import { Cell, Coord } from '../model/Cell';\r\nimport { Result } from '../model/PQEntry';\r\nimport { astar } from './Astar';\r\nimport { Bidirectional } from './Bidirectional';\r\nimport { UCS } from './UCS';\r\n\r\ntype pathfindingFunc = (\r\n  start: Coord,\r\n  finish: Coord,\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>,\r\n  heuristic?: string\r\n) => Promise<Result>;\r\n\r\nexport const getPathfindingAlgorithm = (algorithm: string): pathfindingFunc => {\r\n  if (algorithm === 'ucs') return UCS;\r\n  else if (algorithm === 'astar') return astar;\r\n  else if (algorithm === 'bidirectional') return Bidirectional;\r\n  else throw new Error('Incorrect type for pathfinding algorithm');\r\n};\r\n","import React from 'react';\r\n\r\nimport { ButtonGroup, ToggleButton } from 'react-bootstrap';\r\n\r\ninterface Algorithm {\r\n  name: string;\r\n  value: string;\r\n}\r\n\r\ninterface Props {\r\n  defaultAlgorithm: string;\r\n  algorithms: Algorithm[];\r\n  setAlgorithm: React.Dispatch<React.SetStateAction<string>>;\r\n}\r\n\r\nexport const AlgorithmButtonGroup: React.FC<Props> = ({\r\n  defaultAlgorithm,\r\n  algorithms,\r\n  setAlgorithm,\r\n}: Props) => {\r\n  return (\r\n    <ButtonGroup className=\"p-1\">\r\n      {algorithms.map((alg) => (\r\n        <ToggleButton\r\n          key={alg.value}\r\n          type=\"radio\"\r\n          variant=\"outline-warning\"\r\n          value={alg.value}\r\n          checked={defaultAlgorithm === alg.value}\r\n          onChange={(e) => setAlgorithm(e.currentTarget.value)}\r\n        >\r\n          {alg.name}\r\n        </ToggleButton>\r\n      ))}\r\n    </ButtonGroup>\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { Button } from 'react-bootstrap';\r\n\r\nimport { Cell } from '../../core/model/Cell';\r\nimport './CellButton.css';\r\n\r\ninterface Props {\r\n  cell: Cell;\r\n  mouseDown: boolean;\r\n  onMouseDown: (row: number, col: number) => void;\r\n  onMouseEnter: (row: number, col: number) => void;\r\n  onMouseUp: () => void;\r\n}\r\n\r\nconst cellColor = (cell: Cell): string => {\r\n  if (cell.isWall) return 'grey';\r\n  else if (cell.isStart) return 'yellow';\r\n  else if (cell.isFinish) return 'blue';\r\n  else if (cell.isPath) return 'Chartreuse';\r\n  // or tomato for brighter\r\n  else if (cell.isActive) return 'crimson';\r\n  else return 'azure';\r\n};\r\n\r\nconst cssAnimation = (cell: Cell): string => {\r\n  return cell.isPath ? 'finish' : cell.isActive ? 'visited' : '';\r\n};\r\n\r\nexport const CellButton: React.FC<Props> = ({\r\n  cell,\r\n  mouseDown,\r\n  onMouseDown,\r\n  onMouseEnter,\r\n  onMouseUp,\r\n}: Props) => {\r\n  return (\r\n    <Button\r\n      className={`cell ${cssAnimation(cell)}`}\r\n      style={{\r\n        backgroundColor: cellColor(cell),\r\n      }}\r\n      onMouseEnter={() => {\r\n        if (mouseDown) onMouseEnter(cell.coord.y, cell.coord.x);\r\n      }}\r\n      onMouseDown={() => onMouseDown(cell.coord.y, cell.coord.x)}\r\n      onMouseUp={onMouseUp}\r\n    />\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { Cell, Coord } from '../../core/model/Cell';\r\nimport { CellButton } from './CellButton';\r\n\r\ninterface Props {\r\n  grid: Cell[][];\r\n  mode: string;\r\n  setMode: React.Dispatch<React.SetStateAction<string>>;\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>;\r\n  start: Coord;\r\n  setStart: React.Dispatch<React.SetStateAction<Coord>>;\r\n  finish: Coord;\r\n  setFinish: React.Dispatch<React.SetStateAction<Coord>>;\r\n  searching: boolean;\r\n}\r\n\r\nexport const Grid: React.FC<Props> = ({\r\n  grid,\r\n  mode,\r\n  setMode,\r\n  setGrid,\r\n  start,\r\n  setStart,\r\n  finish,\r\n  setFinish,\r\n  searching,\r\n}: Props) => {\r\n  const [mouseDown, setMouseDown] = React.useState<boolean>(false);\r\n\r\n  const toggleWall = (row: number, col: number): void => {\r\n    const cell = grid[row][col];\r\n    if (!cell.isStart && !cell.isFinish) {\r\n      cell.isWall = !cell.isWall;\r\n      setGrid([...grid]);\r\n    }\r\n  };\r\n\r\n  const moveStart = (row: number, col: number): void => {\r\n    grid[start.y][start.x].isStart = false;\r\n    const cell: Cell = grid[row][col];\r\n    cell.isStart = true;\r\n    setStart(cell.coord);\r\n    setGrid([...grid]);\r\n  };\r\n\r\n  const moveFinish = (row: number, col: number): void => {\r\n    grid[finish.y][finish.x].isFinish = false;\r\n    const cell = grid[row][col];\r\n    cell.isFinish = true;\r\n    setFinish(cell.coord);\r\n    setGrid([...grid]);\r\n  };\r\n\r\n  const handleMouseUp = (): void => setMouseDown(false);\r\n\r\n  const handleMouseDown = (row: number, col: number): void => {\r\n    if (grid[row][col].isStart) setMode('start');\r\n    else if (grid[row][col].isFinish) setMode('finish');\r\n    else {\r\n      setMode('wall');\r\n      toggleWall(row, col);\r\n    }\r\n    setMouseDown(true);\r\n  };\r\n\r\n  const handleMouseEnter = (row: number, col: number): void => {\r\n    if (mouseDown) {\r\n      if (mode === 'wall') toggleWall(row, col);\r\n      else if (mode === 'start' && !searching) moveStart(row, col);\r\n      else if (mode === 'finish' && !searching) moveFinish(row, col);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      {/* 🐰 🥚 */}\r\n      <button\r\n        style={{\r\n          background: 'transparent',\r\n          border: 'none',\r\n          outline: 'none',\r\n          display: 'block',\r\n          height: '5px',\r\n          width: '5px',\r\n          cursor: 'pointer',\r\n          marginBottom: '5px',\r\n        }}\r\n        onClick={() => {\r\n          for (let i = 0; i < grid.length; i++) {\r\n            grid[i][0].isWall = true;\r\n            grid[i][grid[0].length - 1].isWall = true;\r\n          }\r\n          // horizontal walls\r\n          for (let i = 0; i < grid[0].length; i++) {\r\n            grid[0][i].isWall = true;\r\n            grid[grid.length - 1][i].isWall = true;\r\n          }\r\n          for (let i = 0; i < grid.length - 1; i++) {\r\n            for (let j = 0; j < grid[0].length - 1; j++) {\r\n              if (i % 2 === 0 && j % 2 === 0) grid[i][j].isWall = true;\r\n            }\r\n          }\r\n          setGrid([...grid]);\r\n        }}\r\n      />\r\n      <div\r\n        onMouseDown={() => {\r\n          setMouseDown(true);\r\n        }}\r\n        onMouseUp={() => {\r\n          setMouseDown(false);\r\n        }}\r\n        onMouseLeave={() => {\r\n          setMouseDown(false);\r\n        }}\r\n      >\r\n        {grid.map((row, i) => (\r\n          <div key={i}>\r\n            {row.map((c, j) => (\r\n              <CellButton\r\n                cell={c}\r\n                key={j}\r\n                mouseDown={mouseDown}\r\n                onMouseDown={handleMouseDown}\r\n                onMouseEnter={handleMouseEnter}\r\n                onMouseUp={handleMouseUp}\r\n              />\r\n            ))}\r\n          </div>\r\n        ))}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { Popover } from 'react-bootstrap';\r\n\r\n/**\r\n * Basic popover explaining the different ways to calculate heuristic for A*\r\n */\r\nexport const popover = (\r\n  <Popover id=\"popover-basic\">\r\n    <Popover.Title as=\"h3\">A* Heuristic</Popover.Title>\r\n    <Popover.Content>\r\n      Different methods of calculating the heuristic in A*\r\n      <ul>\r\n        <li>\r\n          <strong>Manhattan distance</strong>:\r\n          <ul>\r\n            <li>Guarantees shortest path.</li>\r\n            <li>Trading speed for accuracy.</li>\r\n          </ul>\r\n        </li>\r\n        <li>\r\n          <strong>Fudge</strong>:\r\n          <ul>\r\n            <li>\r\n              Similar to A* except that the heuristic favours nodes closer to\r\n              the target.\r\n            </li>\r\n            <li>Finds a more direct route.</li>\r\n            <li>Inadmissible heuristic.</li>\r\n          </ul>\r\n        </li>\r\n        <li>\r\n          <strong>Cross</strong>:\r\n          <ul>\r\n            <li>\r\n              Prefers path that are along the straight line from the starting\r\n              point to the target.\r\n            </li>\r\n            <li>Nicer diagonal paths.</li>\r\n            <li>Inadmissible heuristic.</li>\r\n          </ul>\r\n        </li>\r\n      </ul>\r\n    </Popover.Content>\r\n  </Popover>\r\n);\r\n","import React from 'react';\r\n\r\nimport {\r\n  Button,\r\n  Dropdown,\r\n  DropdownButton,\r\n  OverlayTrigger,\r\n  SplitButton,\r\n} from 'react-bootstrap';\r\n\r\nimport { popover } from './Popover';\r\n\r\ninterface NameValue {\r\n  name: string;\r\n  value: string;\r\n}\r\n\r\ninterface Props {\r\n  algorithm: string;\r\n  AlgorithmButtonGroup: React.ReactNode;\r\n  heuristic: string;\r\n  heuristics: NameValue[];\r\n  setHeuristic: React.Dispatch<React.SetStateAction<string>>;\r\n  resetGrid: () => void;\r\n  removePath: () => void;\r\n  search: () => Promise<void>;\r\n  mazes: NameValue[];\r\n  generateMaze: (algorithmType: string) => Promise<void>;\r\n}\r\n\r\nexport const Panel: React.FC<Props> = ({\r\n  algorithm,\r\n  AlgorithmButtonGroup,\r\n  heuristic,\r\n  heuristics,\r\n  setHeuristic,\r\n  resetGrid,\r\n  removePath,\r\n  search,\r\n  mazes,\r\n  generateMaze,\r\n}: Props) => {\r\n  return (\r\n    <div className=\"app-center\">\r\n      <DropdownButton variant=\"success\" title=\"Mazes\" menuAlign=\"left\">\r\n        {mazes.map((m, i) => (\r\n          <Dropdown.Item\r\n            as=\"button\"\r\n            key={i}\r\n            onClick={() => generateMaze(m.value)}\r\n          >\r\n            {m.name}\r\n          </Dropdown.Item>\r\n        ))}\r\n      </DropdownButton>\r\n      <SplitButton\r\n        id=\"reset\"\r\n        className=\"m-2\"\r\n        variant=\"danger\"\r\n        title={'Reset'}\r\n        toggleLabel=\"\"\r\n        onClick={resetGrid}\r\n      >\r\n        <Dropdown.Item onClick={removePath}>Clear path</Dropdown.Item>\r\n      </SplitButton>\r\n      <Button onClick={search} variant=\"primary\" className=\"m-1\">\r\n        Search!\r\n      </Button>\r\n      {AlgorithmButtonGroup}\r\n      <OverlayTrigger placement=\"right\" overlay={popover}>\r\n        <DropdownButton\r\n          alignRight={true}\r\n          className=\"m-1\"\r\n          variant=\"secondary\"\r\n          title={heuristic.charAt(0).toUpperCase() + heuristic.slice(1)}\r\n          disabled={algorithm !== 'astar'}\r\n        >\r\n          {heuristics.map((h) => (\r\n            <Dropdown.Item\r\n              as=\"button\"\r\n              key={h.value}\r\n              onClick={() => setHeuristic(h.value)}\r\n            >\r\n              {h.name}\r\n            </Dropdown.Item>\r\n          ))}\r\n        </DropdownButton>\r\n      </OverlayTrigger>\r\n    </div>\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport { Col, Container, Row } from 'react-bootstrap';\r\n\r\nimport { getMazeAlgorithm } from '../../core/maze/MazeFactory';\r\nimport { Cell, Coord } from '../../core/model/Cell';\r\nimport { Result } from '../../core/model/PQEntry';\r\nimport { getPathfindingAlgorithm } from '../../core/pathfinding/PathfindingFactory';\r\nimport { closestOddCoord, sleep } from '../../utils';\r\nimport { AlgorithmButtonGroup } from '../common/AlgorithmButtonGroup';\r\nimport { Grid } from './Grid';\r\nimport { Panel } from './Panel';\r\n\r\nconst algorithms = [\r\n  { name: 'UCS', value: 'ucs' },\r\n  { name: 'A*', value: 'astar' },\r\n  { name: 'Bidirectional search', value: 'bidirectional' },\r\n];\r\nconst mazes = [\r\n  { name: 'Recursive Division', value: 'division' },\r\n  { name: 'Recursive Backtracking', value: 'backtracking' },\r\n  { name: 'Binary Tree (Southeast bias)', value: 'binary' },\r\n  { name: \"Prim's Algorithm\", value: 'prim' },\r\n  { name: \"Kruskal's Algorithm\", value: 'kruskal' },\r\n  { name: \"Eller's Algorithm\", value: 'eller' },\r\n];\r\nconst heuristics = [\r\n  { name: 'Manhattan distance', value: 'manhattan' },\r\n  { name: 'Fudge', value: 'fudge' },\r\n  { name: 'Cross', value: 'cross' },\r\n];\r\n\r\n// Calculate how many cells fit the screen horizontally and vertically\r\nconst calculateCells = (): [number, number] => {\r\n  const noHorizontalCells = Math.floor(window.innerWidth / 30);\r\n  const noVerticalCells = Math.floor((window.innerHeight - 130) / 30);\r\n  // maze algorithm requires maze to have odd size\r\n  return [\r\n    noHorizontalCells % 2 === 0 ? noHorizontalCells - 1 : noHorizontalCells,\r\n    noVerticalCells % 2 === 0 ? noVerticalCells - 1 : noVerticalCells,\r\n  ];\r\n};\r\n\r\nconst newGrid = (start: Coord, finish: Coord): Cell[][] => {\r\n  const [n, m] = calculateCells();\r\n  const grid: Cell[][] = [...Array(m)].map((_, i) => {\r\n    return [...Array(n)].map((_, j) => ({\r\n      coord: { x: j, y: i },\r\n      isActive: false,\r\n      isPath: false,\r\n      isStart: false,\r\n      isFinish: false,\r\n      isWall: false,\r\n    }));\r\n  });\r\n  grid[start.y][start.x].isStart = true;\r\n  grid[finish.y][finish.x].isFinish = true;\r\n  return grid;\r\n};\r\n\r\nconst removePath = (\r\n  grid: Cell[][],\r\n  setGrid: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): void => {\r\n  for (let row = 0; row < grid.length; row++)\r\n    for (let col = 0; col < grid[0].length; col++) {\r\n      const cell = grid[row][col];\r\n      if (cell.isPath) cell.isPath = false;\r\n      if (cell.isActive) cell.isActive = false;\r\n    }\r\n  setGrid([...grid]);\r\n};\r\n\r\n// Draw the path received from pathfinding algorithm\r\nconst drawPath = async (\r\n  res: Result,\r\n  grid: Cell[][],\r\n  setState: React.Dispatch<React.SetStateAction<Cell[][]>>\r\n): Promise<void> => {\r\n  if (res.path) {\r\n    for (const c of res.path) {\r\n      grid[c.y][c.x].isPath = true;\r\n      setState([...grid]);\r\n      await sleep(1);\r\n    }\r\n  }\r\n};\r\n\r\nexport const PathfindingVisualizer: React.FC = () => {\r\n  const [algorithm, setAlgorithm] = React.useState<string>('ucs');\r\n  // to disable moving starting and finish cells during search\r\n  const [searching, setSearching] = React.useState<boolean>(false);\r\n  const [start, setStart] = React.useState<Coord>({ x: 1, y: 3 });\r\n  const [finish, setFinish] = React.useState<Coord>({ x: 7, y: 3 });\r\n  const [grid, setGrid] = React.useState<Cell[][]>(newGrid(start, finish));\r\n  const [mode, setMode] = React.useState<string>('wall');\r\n  const [heuristic, setHeuristic] = React.useState<string>('manhattan');\r\n\r\n  const search = async (): Promise<void> => {\r\n    const searcher = getPathfindingAlgorithm(algorithm);\r\n    setSearching(true);\r\n    await searcher(start, finish, grid, setGrid, heuristic).then(\r\n      async (res) => {\r\n        if (res.success) await drawPath(res, grid, setGrid);\r\n      }\r\n    );\r\n    setSearching(false);\r\n  };\r\n\r\n  // Move start and finish to odd coordinates (if they aren't already on odd coordinates)\r\n  const relocateStartAndFinishToOddCoords = (): void => {\r\n    grid[start.y][start.x].isStart = false;\r\n    grid[finish.y][finish.x].isFinish = false;\r\n    const newStart = closestOddCoord(start);\r\n    const newFinish = closestOddCoord(finish);\r\n    grid[newStart.y][newStart.x].isStart = true;\r\n    grid[newFinish.y][newFinish.x].isFinish = true;\r\n    setGrid([...grid]);\r\n    setStart(newStart);\r\n    setFinish(newFinish);\r\n  };\r\n\r\n  const generateMaze = async (algorithmType: string): Promise<void> => {\r\n    relocateStartAndFinishToOddCoords();\r\n    const mazeGenerator = getMazeAlgorithm(algorithmType);\r\n    await mazeGenerator(grid, setGrid);\r\n  };\r\n\r\n  return (\r\n    <Container fluid={true} style={{ padding: '0' }}>\r\n      <Row>\r\n        <Col>\r\n          <Panel\r\n            AlgorithmButtonGroup={\r\n              <AlgorithmButtonGroup\r\n                defaultAlgorithm={algorithm}\r\n                algorithms={algorithms}\r\n                setAlgorithm={setAlgorithm}\r\n              />\r\n            }\r\n            algorithm={algorithm}\r\n            heuristic={heuristic}\r\n            heuristics={heuristics}\r\n            setHeuristic={setHeuristic}\r\n            resetGrid={() => setGrid(newGrid(start, finish))}\r\n            removePath={() => removePath(grid, setGrid)}\r\n            search={search}\r\n            mazes={mazes}\r\n            generateMaze={generateMaze}\r\n          />\r\n        </Col>\r\n      </Row>\r\n      <Row className=\"justify-content-center\">\r\n        <Col md=\"auto\" className=\"app-center\">\r\n          <Grid\r\n            grid={grid}\r\n            mode={mode}\r\n            setMode={setMode}\r\n            setGrid={setGrid}\r\n            start={start}\r\n            setStart={setStart}\r\n            finish={finish}\r\n            setFinish={setFinish}\r\n            searching={searching}\r\n          />\r\n        </Col>\r\n      </Row>\r\n    </Container>\r\n  );\r\n};\r\n","export type Color = '#FF0000' | '#0000FF' | '#7CFC00';\r\nexport const RED: Color = '#FF0000';\r\nexport const BLUE: Color = '#0000FF';\r\nexport const GREEN: Color = '#7CFC00';\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN, BLUE } from '../model/Color';\r\n\r\nconst animation = async (\r\n  bars: Bar[],\r\n  j: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  bars[j].color = RED;\r\n  bars[j + 1].color = GREEN;\r\n  setState([...bars]);\r\n  await sleep(delay);\r\n  bars[j].color = BLUE;\r\n  bars[j + 1].color = BLUE;\r\n};\r\n\r\nexport const bubbleSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  const n: number = bars.length;\r\n  let greatestElementIndex: number = bars.length;\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    for (let j = 0; j < n - 1; j++) {\r\n      if (bars[j].num > bars[j + 1].num) {\r\n        swap(bars, j, j + 1);\r\n        await animation(bars, j, setState, delay);\r\n      }\r\n\r\n      if (j === greatestElementIndex - 2) {\r\n        // make the iteration's greatest element green (sorted partition)\r\n        greatestElementIndex--;\r\n        bars[greatestElementIndex].color = RED;\r\n        setState([...bars]);\r\n      }\r\n    }\r\n  }\r\n};\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN, BLUE } from '../model/Color';\r\n\r\nexport const cocktailSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  let swapped = true;\r\n  let start = 0;\r\n  let end = bars.length;\r\n\r\n  while (swapped) {\r\n    swapped = false;\r\n\r\n    // bottom to top\r\n    for (let i = start; i < end - 1; i++) {\r\n      if (bars[i].num > bars[i + 1].num) {\r\n        swap(bars, i, i + 1);\r\n        swapped = true;\r\n      }\r\n      bars[i].color = BLUE;\r\n      bars[i + 1].color = GREEN;\r\n      setState([...bars]);\r\n      await sleep(delay);\r\n    }\r\n\r\n    // mark this iterations greatest element\r\n    bars[end - 1].color = RED;\r\n    setState([...bars]);\r\n\r\n    // exit if sorted\r\n    if (!swapped) break;\r\n\r\n    swapped = false;\r\n    end--;\r\n\r\n    // top to bottom\r\n    for (let i = end - 1; i >= start; i--) {\r\n      if (bars[i].num > bars[i + 1].num) {\r\n        swap(bars, i, i + 1);\r\n        swapped = true;\r\n      }\r\n      if (i !== end - 1) bars[i + 1].color = BLUE;\r\n      bars[i].color = GREEN;\r\n      setState([...bars]);\r\n      await sleep(delay);\r\n    }\r\n    // mark this iterations smallest element\r\n    bars[start].color = RED;\r\n    setState([...bars]);\r\n\r\n    start++;\r\n  }\r\n};\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, BLUE } from '../model/Color';\r\n\r\nconst animation = async (\r\n  bars: Bar[],\r\n  x: number,\r\n  y: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  bars[x].color = RED;\r\n  bars[y].color = RED;\r\n  setState([...bars]);\r\n  await sleep(delay);\r\n  bars[x].color = BLUE;\r\n  bars[y].color = BLUE;\r\n  setState([...bars]);\r\n};\r\n\r\nconst heapify = async (\r\n  bars: Bar[],\r\n  n: number,\r\n  i: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  let largest = i;\r\n  const left = 2 * i + 1;\r\n  const right = 2 * i + 2;\r\n\r\n  if (left < n && bars[left].num > bars[largest].num) largest = left;\r\n\r\n  if (right < n && bars[right].num > bars[largest].num) largest = right;\r\n\r\n  if (largest !== i) {\r\n    swap(bars, i, largest);\r\n    await animation(bars, i, largest, setState, delay);\r\n    // recursively heapify sub-tree\r\n    await heapify(bars, n, largest, setState, delay);\r\n  }\r\n};\r\n\r\nexport const heapSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  const n = bars.length;\r\n\r\n  // build max-heap\r\n  for (let i = Math.floor(n / 2 - 1); i >= 0; i--) {\r\n    await heapify(bars, n, i, setState, delay);\r\n  }\r\n\r\n  for (let i = n - 1; i > 0; i--) {\r\n    // Move root to the end\r\n    swap(bars, 0, i, setState);\r\n\r\n    // mark sorted partition\r\n    bars[i].color = RED;\r\n\r\n    // heapify reduced heap\r\n    await heapify(bars, i, 0, setState, delay);\r\n  }\r\n};\r\n","import React, { SetStateAction } from 'react';\r\n\r\nimport { sleep } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN } from '../model/Color';\r\n\r\nexport const insertionSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  const n: number = bars.length;\r\n\r\n  bars[0].color = RED;\r\n\r\n  for (let i = 1; i < n; i++) {\r\n    const value: Bar = bars[i];\r\n    let hole: number = i;\r\n\r\n    bars[hole].color = RED;\r\n\r\n    while (hole > 0 && bars[hole - 1].num > value.num) {\r\n      await sleep(delay);\r\n      bars[hole] = bars[hole - 1];\r\n\r\n      bars[hole].color = GREEN;\r\n      if (hole + 1 < bars.length) bars[hole + 1].color = RED;\r\n\r\n      setState([...bars]);\r\n      hole--;\r\n    }\r\n\r\n    bars[hole].color = RED;\r\n\r\n    bars[hole] = value;\r\n    setState([...bars]);\r\n  }\r\n};\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, BLUE } from '../model/Color';\r\n\r\nconst nextGap = (gap: number): number => (gap <= 1 ? 0 : Math.ceil(gap / 2.0));\r\n\r\nconst animation = async (\r\n  bars: Bar[],\r\n  x: number,\r\n  y: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  bars[x].color = RED;\r\n  bars[y].color = RED;\r\n\r\n  setState([...bars]);\r\n  await sleep(delay);\r\n\r\n  bars[x].color = BLUE;\r\n  bars[y].color = BLUE;\r\n};\r\n\r\n/**\r\n * In-place Merge Sort\r\n *\r\n * Approach 2 from {@link https://www.geeksforgeeks.org/in-place-merge-sort/}.\r\n *\r\n * @param bars The array to be sorted.\r\n * @param start The left index of the array.\r\n * @param end The right index of the array.\r\n * @param setState Hook for changing the state.\r\n * @param delay Time in between each animation.\r\n */\r\nconst inPlaceMerge = async (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  let gap: number = end - start + 1;\r\n\r\n  for (gap = nextGap(gap); gap > 0; gap = nextGap(gap)) {\r\n    for (let i = start; i + gap <= end; i++) {\r\n      const j = i + gap;\r\n      if (bars[i].num > bars[j].num) {\r\n        swap(bars, i, j);\r\n        await animation(bars, i, j, setState, delay);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nconst _sort = async (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  if (start === end) return;\r\n\r\n  const mid = Math.floor((start + end) / 2);\r\n  await _sort(bars, start, mid, setState, delay);\r\n  await _sort(bars, mid + 1, end, setState, delay);\r\n\r\n  await inPlaceMerge(bars, start, end, setState, delay);\r\n};\r\n\r\nexport const mergeSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  await _sort(bars, 0, bars.length - 1, setState, delay);\r\n};\r\n","import React from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN, BLUE } from '../model/Color';\r\n\r\nconst animation = async (\r\n  bars: Bar[],\r\n  i: number,\r\n  partitionIndex: number,\r\n  start: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  bars[i].color = GREEN;\r\n  bars[partitionIndex].color = RED;\r\n  setState([...bars]);\r\n  await sleep(delay);\r\n  if (i !== start) {\r\n    // only reset indices after start\r\n    bars[i].color = BLUE;\r\n    bars[partitionIndex].color = BLUE;\r\n  }\r\n};\r\n\r\n/**\r\n * Median of three\r\n *\r\n * Puts the median at the last index of the array and returns the pivot value\r\n *\r\n * @param bars The array to be sorted.\r\n * @param start The left index of the array.\r\n * @param end The right index of the array.\r\n * @returns The pivot value.\r\n */\r\nconst getMedian = (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>\r\n): number => {\r\n  const midpoint: number = Math.floor((start + end) / 2);\r\n  if (bars[start].num > bars[midpoint].num) swap(bars, start, midpoint);\r\n  if (bars[start] > bars[end]) swap(bars, start, end);\r\n  if (bars[midpoint] > bars[end]) swap(bars, midpoint, end);\r\n\r\n  swap(bars, midpoint, end, setState);\r\n  return bars[end].num;\r\n};\r\n\r\nconst partition = async (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<number> => {\r\n  const pivotIndex: number = end;\r\n  const pivot = getMedian(bars, start, end, setState);\r\n  let partitionIndex = start;\r\n\r\n  // Mark pivot\r\n  bars[pivotIndex].color = RED;\r\n  setState([...bars]);\r\n\r\n  for (let i = start; i < end; i++) {\r\n    if (bars[i].num <= pivot) {\r\n      swap(bars, i, partitionIndex, setState);\r\n\r\n      await animation(bars, i, partitionIndex, start, setState, delay);\r\n\r\n      partitionIndex++;\r\n    }\r\n  }\r\n\r\n  // Unmark pivot and starting pointer\r\n  bars[start].color = BLUE;\r\n  bars[pivotIndex].color = BLUE;\r\n  setState([...bars]);\r\n\r\n  swap(bars, partitionIndex, pivotIndex, setState);\r\n  return partitionIndex;\r\n};\r\n\r\nconst _sort = async (\r\n  bars: Bar[],\r\n  start: number,\r\n  end: number,\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  if (start < end) {\r\n    const partitionIndex: number = await partition(\r\n      bars,\r\n      start,\r\n      end,\r\n      setState,\r\n      delay\r\n    );\r\n    await _sort(bars, start, partitionIndex - 1, setState, delay);\r\n    await _sort(bars, partitionIndex + 1, end, setState, delay);\r\n  }\r\n};\r\n\r\nexport const quicksort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  await _sort(bars, 0, bars.length - 1, setState, delay);\r\n};\r\n","import React, { SetStateAction } from 'react';\r\n\r\nimport { sleep, swap } from '../../utils';\r\nimport { Bar } from '../model/Bar';\r\nimport { RED, GREEN, BLUE } from '../model/Color';\r\n\r\nexport const selectionSort = async (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<SetStateAction<Bar[]>>,\r\n  delay: number\r\n): Promise<void> => {\r\n  const n: number = bars.length;\r\n  for (let i = 0; i < n - 1; i++) {\r\n    let iMin: number = i;\r\n    for (let j: number = i + 1; j < n; j++) {\r\n      if (bars[j].num < bars[iMin].num) iMin = j;\r\n\r\n      if (j === n - 1) {\r\n        // Mark the smallest element in the unsorted array\r\n        bars[iMin].color = GREEN;\r\n        setState([...bars]);\r\n      }\r\n    }\r\n\r\n    swap(bars, i, iMin);\r\n\r\n    await sleep(delay);\r\n    bars[iMin].color = BLUE; // Unmark\r\n    bars[i].color = RED;\r\n    setState([...bars]);\r\n  }\r\n\r\n  // manually make last element red cause yeah\r\n  bars[bars.length - 1].color = RED;\r\n  setState([...bars]);\r\n};\r\n","import { Bar } from '../model/Bar';\r\nimport { bubbleSort } from './BubbleSort';\r\nimport { cocktailSort } from './CocktailSort';\r\nimport { heapSort } from './HeapSort';\r\nimport { insertionSort } from './InsertionSort';\r\nimport { mergeSort } from './MergeSort';\r\nimport { quicksort } from './QuickSort';\r\nimport { selectionSort } from './SelectionSort';\r\n\r\ntype sortingFunc = (\r\n  bars: Bar[],\r\n  setState: React.Dispatch<React.SetStateAction<Bar[]>>,\r\n  delay: number\r\n) => Promise<void>;\r\n\r\nexport const getSortingAlgorithm = (algorithm: string): sortingFunc => {\r\n  if (algorithm === 'selection') return selectionSort;\r\n  else if (algorithm === 'insertion') return insertionSort;\r\n  else if (algorithm === 'bubble') return bubbleSort;\r\n  else if (algorithm === 'quick') return quicksort;\r\n  else if (algorithm === 'merge') return mergeSort;\r\n  else if (algorithm === 'cocktail') return cocktailSort;\r\n  else if (algorithm === 'heap') return heapSort;\r\n  else throw new Error('Incorrect type for sorting algorithm');\r\n};\r\n","import React, { SetStateAction } from 'react';\r\n\r\nimport { Button } from 'react-bootstrap';\r\n\r\nimport { Bar } from '../../core/model/Bar';\r\n\r\ninterface Props {\r\n  num: number;\r\n  handleNumberChange: (e: React.ChangeEvent<HTMLInputElement>) => void;\r\n  sort: () => Promise<void>;\r\n  reset: () => void;\r\n  setBars: React.Dispatch<SetStateAction<Bar[]>>;\r\n  delay: number;\r\n  setDelay: React.Dispatch<SetStateAction<number>>;\r\n}\r\n\r\nexport const Panel: React.FC<Props> = ({\r\n  num,\r\n  handleNumberChange,\r\n  sort,\r\n  reset,\r\n  delay,\r\n  setDelay,\r\n}: Props) => {\r\n  const renderRangeSlider = (): JSX.Element => (\r\n    <label className=\"mx-2\" style={{ width: '10%', textAlign: 'left' }}>\r\n      Delay\r\n      <input\r\n        name=\"foo\"\r\n        type=\"range\"\r\n        min=\"1\"\r\n        max=\"100\"\r\n        value={delay}\r\n        className=\"slider\"\r\n        onChange={(e) => setDelay(parseInt(e.target.value))}\r\n      />\r\n    </label>\r\n  );\r\n\r\n  return (\r\n    <span>\r\n      {renderRangeSlider()}\r\n      <input\r\n        className=\"input-number\"\r\n        name=\"no. bars\"\r\n        type=\"number\"\r\n        value={num}\r\n        step={5}\r\n        min=\"5\"\r\n        max=\"150\"\r\n        onChange={handleNumberChange}\r\n        onKeyDown={(e) => e.preventDefault()}\r\n      />\r\n      <Button onClick={reset} className=\"mx-2\" variant=\"danger\">\r\n        Reset\r\n      </Button>\r\n      <Button onClick={sort}>Sort</Button>\r\n    </span>\r\n  );\r\n};\r\n","import React, { useState, useEffect } from 'react';\r\n\r\nimport './SortingVisualizer.css';\r\nimport { Col, Container, Row } from 'react-bootstrap';\r\n\r\nimport { Bar } from '../../core/model/Bar';\r\nimport { BLUE, GREEN } from '../../core/model/Color';\r\nimport { getSortingAlgorithm } from '../../core/sorting/SortingFactory';\r\nimport { sleep } from '../../utils';\r\nimport { AlgorithmButtonGroup } from '../common/AlgorithmButtonGroup';\r\nimport { Panel } from './Panel';\r\n\r\nconst algorithms = [\r\n  { name: 'Insertion Sort', value: 'insertion' },\r\n  { name: 'Selection Sort', value: 'selection' },\r\n  { name: 'Bubble Sort', value: 'bubble' },\r\n  { name: 'Quicksort', value: 'quick' },\r\n  { name: 'Merge Sort', value: 'merge' },\r\n  { name: 'Cocktail Sort', value: 'cocktail' },\r\n  { name: 'Heap Sort', value: 'heap' },\r\n];\r\n\r\nexport const SortingVisualizer: React.FC = () => {\r\n  const [bars, setBars] = useState<Bar[]>([]);\r\n  const [num, setNum] = useState<number>(90);\r\n  const [algorithm, setAlgorithm] = useState<string>('insertion');\r\n  const [delay, setDelay] = useState<number>(1);\r\n\r\n  const resetBars = (): void =>\r\n    setBars(\r\n      [...Array(num)].map(() => ({\r\n        num: Math.floor(Math.random() * 80) + 1,\r\n        color: BLUE,\r\n      }))\r\n    );\r\n\r\n  useEffect((): void => {\r\n    resetBars();\r\n  }, [num]); // eslint-disable-line react-hooks/exhaustive-deps\r\n\r\n  // Green progressive animation\r\n  const finish = async (\r\n    bars: Bar[],\r\n    setState: React.Dispatch<React.SetStateAction<Bar[]>>\r\n  ): Promise<void> => {\r\n    for (let i = 0; i < bars.length; i++) {\r\n      bars[i].color = GREEN;\r\n      setState([...bars]);\r\n      await sleep(1);\r\n    }\r\n  };\r\n\r\n  const sort = async (): Promise<void> => {\r\n    const sorter = getSortingAlgorithm(algorithm);\r\n    await sorter(bars, setBars, delay);\r\n    await finish(bars, setBars);\r\n  };\r\n\r\n  const handleNumberChange = (e: React.ChangeEvent<HTMLInputElement>): void => {\r\n    const { value, min, max } = e.target;\r\n    setNum(Math.max(Number(min), Math.min(Number(max), Number(value))));\r\n  };\r\n\r\n  const renderBars = (): JSX.Element => (\r\n    <div className=\"sorting-container\">\r\n      {bars.map((bar: Bar, idx) => (\r\n        <div\r\n          key={`b-${idx}`}\r\n          className=\"bar\"\r\n          style={{\r\n            backgroundColor: `${bar.color}`,\r\n            width: '1vw',\r\n            height: `${bar.num}vmin`,\r\n          }}\r\n        />\r\n      ))}\r\n    </div>\r\n  );\r\n\r\n  return (\r\n    <Container fluid={true} style={{ padding: '0' }}>\r\n      <Row className=\"app-vanish text-center justify-content-center\">\r\n        <Col md=\"auto\">\r\n          <Panel\r\n            num={num}\r\n            handleNumberChange={handleNumberChange}\r\n            reset={resetBars}\r\n            setBars={setBars}\r\n            sort={sort}\r\n            delay={delay}\r\n            setDelay={setDelay}\r\n          />\r\n          <AlgorithmButtonGroup\r\n            defaultAlgorithm={algorithm}\r\n            algorithms={algorithms}\r\n            setAlgorithm={setAlgorithm}\r\n          />\r\n        </Col>\r\n      </Row>\r\n      <Row className=\"justify-content-center\">\r\n        <Col md=\"auto\">{renderBars()}</Col>\r\n      </Row>\r\n    </Container>\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport './App.css';\r\nimport { HashRouter as Router, Switch, Route } from 'react-router-dom';\r\n\r\nimport { Header } from './components/common/Header';\r\nimport { PathfindingVisualizer } from './components/pathfinding/PathfindingVisualizer';\r\nimport { SortingVisualizer } from './components/sorting/SortingVisualizer';\r\n\r\nconst App = (): JSX.Element => {\r\n  return (\r\n    <Router>\r\n      <Header />\r\n      <Switch>\r\n        <Route path=\"/sorting\" component={SortingVisualizer} />\r\n        <Route\r\n          exact\r\n          path={['/', '/pathfinding']}\r\n          component={PathfindingVisualizer}\r\n        />\r\n      </Switch>\r\n    </Router>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React from 'react';\r\n\r\nimport ReactDOM from 'react-dom';\r\n\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}